
zephyr.elf:     file format elf64-x86-64


Disassembly of section .init:

0000000000002000 <_init>:
    2000:	f3 0f 1e fa          	endbr64 
    2004:	48 83 ec 08          	sub    $0x8,%rsp
    2008:	48 8b 05 c1 7f 00 00 	mov    0x7fc1(%rip),%rax        # 9fd0 <__gmon_start__>
    200f:	48 85 c0             	test   %rax,%rax
    2012:	74 02                	je     2016 <_init+0x16>
    2014:	ff d0                	callq  *%rax
    2016:	48 83 c4 08          	add    $0x8,%rsp
    201a:	c3                   	retq   

Disassembly of section .plt:

0000000000002020 <.plt>:
    2020:	ff 35 3a 7e 00 00    	pushq  0x7e3a(%rip)        # 9e60 <_GLOBAL_OFFSET_TABLE_+0x8>
    2026:	f2 ff 25 3b 7e 00 00 	bnd jmpq *0x7e3b(%rip)        # 9e68 <_GLOBAL_OFFSET_TABLE_+0x10>
    202d:	0f 1f 00             	nopl   (%rax)
    2030:	f3 0f 1e fa          	endbr64 
    2034:	68 00 00 00 00       	pushq  $0x0
    2039:	f2 e9 e1 ff ff ff    	bnd jmpq 2020 <.plt>
    203f:	90                   	nop
    2040:	f3 0f 1e fa          	endbr64 
    2044:	68 01 00 00 00       	pushq  $0x1
    2049:	f2 e9 d1 ff ff ff    	bnd jmpq 2020 <.plt>
    204f:	90                   	nop
    2050:	f3 0f 1e fa          	endbr64 
    2054:	68 02 00 00 00       	pushq  $0x2
    2059:	f2 e9 c1 ff ff ff    	bnd jmpq 2020 <.plt>
    205f:	90                   	nop
    2060:	f3 0f 1e fa          	endbr64 
    2064:	68 03 00 00 00       	pushq  $0x3
    2069:	f2 e9 b1 ff ff ff    	bnd jmpq 2020 <.plt>
    206f:	90                   	nop
    2070:	f3 0f 1e fa          	endbr64 
    2074:	68 04 00 00 00       	pushq  $0x4
    2079:	f2 e9 a1 ff ff ff    	bnd jmpq 2020 <.plt>
    207f:	90                   	nop
    2080:	f3 0f 1e fa          	endbr64 
    2084:	68 05 00 00 00       	pushq  $0x5
    2089:	f2 e9 91 ff ff ff    	bnd jmpq 2020 <.plt>
    208f:	90                   	nop
    2090:	f3 0f 1e fa          	endbr64 
    2094:	68 06 00 00 00       	pushq  $0x6
    2099:	f2 e9 81 ff ff ff    	bnd jmpq 2020 <.plt>
    209f:	90                   	nop
    20a0:	f3 0f 1e fa          	endbr64 
    20a4:	68 07 00 00 00       	pushq  $0x7
    20a9:	f2 e9 71 ff ff ff    	bnd jmpq 2020 <.plt>
    20af:	90                   	nop
    20b0:	f3 0f 1e fa          	endbr64 
    20b4:	68 08 00 00 00       	pushq  $0x8
    20b9:	f2 e9 61 ff ff ff    	bnd jmpq 2020 <.plt>
    20bf:	90                   	nop
    20c0:	f3 0f 1e fa          	endbr64 
    20c4:	68 09 00 00 00       	pushq  $0x9
    20c9:	f2 e9 51 ff ff ff    	bnd jmpq 2020 <.plt>
    20cf:	90                   	nop
    20d0:	f3 0f 1e fa          	endbr64 
    20d4:	68 0a 00 00 00       	pushq  $0xa
    20d9:	f2 e9 41 ff ff ff    	bnd jmpq 2020 <.plt>
    20df:	90                   	nop
    20e0:	f3 0f 1e fa          	endbr64 
    20e4:	68 0b 00 00 00       	pushq  $0xb
    20e9:	f2 e9 31 ff ff ff    	bnd jmpq 2020 <.plt>
    20ef:	90                   	nop
    20f0:	f3 0f 1e fa          	endbr64 
    20f4:	68 0c 00 00 00       	pushq  $0xc
    20f9:	f2 e9 21 ff ff ff    	bnd jmpq 2020 <.plt>
    20ff:	90                   	nop
    2100:	f3 0f 1e fa          	endbr64 
    2104:	68 0d 00 00 00       	pushq  $0xd
    2109:	f2 e9 11 ff ff ff    	bnd jmpq 2020 <.plt>
    210f:	90                   	nop
    2110:	f3 0f 1e fa          	endbr64 
    2114:	68 0e 00 00 00       	pushq  $0xe
    2119:	f2 e9 01 ff ff ff    	bnd jmpq 2020 <.plt>
    211f:	90                   	nop
    2120:	f3 0f 1e fa          	endbr64 
    2124:	68 0f 00 00 00       	pushq  $0xf
    2129:	f2 e9 f1 fe ff ff    	bnd jmpq 2020 <.plt>
    212f:	90                   	nop
    2130:	f3 0f 1e fa          	endbr64 
    2134:	68 10 00 00 00       	pushq  $0x10
    2139:	f2 e9 e1 fe ff ff    	bnd jmpq 2020 <.plt>
    213f:	90                   	nop
    2140:	f3 0f 1e fa          	endbr64 
    2144:	68 11 00 00 00       	pushq  $0x11
    2149:	f2 e9 d1 fe ff ff    	bnd jmpq 2020 <.plt>
    214f:	90                   	nop
    2150:	f3 0f 1e fa          	endbr64 
    2154:	68 12 00 00 00       	pushq  $0x12
    2159:	f2 e9 c1 fe ff ff    	bnd jmpq 2020 <.plt>
    215f:	90                   	nop
    2160:	f3 0f 1e fa          	endbr64 
    2164:	68 13 00 00 00       	pushq  $0x13
    2169:	f2 e9 b1 fe ff ff    	bnd jmpq 2020 <.plt>
    216f:	90                   	nop
    2170:	f3 0f 1e fa          	endbr64 
    2174:	68 14 00 00 00       	pushq  $0x14
    2179:	f2 e9 a1 fe ff ff    	bnd jmpq 2020 <.plt>
    217f:	90                   	nop
    2180:	f3 0f 1e fa          	endbr64 
    2184:	68 15 00 00 00       	pushq  $0x15
    2189:	f2 e9 91 fe ff ff    	bnd jmpq 2020 <.plt>
    218f:	90                   	nop
    2190:	f3 0f 1e fa          	endbr64 
    2194:	68 16 00 00 00       	pushq  $0x16
    2199:	f2 e9 81 fe ff ff    	bnd jmpq 2020 <.plt>
    219f:	90                   	nop
    21a0:	f3 0f 1e fa          	endbr64 
    21a4:	68 17 00 00 00       	pushq  $0x17
    21a9:	f2 e9 71 fe ff ff    	bnd jmpq 2020 <.plt>
    21af:	90                   	nop
    21b0:	f3 0f 1e fa          	endbr64 
    21b4:	68 18 00 00 00       	pushq  $0x18
    21b9:	f2 e9 61 fe ff ff    	bnd jmpq 2020 <.plt>
    21bf:	90                   	nop
    21c0:	f3 0f 1e fa          	endbr64 
    21c4:	68 19 00 00 00       	pushq  $0x19
    21c9:	f2 e9 51 fe ff ff    	bnd jmpq 2020 <.plt>
    21cf:	90                   	nop
    21d0:	f3 0f 1e fa          	endbr64 
    21d4:	68 1a 00 00 00       	pushq  $0x1a
    21d9:	f2 e9 41 fe ff ff    	bnd jmpq 2020 <.plt>
    21df:	90                   	nop
    21e0:	f3 0f 1e fa          	endbr64 
    21e4:	68 1b 00 00 00       	pushq  $0x1b
    21e9:	f2 e9 31 fe ff ff    	bnd jmpq 2020 <.plt>
    21ef:	90                   	nop
    21f0:	f3 0f 1e fa          	endbr64 
    21f4:	68 1c 00 00 00       	pushq  $0x1c
    21f9:	f2 e9 21 fe ff ff    	bnd jmpq 2020 <.plt>
    21ff:	90                   	nop
    2200:	f3 0f 1e fa          	endbr64 
    2204:	68 1d 00 00 00       	pushq  $0x1d
    2209:	f2 e9 11 fe ff ff    	bnd jmpq 2020 <.plt>
    220f:	90                   	nop
    2210:	f3 0f 1e fa          	endbr64 
    2214:	68 1e 00 00 00       	pushq  $0x1e
    2219:	f2 e9 01 fe ff ff    	bnd jmpq 2020 <.plt>
    221f:	90                   	nop
    2220:	f3 0f 1e fa          	endbr64 
    2224:	68 1f 00 00 00       	pushq  $0x1f
    2229:	f2 e9 f1 fd ff ff    	bnd jmpq 2020 <.plt>
    222f:	90                   	nop
    2230:	f3 0f 1e fa          	endbr64 
    2234:	68 20 00 00 00       	pushq  $0x20
    2239:	f2 e9 e1 fd ff ff    	bnd jmpq 2020 <.plt>
    223f:	90                   	nop
    2240:	f3 0f 1e fa          	endbr64 
    2244:	68 21 00 00 00       	pushq  $0x21
    2249:	f2 e9 d1 fd ff ff    	bnd jmpq 2020 <.plt>
    224f:	90                   	nop
    2250:	f3 0f 1e fa          	endbr64 
    2254:	68 22 00 00 00       	pushq  $0x22
    2259:	f2 e9 c1 fd ff ff    	bnd jmpq 2020 <.plt>
    225f:	90                   	nop
    2260:	f3 0f 1e fa          	endbr64 
    2264:	68 23 00 00 00       	pushq  $0x23
    2269:	f2 e9 b1 fd ff ff    	bnd jmpq 2020 <.plt>
    226f:	90                   	nop
    2270:	f3 0f 1e fa          	endbr64 
    2274:	68 24 00 00 00       	pushq  $0x24
    2279:	f2 e9 a1 fd ff ff    	bnd jmpq 2020 <.plt>
    227f:	90                   	nop

Disassembly of section .plt.got:

0000000000002280 <__cxa_finalize@plt>:
    2280:	f3 0f 1e fa          	endbr64 
    2284:	f2 ff 25 65 7d 00 00 	bnd jmpq *0x7d65(%rip)        # 9ff0 <__cxa_finalize@GLIBC_2.2.5>
    228b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000002290 <__snprintf_chk@plt>:
    2290:	f3 0f 1e fa          	endbr64 
    2294:	f2 ff 25 d5 7b 00 00 	bnd jmpq *0x7bd5(%rip)        # 9e70 <__snprintf_chk@GLIBC_2.3.4>
    229b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022a0 <free@plt>:
    22a0:	f3 0f 1e fa          	endbr64 
    22a4:	f2 ff 25 cd 7b 00 00 	bnd jmpq *0x7bcd(%rip)        # 9e78 <free@GLIBC_2.2.5>
    22ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022b0 <pthread_create@plt>:
    22b0:	f3 0f 1e fa          	endbr64 
    22b4:	f2 ff 25 c5 7b 00 00 	bnd jmpq *0x7bc5(%rip)        # 9e80 <pthread_create@GLIBC_2.2.5>
    22bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022c0 <strcasecmp@plt>:
    22c0:	f3 0f 1e fa          	endbr64 
    22c4:	f2 ff 25 bd 7b 00 00 	bnd jmpq *0x7bbd(%rip)        # 9e88 <strcasecmp@GLIBC_2.2.5>
    22cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022d0 <pthread_detach@plt>:
    22d0:	f3 0f 1e fa          	endbr64 
    22d4:	f2 ff 25 b5 7b 00 00 	bnd jmpq *0x7bb5(%rip)        # 9e90 <pthread_detach@GLIBC_2.2.5>
    22db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022e0 <__vfprintf_chk@plt>:
    22e0:	f3 0f 1e fa          	endbr64 
    22e4:	f2 ff 25 ad 7b 00 00 	bnd jmpq *0x7bad(%rip)        # 9e98 <__vfprintf_chk@GLIBC_2.3.4>
    22eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000022f0 <pthread_cond_broadcast@plt>:
    22f0:	f3 0f 1e fa          	endbr64 
    22f4:	f2 ff 25 a5 7b 00 00 	bnd jmpq *0x7ba5(%rip)        # 9ea0 <pthread_cond_broadcast@GLIBC_2.3.2>
    22fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002300 <pthread_cancel@plt>:
    2300:	f3 0f 1e fa          	endbr64 
    2304:	f2 ff 25 9d 7b 00 00 	bnd jmpq *0x7b9d(%rip)        # 9ea8 <pthread_cancel@GLIBC_2.2.5>
    230b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002310 <isatty@plt>:
    2310:	f3 0f 1e fa          	endbr64 
    2314:	f2 ff 25 95 7b 00 00 	bnd jmpq *0x7b95(%rip)        # 9eb0 <isatty@GLIBC_2.2.5>
    231b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002320 <sigaction@plt>:
    2320:	f3 0f 1e fa          	endbr64 
    2324:	f2 ff 25 8d 7b 00 00 	bnd jmpq *0x7b8d(%rip)        # 9eb8 <sigaction@GLIBC_2.2.5>
    232b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002330 <__pthread_register_cancel@plt>:
    2330:	f3 0f 1e fa          	endbr64 
    2334:	f2 ff 25 85 7b 00 00 	bnd jmpq *0x7b85(%rip)        # 9ec0 <__pthread_register_cancel@GLIBC_2.3.3>
    233b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002340 <strtod@plt>:
    2340:	f3 0f 1e fa          	endbr64 
    2344:	f2 ff 25 7d 7b 00 00 	bnd jmpq *0x7b7d(%rip)        # 9ec8 <strtod@GLIBC_2.2.5>
    234b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002350 <clock_gettime@plt>:
    2350:	f3 0f 1e fa          	endbr64 
    2354:	f2 ff 25 75 7b 00 00 	bnd jmpq *0x7b75(%rip)        # 9ed0 <clock_gettime@GLIBC_2.17>
    235b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002360 <pthread_cond_wait@plt>:
    2360:	f3 0f 1e fa          	endbr64 
    2364:	f2 ff 25 6d 7b 00 00 	bnd jmpq *0x7b6d(%rip)        # 9ed8 <pthread_cond_wait@GLIBC_2.3.2>
    236b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002370 <__stack_chk_fail@plt>:
    2370:	f3 0f 1e fa          	endbr64 
    2374:	f2 ff 25 65 7b 00 00 	bnd jmpq *0x7b65(%rip)        # 9ee0 <__stack_chk_fail@GLIBC_2.4>
    237b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002380 <snprintf@plt>:
    2380:	f3 0f 1e fa          	endbr64 
    2384:	f2 ff 25 5d 7b 00 00 	bnd jmpq *0x7b5d(%rip)        # 9ee8 <snprintf@GLIBC_2.2.5>
    238b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002390 <nanosleep@plt>:
    2390:	f3 0f 1e fa          	endbr64 
    2394:	f2 ff 25 55 7b 00 00 	bnd jmpq *0x7b55(%rip)        # 9ef0 <nanosleep@GLIBC_2.2.5>
    239b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023a0 <strnlen@plt>:
    23a0:	f3 0f 1e fa          	endbr64 
    23a4:	f2 ff 25 4d 7b 00 00 	bnd jmpq *0x7b4d(%rip)        # 9ef8 <strnlen@GLIBC_2.2.5>
    23ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023b0 <strtoull@plt>:
    23b0:	f3 0f 1e fa          	endbr64 
    23b4:	f2 ff 25 45 7b 00 00 	bnd jmpq *0x7b45(%rip)        # 9f00 <strtoull@GLIBC_2.2.5>
    23bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023c0 <calloc@plt>:
    23c0:	f3 0f 1e fa          	endbr64 
    23c4:	f2 ff 25 3d 7b 00 00 	bnd jmpq *0x7b3d(%rip)        # 9f08 <calloc@GLIBC_2.2.5>
    23cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023d0 <strcmp@plt>:
    23d0:	f3 0f 1e fa          	endbr64 
    23d4:	f2 ff 25 35 7b 00 00 	bnd jmpq *0x7b35(%rip)        # 9f10 <strcmp@GLIBC_2.2.5>
    23db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023e0 <strtoll@plt>:
    23e0:	f3 0f 1e fa          	endbr64 
    23e4:	f2 ff 25 2d 7b 00 00 	bnd jmpq *0x7b2d(%rip)        # 9f18 <strtoll@GLIBC_2.2.5>
    23eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023f0 <sigemptyset@plt>:
    23f0:	f3 0f 1e fa          	endbr64 
    23f4:	f2 ff 25 25 7b 00 00 	bnd jmpq *0x7b25(%rip)        # 9f20 <sigemptyset@GLIBC_2.2.5>
    23fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002400 <strtol@plt>:
    2400:	f3 0f 1e fa          	endbr64 
    2404:	f2 ff 25 1d 7b 00 00 	bnd jmpq *0x7b1d(%rip)        # 9f28 <strtol@GLIBC_2.2.5>
    240b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002410 <pthread_mutex_unlock@plt>:
    2410:	f3 0f 1e fa          	endbr64 
    2414:	f2 ff 25 15 7b 00 00 	bnd jmpq *0x7b15(%rip)        # 9f30 <pthread_mutex_unlock@GLIBC_2.2.5>
    241b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002420 <pthread_exit@plt>:
    2420:	f3 0f 1e fa          	endbr64 
    2424:	f2 ff 25 0d 7b 00 00 	bnd jmpq *0x7b0d(%rip)        # 9f38 <pthread_exit@GLIBC_2.2.5>
    242b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002430 <realloc@plt>:
    2430:	f3 0f 1e fa          	endbr64 
    2434:	f2 ff 25 05 7b 00 00 	bnd jmpq *0x7b05(%rip)        # 9f40 <realloc@GLIBC_2.2.5>
    243b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002440 <setvbuf@plt>:
    2440:	f3 0f 1e fa          	endbr64 
    2444:	f2 ff 25 fd 7a 00 00 	bnd jmpq *0x7afd(%rip)        # 9f48 <setvbuf@GLIBC_2.2.5>
    244b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002450 <pthread_self@plt>:
    2450:	f3 0f 1e fa          	endbr64 
    2454:	f2 ff 25 f5 7a 00 00 	bnd jmpq *0x7af5(%rip)        # 9f50 <pthread_self@GLIBC_2.2.5>
    245b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002460 <strtoul@plt>:
    2460:	f3 0f 1e fa          	endbr64 
    2464:	f2 ff 25 ed 7a 00 00 	bnd jmpq *0x7aed(%rip)        # 9f58 <strtoul@GLIBC_2.2.5>
    246b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002470 <__pthread_unwind_next@plt>:
    2470:	f3 0f 1e fa          	endbr64 
    2474:	f2 ff 25 e5 7a 00 00 	bnd jmpq *0x7ae5(%rip)        # 9f60 <__pthread_unwind_next@GLIBC_2.3.3>
    247b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002480 <exit@plt>:
    2480:	f3 0f 1e fa          	endbr64 
    2484:	f2 ff 25 dd 7a 00 00 	bnd jmpq *0x7add(%rip)        # 9f68 <exit@GLIBC_2.2.5>
    248b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002490 <__fprintf_chk@plt>:
    2490:	f3 0f 1e fa          	endbr64 
    2494:	f2 ff 25 d5 7a 00 00 	bnd jmpq *0x7ad5(%rip)        # 9f70 <__fprintf_chk@GLIBC_2.3.4>
    249b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024a0 <__sigsetjmp@plt>:
    24a0:	f3 0f 1e fa          	endbr64 
    24a4:	f2 ff 25 cd 7a 00 00 	bnd jmpq *0x7acd(%rip)        # 9f78 <__sigsetjmp@GLIBC_2.2.5>
    24ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024b0 <sleep@plt>:
    24b0:	f3 0f 1e fa          	endbr64 
    24b4:	f2 ff 25 c5 7a 00 00 	bnd jmpq *0x7ac5(%rip)        # 9f80 <sleep@GLIBC_2.2.5>
    24bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024c0 <pthread_mutex_lock@plt>:
    24c0:	f3 0f 1e fa          	endbr64 
    24c4:	f2 ff 25 bd 7a 00 00 	bnd jmpq *0x7abd(%rip)        # 9f88 <pthread_mutex_lock@GLIBC_2.2.5>
    24cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024d0 <__ctype_b_loc@plt>:
    24d0:	f3 0f 1e fa          	endbr64 
    24d4:	f2 ff 25 b5 7a 00 00 	bnd jmpq *0x7ab5(%rip)        # 9f90 <__ctype_b_loc@GLIBC_2.3>
    24db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .text:

00000000000024e0 <_start>:
    24e0:	f3 0f 1e fa          	endbr64 
    24e4:	31 ed                	xor    %ebp,%ebp
    24e6:	49 89 d1             	mov    %rdx,%r9
    24e9:	5e                   	pop    %rsi
    24ea:	48 89 e2             	mov    %rsp,%rdx
    24ed:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    24f1:	50                   	push   %rax
    24f2:	54                   	push   %rsp
    24f3:	4c 8d 05 46 01 00 00 	lea    0x146(%rip),%r8        # 2640 <__libc_csu_fini>
    24fa:	48 8d 0d cf 00 00 00 	lea    0xcf(%rip),%rcx        # 25d0 <__libc_csu_init>
    2501:	48 8d 3d db 23 00 00 	lea    0x23db(%rip),%rdi        # 48e3 <main>
    2508:	ff 15 ba 7a 00 00    	callq  *0x7aba(%rip)        # 9fc8 <__libc_start_main@GLIBC_2.2.5>
    250e:	f4                   	hlt    
    250f:	90                   	nop

0000000000002510 <deregister_tm_clones>:
    2510:	48 8d 3d 49 7e 00 00 	lea    0x7e49(%rip),%rdi        # a360 <__TMC_END__>
    2517:	48 8d 05 42 7e 00 00 	lea    0x7e42(%rip),%rax        # a360 <__TMC_END__>
    251e:	48 39 f8             	cmp    %rdi,%rax
    2521:	74 15                	je     2538 <deregister_tm_clones+0x28>
    2523:	48 8b 05 76 7a 00 00 	mov    0x7a76(%rip),%rax        # 9fa0 <_ITM_deregisterTMCloneTable>
    252a:	48 85 c0             	test   %rax,%rax
    252d:	74 09                	je     2538 <deregister_tm_clones+0x28>
    252f:	ff e0                	jmpq   *%rax
    2531:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2538:	c3                   	retq   
    2539:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002540 <register_tm_clones>:
    2540:	48 8d 3d 19 7e 00 00 	lea    0x7e19(%rip),%rdi        # a360 <__TMC_END__>
    2547:	48 8d 35 12 7e 00 00 	lea    0x7e12(%rip),%rsi        # a360 <__TMC_END__>
    254e:	48 29 fe             	sub    %rdi,%rsi
    2551:	48 89 f0             	mov    %rsi,%rax
    2554:	48 c1 ee 3f          	shr    $0x3f,%rsi
    2558:	48 c1 f8 03          	sar    $0x3,%rax
    255c:	48 01 c6             	add    %rax,%rsi
    255f:	48 d1 fe             	sar    %rsi
    2562:	74 14                	je     2578 <register_tm_clones+0x38>
    2564:	48 8b 05 7d 7a 00 00 	mov    0x7a7d(%rip),%rax        # 9fe8 <_ITM_registerTMCloneTable>
    256b:	48 85 c0             	test   %rax,%rax
    256e:	74 08                	je     2578 <register_tm_clones+0x38>
    2570:	ff e0                	jmpq   *%rax
    2572:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2578:	c3                   	retq   
    2579:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002580 <__do_global_dtors_aux>:
    2580:	f3 0f 1e fa          	endbr64 
    2584:	80 3d 21 92 00 00 00 	cmpb   $0x0,0x9221(%rip)        # b7ac <completed.8060>
    258b:	75 2b                	jne    25b8 <__do_global_dtors_aux+0x38>
    258d:	55                   	push   %rbp
    258e:	48 83 3d 5a 7a 00 00 	cmpq   $0x0,0x7a5a(%rip)        # 9ff0 <__cxa_finalize@GLIBC_2.2.5>
    2595:	00 
    2596:	48 89 e5             	mov    %rsp,%rbp
    2599:	74 0c                	je     25a7 <__do_global_dtors_aux+0x27>
    259b:	48 8b 3d 7e 7d 00 00 	mov    0x7d7e(%rip),%rdi        # a320 <__dso_handle>
    25a2:	e8 d9 fc ff ff       	callq  2280 <__cxa_finalize@plt>
    25a7:	e8 64 ff ff ff       	callq  2510 <deregister_tm_clones>
    25ac:	c6 05 f9 91 00 00 01 	movb   $0x1,0x91f9(%rip)        # b7ac <completed.8060>
    25b3:	5d                   	pop    %rbp
    25b4:	c3                   	retq   
    25b5:	0f 1f 00             	nopl   (%rax)
    25b8:	c3                   	retq   
    25b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000025c0 <frame_dummy>:
    25c0:	f3 0f 1e fa          	endbr64 
    25c4:	e9 77 ff ff ff       	jmpq   2540 <register_tm_clones>
    25c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000025d0 <__libc_csu_init>:
    25d0:	f3 0f 1e fa          	endbr64 
    25d4:	41 57                	push   %r15
    25d6:	4c 8d 3d f3 75 00 00 	lea    0x75f3(%rip),%r15        # 9bd0 <__frame_dummy_init_array_entry>
    25dd:	41 56                	push   %r14
    25df:	49 89 d6             	mov    %rdx,%r14
    25e2:	41 55                	push   %r13
    25e4:	49 89 f5             	mov    %rsi,%r13
    25e7:	41 54                	push   %r12
    25e9:	41 89 fc             	mov    %edi,%r12d
    25ec:	55                   	push   %rbp
    25ed:	48 8d 2d e4 75 00 00 	lea    0x75e4(%rip),%rbp        # 9bd8 <__do_global_dtors_aux_fini_array_entry>
    25f4:	53                   	push   %rbx
    25f5:	4c 29 fd             	sub    %r15,%rbp
    25f8:	48 83 ec 08          	sub    $0x8,%rsp
    25fc:	e8 ff f9 ff ff       	callq  2000 <_init>
    2601:	48 c1 fd 03          	sar    $0x3,%rbp
    2605:	74 1f                	je     2626 <__libc_csu_init+0x56>
    2607:	31 db                	xor    %ebx,%ebx
    2609:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2610:	4c 89 f2             	mov    %r14,%rdx
    2613:	4c 89 ee             	mov    %r13,%rsi
    2616:	44 89 e7             	mov    %r12d,%edi
    2619:	41 ff 14 df          	callq  *(%r15,%rbx,8)
    261d:	48 83 c3 01          	add    $0x1,%rbx
    2621:	48 39 dd             	cmp    %rbx,%rbp
    2624:	75 ea                	jne    2610 <__libc_csu_init+0x40>
    2626:	48 83 c4 08          	add    $0x8,%rsp
    262a:	5b                   	pop    %rbx
    262b:	5d                   	pop    %rbp
    262c:	41 5c                	pop    %r12
    262e:	41 5d                	pop    %r13
    2630:	41 5e                	pop    %r14
    2632:	41 5f                	pop    %r15
    2634:	c3                   	retq   
    2635:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    263c:	00 00 00 00 

0000000000002640 <__libc_csu_fini>:
    2640:	f3 0f 1e fa          	endbr64 
    2644:	c3                   	retq   

0000000000002645 <zephyr_app_main>:

#include <zephyr.h>
#include <sys/printk.h>

void main(void)
{
    2645:	f3 0f 1e fa          	endbr64 
	printk("Lezuo Stinkt: Auf diesem Board: %s\n", CONFIG_BOARD);
    2649:	48 8d 35 04 4b 00 00 	lea    0x4b04(%rip),%rsi        # 7154 <__func__.5051+0x154>
    2650:	48 8d 3d 0d 4b 00 00 	lea    0x4b0d(%rip),%rdi        # 7164 <__func__.5051+0x164>
    2657:	31 c0                	xor    %eax,%eax
    2659:	e9 76 00 00 00       	jmpq   26d4 <printk>

000000000000265e <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    265e:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    2662:	31 c0                	xor    %eax,%eax
    2664:	c3                   	retq   

0000000000002665 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    2665:	f3 0f 1e fa          	endbr64 
	struct out_context *ctx = ctx_p;

	ctx->count++;
	return _char_out(c);
    2669:	48 8d 05 b8 7c 00 00 	lea    0x7cb8(%rip),%rax        # a328 <_char_out>
	ctx->count++;
    2670:	ff 06                	incl   (%rsi)
	return _char_out(c);
    2672:	ff 20                	jmpq   *(%rax)

0000000000002674 <__printk_hook_install>:
{
    2674:	f3 0f 1e fa          	endbr64 
	_char_out = fn;
    2678:	48 8d 05 a9 7c 00 00 	lea    0x7ca9(%rip),%rax        # a328 <_char_out>
    267f:	48 89 38             	mov    %rdi,(%rax)
}
    2682:	c3                   	retq   

0000000000002683 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    2683:	f3 0f 1e fa          	endbr64 
    2687:	48 83 ec 18          	sub    $0x18,%rsp
    268b:	48 89 fa             	mov    %rdi,%rdx
    268e:	48 89 f1             	mov    %rsi,%rcx
    2691:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2698:	00 00 
    269a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    269f:	31 c0                	xor    %eax,%eax
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    26a1:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    26a6:	48 8d 3d b8 ff ff ff 	lea    -0x48(%rip),%rdi        # 2665 <char_out>
	struct out_context ctx = { 0 };
    26ad:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    26b4:	00 
	cbvprintf(char_out, &ctx, fmt, ap);
    26b5:	e8 84 03 00 00       	callq  2a3e <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    26ba:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    26bf:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    26c6:	00 00 
    26c8:	74 05                	je     26cf <vprintk+0x4c>
    26ca:	e8 a1 fc ff ff       	callq  2370 <__stack_chk_fail@plt>
    26cf:	48 83 c4 18          	add    $0x18,%rsp
    26d3:	c3                   	retq   

00000000000026d4 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
    26d4:	f3 0f 1e fa          	endbr64 
    26d8:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    26df:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    26e4:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    26e9:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    26ee:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    26f3:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    26f8:	84 c0                	test   %al,%al
    26fa:	74 37                	je     2733 <printk+0x5f>
    26fc:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    2701:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    2706:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    270b:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    2712:	00 
    2713:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    271a:	00 
    271b:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    2722:	00 
    2723:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    272a:	00 
    272b:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    2732:	00 
    2733:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    273a:	00 00 
    273c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    2741:	31 c0                	xor    %eax,%eax
	va_list ap;

	va_start(ap, fmt);
    2743:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    274a:	00 

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    274b:	48 89 e6             	mov    %rsp,%rsi
	va_start(ap, fmt);
    274e:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    2755:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    275a:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    275f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    2764:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    276b:	00 
		vprintk(fmt, ap);
    276c:	e8 12 ff ff ff       	callq  2683 <vprintk>
	}
	va_end(ap);
}
    2771:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    2776:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    277d:	00 00 
    277f:	74 05                	je     2786 <printk+0xb2>
    2781:	e8 ea fb ff ff       	callq  2370 <__stack_chk_fail@plt>
    2786:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    278d:	c3                   	retq   

000000000000278e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    278e:	f3 0f 1e fa          	endbr64 
    2792:	50                   	push   %rax
    2793:	58                   	pop    %rax
    2794:	49 89 f8             	mov    %rdi,%r8
    2797:	50                   	push   %rax
    2798:	48 89 f7             	mov    %rsi,%rdi
    279b:	48 89 d6             	mov    %rdx,%rsi
    279e:	48 89 ca             	mov    %rcx,%rdx
	entry(p1, p2, p3);
    27a1:	41 ff d0             	callq  *%r8
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_K_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_current_get();
    27a4:	31 c0                	xor    %eax,%eax
    27a6:	e8 01 36 00 00       	callq  5dac <z_impl_k_current_get>
    27ab:	48 89 c7             	mov    %rax,%rdi
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    27ae:	e8 fa 11 00 00       	callq  39ad <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    27b3:	ba 26 00 00 00       	mov    $0x26,%edx
    27b8:	48 8d 35 c9 49 00 00 	lea    0x49c9(%rip),%rsi        # 7188 <__func__.5051+0x188>
    27bf:	31 c0                	xor    %eax,%eax
    27c1:	48 8d 3d e9 49 00 00 	lea    0x49e9(%rip),%rdi        # 71b1 <__func__.5051+0x1b1>
    27c8:	e8 e0 21 00 00       	callq  49ad <posix_print_error_and_exit>

00000000000027cd <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
    27cd:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    27d1:	48 d1 e8             	shr    %rax
}
    27d4:	c3                   	retq   

00000000000027d5 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    27d5:	48 8d 04 f7          	lea    (%rdi,%rsi,8),%rax
{
    27d9:	41 89 d0             	mov    %edx,%r8d
    27dc:	8b 48 04             	mov    0x4(%rax),%ecx

	if (big_heap(h)) {
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    27df:	89 ca                	mov    %ecx,%edx
    27e1:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
    27e4:	45 84 c0             	test   %r8b,%r8b
    27e7:	74 05                	je     27ee <set_chunk_used+0x19>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    27e9:	83 c9 01             	or     $0x1,%ecx
    27ec:	89 ca                	mov    %ecx,%edx
    27ee:	89 50 04             	mov    %edx,0x4(%rax)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    27f1:	c3                   	retq   

00000000000027f2 <free_list_add>:
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    27f2:	e8 d6 ff ff ff       	callq  27cd <chunk_size>
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
	if (!solo_free_header(h, c)) {
    27f7:	48 83 f8 01          	cmp    $0x1,%rax
    27fb:	74 59                	je     2856 <free_list_add+0x64>
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    27fd:	48 ff c8             	dec    %rax
	return 31 - __builtin_clz(usable_sz);
    2800:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    2805:	0f bd c0             	bsr    %eax,%eax
    2808:	83 f0 1f             	xor    $0x1f,%eax
    280b:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
    280d:	48 63 c1             	movslq %ecx,%rax
    2810:	4c 8d 14 c7          	lea    (%rdi,%rax,8),%r10
    2814:	48 8d 04 f5 08 00 00 	lea    0x8(,%rsi,8),%rax
    281b:	00 
    281c:	49 8b 52 10          	mov    0x10(%r10),%rdx
    2820:	4c 8d 0c 07          	lea    (%rdi,%rax,1),%r9
    2824:	4c 8d 44 07 04       	lea    0x4(%rdi,%rax,1),%r8
    2829:	48 85 d2             	test   %rdx,%rdx
    282c:	75 15                	jne    2843 <free_list_add+0x51>
		h->avail_buckets |= (1 << bidx);
    282e:	b8 01 00 00 00       	mov    $0x1,%eax
    2833:	d3 e0                	shl    %cl,%eax
    2835:	09 47 0c             	or     %eax,0xc(%rdi)
		b->next = c;
    2838:	49 89 72 10          	mov    %rsi,0x10(%r10)
		((uint32_t *)cmem)[f] = val;
    283c:	41 89 31             	mov    %esi,(%r9)
    283f:	41 89 30             	mov    %esi,(%r8)
}
    2842:	c3                   	retq   
		return ((uint32_t *)cmem)[f];
    2843:	48 8d 4c d7 08       	lea    0x8(%rdi,%rdx,8),%rcx
    2848:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
    284a:	41 89 01             	mov    %eax,(%r9)
    284d:	41 89 10             	mov    %edx,(%r8)
    2850:	89 74 c7 0c          	mov    %esi,0xc(%rdi,%rax,8)
    2854:	89 31                	mov    %esi,(%rcx)
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    2856:	c3                   	retq   

0000000000002857 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    2857:	f3 0f 1e fa          	endbr64 
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    285b:	4c 8d 5c 16 f8       	lea    -0x8(%rsi,%rdx,1),%r11
{
    2860:	49 89 f8             	mov    %rdi,%r8
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    2863:	48 8d 7e 07          	lea    0x7(%rsi),%rdi
	heap->heap = h;
	h->chunk0_hdr_area = 0;
	h->len = buf_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
    2867:	ba 20 00 00 00       	mov    $0x20,%edx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    286c:	49 83 e3 f8          	and    $0xfffffffffffffff8,%r11
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    2870:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    2874:	4d 89 da             	mov    %r11,%r10
	heap->heap = h;
    2877:	49 89 38             	mov    %rdi,(%r8)
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    287a:	49 29 fa             	sub    %rdi,%r10
	h->chunk0_hdr_area = 0;
    287d:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
    2884:	49 c1 ea 03          	shr    $0x3,%r10
	h->avail_buckets = 0;
    2888:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
	size_t usable_sz = sz - min_chunk_size(h) + 1;
    288f:	49 8d 42 ff          	lea    -0x1(%r10),%rax
	h->len = buf_sz;
    2893:	44 89 57 08          	mov    %r10d,0x8(%rdi)
	return 31 - __builtin_clz(usable_sz);
    2897:	0f bd c0             	bsr    %eax,%eax
    289a:	83 f0 1f             	xor    $0x1f,%eax
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
    289d:	29 c2                	sub    %eax,%edx
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
    289f:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    28a2:	4c 8d 0c c5 17 00 00 	lea    0x17(,%rax,8),%r9
    28a9:	00 
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    28aa:	31 c0                	xor    %eax,%eax
    28ac:	49 c1 e9 03          	shr    $0x3,%r9
    28b0:	39 c2                	cmp    %eax,%edx
    28b2:	7e 0e                	jle    28c2 <sys_heap_init+0x6b>
		h->buckets[i].next = 0;
    28b4:	48 c7 44 c7 10 00 00 	movq   $0x0,0x10(%rdi,%rax,8)
    28bb:	00 00 
	for (int i = 0; i < nb_buckets; i++) {
    28bd:	48 ff c0             	inc    %rax
    28c0:	eb ee                	jmp    28b0 <sys_heap_init+0x59>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    28c2:	4b 8d 04 09          	lea    (%r9,%r9,1),%rax
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_chunk_used(h, 0, true);
    28c6:	ba 01 00 00 00       	mov    $0x1,%edx
    28cb:	31 f6                	xor    %esi,%esi
		((uint32_t *)cmem)[f] = val;
    28cd:	89 47 04             	mov    %eax,0x4(%rdi)
    28d0:	e8 00 ff ff ff       	callq  27d5 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
    28d5:	4c 89 d0             	mov    %r10,%rax
    28d8:	46 89 0c cf          	mov    %r9d,(%rdi,%r9,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
    28dc:	4c 89 d6             	mov    %r10,%rsi
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
    28df:	4c 29 c8             	sub    %r9,%rax
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    28e2:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
		((uint32_t *)cmem)[f] = val;
    28e6:	42 89 54 cf 04       	mov    %edx,0x4(%rdi,%r9,8)
	set_chunk_used(h, buf_sz, true);
    28eb:	ba 01 00 00 00       	mov    $0x1,%edx
    28f0:	41 c7 43 04 00 00 00 	movl   $0x0,0x4(%r11)
    28f7:	00 
    28f8:	41 89 03             	mov    %eax,(%r11)
    28fb:	e8 d5 fe ff ff       	callq  27d5 <set_chunk_used>

	free_list_add(h, chunk0_size);
    2900:	4c 89 ce             	mov    %r9,%rsi
    2903:	e9 ea fe ff ff       	jmpq   27f2 <free_list_add>

0000000000002908 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    2908:	41 56                	push   %r14
    290a:	49 89 f6             	mov    %rsi,%r14
    290d:	41 55                	push   %r13
    290f:	49 89 fd             	mov    %rdi,%r13
    2912:	41 54                	push   %r12
    2914:	49 89 cc             	mov    %rcx,%r12
    2917:	55                   	push   %rbp
    2918:	48 89 d5             	mov    %rdx,%rbp
    291b:	53                   	push   %rbx
	size_t count = 0;
    291c:	31 db                	xor    %ebx,%ebx

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    291e:	48 8d 44 1d 00       	lea    0x0(%rbp,%rbx,1),%rax
    2923:	49 39 c4             	cmp    %rax,%r12
    2926:	76 16                	jbe    293e <outs+0x36>
		int rc = out((int)*sp++, ctx);
    2928:	31 c0                	xor    %eax,%eax
    292a:	0f be 7c 1d 00       	movsbl 0x0(%rbp,%rbx,1),%edi
    292f:	4c 89 f6             	mov    %r14,%rsi
    2932:	41 ff d5             	callq  *%r13

		if (rc < 0) {
    2935:	85 c0                	test   %eax,%eax
    2937:	78 17                	js     2950 <outs+0x48>
			return rc;
		}
		++count;
    2939:	48 ff c3             	inc    %rbx
    293c:	eb e0                	jmp    291e <outs+0x16>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    293e:	4d 85 e4             	test   %r12,%r12
    2941:	74 04                	je     2947 <outs+0x3f>
	}

	return (int)count;
    2943:	89 d8                	mov    %ebx,%eax
    2945:	eb 09                	jmp    2950 <outs+0x48>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    2947:	80 7c 1d 00 00       	cmpb   $0x0,0x0(%rbp,%rbx,1)
    294c:	75 da                	jne    2928 <outs+0x20>
    294e:	eb f3                	jmp    2943 <outs+0x3b>
}
    2950:	5b                   	pop    %rbx
    2951:	5d                   	pop    %rbp
    2952:	41 5c                	pop    %r12
    2954:	41 5d                	pop    %r13
    2956:	41 5e                	pop    %r14
    2958:	c3                   	retq   

0000000000002959 <extract_decimal>:
{
    2959:	55                   	push   %rbp
    295a:	53                   	push   %rbx
    295b:	48 89 fb             	mov    %rdi,%rbx
    295e:	51                   	push   %rcx
	const char *sp = *str;
    295f:	48 8b 2f             	mov    (%rdi),%rbp
	while (isdigit((int)(unsigned char)*sp)) {
    2962:	e8 69 fb ff ff       	callq  24d0 <__ctype_b_loc@plt>
    2967:	48 8b 08             	mov    (%rax),%rcx
	size_t val = 0;
    296a:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    296c:	48 0f be 55 00       	movsbq 0x0(%rbp),%rdx
    2971:	0f b6 f2             	movzbl %dl,%esi
    2974:	f6 44 71 01 08       	testb  $0x8,0x1(%rcx,%rsi,2)
    2979:	74 0e                	je     2989 <extract_decimal+0x30>
		val = 10U * val + *sp++ - '0';
    297b:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    297f:	48 ff c5             	inc    %rbp
    2982:	48 8d 44 10 d0       	lea    -0x30(%rax,%rdx,1),%rax
    2987:	eb e3                	jmp    296c <extract_decimal+0x13>
	*str = sp;
    2989:	48 89 2b             	mov    %rbp,(%rbx)
}
    298c:	5a                   	pop    %rdx
    298d:	5b                   	pop    %rbx
    298e:	5d                   	pop    %rbp
    298f:	c3                   	retq   

0000000000002990 <encode_uint>:
{
    2990:	41 55                	push   %r13
    2992:	49 89 fd             	mov    %rdi,%r13
    2995:	41 54                	push   %r12
    2997:	49 89 cc             	mov    %rcx,%r12
    299a:	55                   	push   %rbp
    299b:	48 89 d5             	mov    %rdx,%rbp
    299e:	53                   	push   %rbx
    299f:	48 89 f3             	mov    %rsi,%rbx
    29a2:	41 50                	push   %r8
	bool upcase = isupper((int)conv->specifier);
    29a4:	e8 27 fb ff ff       	callq  24d0 <__ctype_b_loc@plt>
    29a9:	48 0f be 4b 03       	movsbq 0x3(%rbx),%rcx
    29ae:	49 89 c0             	mov    %rax,%r8
    29b1:	49 8b 10             	mov    (%r8),%rdx
    29b4:	48 89 c8             	mov    %rcx,%rax
	switch (specifier) {
    29b7:	41 b8 08 00 00 00    	mov    $0x8,%r8d
    29bd:	66 8b 0c 4a          	mov    (%rdx,%rcx,2),%cx
    29c1:	66 81 e1 00 01       	and    $0x100,%cx
    29c6:	3c 6f                	cmp    $0x6f,%al
    29c8:	74 3b                	je     2a05 <encode_uint+0x75>
    29ca:	7f 04                	jg     29d0 <encode_uint+0x40>
		return 16;
    29cc:	3c 58                	cmp    $0x58,%al
    29ce:	eb 05                	jmp    29d5 <encode_uint+0x45>
	switch (specifier) {
    29d0:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
    29d3:	3c 70                	cmp    $0x70,%al
    29d5:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
    29db:	b8 10 00 00 00       	mov    $0x10,%eax
    29e0:	4c 0f 44 c0          	cmove  %rax,%r8
	char *bp = bps + (bpe - bps);
    29e4:	eb 1f                	jmp    2a05 <encode_uint+0x75>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    29e6:	8d 72 57             	lea    0x57(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    29e9:	66 85 c9             	test   %cx,%cx
    29ec:	74 03                	je     29f1 <encode_uint+0x61>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    29ee:	8d 72 37             	lea    0x37(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    29f1:	49 ff cc             	dec    %r12
    29f4:	41 88 34 24          	mov    %sil,(%r12)
	} while ((value != 0) && (bps < bp));
    29f8:	4d 39 c5             	cmp    %r8,%r13
    29fb:	72 1b                	jb     2a18 <encode_uint+0x88>
    29fd:	49 39 ec             	cmp    %rbp,%r12
    2a00:	76 16                	jbe    2a18 <encode_uint+0x88>
		value /= radix;
    2a02:	49 89 c5             	mov    %rax,%r13
		unsigned int lsv = (unsigned int)(value % radix);
    2a05:	4c 89 e8             	mov    %r13,%rax
    2a08:	31 d2                	xor    %edx,%edx
    2a0a:	49 f7 f0             	div    %r8
		*--bp = (lsv <= 9) ? ('0' + lsv)
    2a0d:	8d 72 30             	lea    0x30(%rdx),%esi
    2a10:	48 83 fa 09          	cmp    $0x9,%rdx
    2a14:	76 db                	jbe    29f1 <encode_uint+0x61>
    2a16:	eb ce                	jmp    29e6 <encode_uint+0x56>
	if (conv->flag_hash) {
    2a18:	f6 03 20             	testb  $0x20,(%rbx)
    2a1b:	74 16                	je     2a33 <encode_uint+0xa3>
		if (radix == 8) {
    2a1d:	49 83 f8 08          	cmp    $0x8,%r8
    2a21:	75 06                	jne    2a29 <encode_uint+0x99>
			conv->altform_0 = true;
    2a23:	80 4b 02 08          	orb    $0x8,0x2(%rbx)
    2a27:	eb 0a                	jmp    2a33 <encode_uint+0xa3>
		} else if (radix == 16) {
    2a29:	49 83 f8 10          	cmp    $0x10,%r8
    2a2d:	75 04                	jne    2a33 <encode_uint+0xa3>
			conv->altform_0c = true;
    2a2f:	80 4b 02 10          	orb    $0x10,0x2(%rbx)
}
    2a33:	5a                   	pop    %rdx
    2a34:	4c 89 e0             	mov    %r12,%rax
    2a37:	5b                   	pop    %rbx
    2a38:	5d                   	pop    %rbp
    2a39:	41 5c                	pop    %r12
    2a3b:	41 5d                	pop    %r13
    2a3d:	c3                   	retq   

0000000000002a3e <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    2a3e:	f3 0f 1e fa          	endbr64 
    2a42:	41 57                	push   %r15
    2a44:	49 89 f7             	mov    %rsi,%r15
    2a47:	41 56                	push   %r14
    2a49:	49 89 fe             	mov    %rdi,%r14
    2a4c:	41 55                	push   %r13
    2a4e:	49 89 d5             	mov    %rdx,%r13
    2a51:	41 54                	push   %r12
    2a53:	49 89 cc             	mov    %rcx,%r12
    2a56:	55                   	push   %rbp
    2a57:	53                   	push   %rbx
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    2a58:	31 db                	xor    %ebx,%ebx
{
    2a5a:	48 83 ec 78          	sub    $0x78,%rsp
    2a5e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2a65:	00 00 
    2a67:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    2a6c:	31 c0                	xor    %eax,%eax
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    2a6e:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    2a73:	40 84 ff             	test   %dil,%dil
    2a76:	0f 84 d2 09 00 00    	je     344e <cbvprintf+0xa10>
		if (*fp != '%') {
    2a7c:	49 8d 6d 01          	lea    0x1(%r13),%rbp
			OUTC(*fp++);
    2a80:	4c 89 fe             	mov    %r15,%rsi
		if (*fp != '%') {
    2a83:	40 80 ff 25          	cmp    $0x25,%dil
    2a87:	0f 85 89 06 00 00    	jne    3116 <cbvprintf+0x6d8>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    2a8d:	31 c0                	xor    %eax,%eax
    2a8f:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    2a94:	b9 08 00 00 00       	mov    $0x8,%ecx
    2a99:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
    2a9b:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
    2aa0:	41 80 7d 01 25       	cmpb   $0x25,0x1(%r13)
    2aa5:	75 1c                	jne    2ac3 <cbvprintf+0x85>
		conv->specifier = *sp++;
    2aa7:	c6 44 24 43 25       	movb   $0x25,0x43(%rsp)
    2aac:	49 8d 6d 02          	lea    0x2(%r13),%rbp
		return sp;
    2ab0:	e9 df 02 00 00       	jmpq   2d94 <cbvprintf+0x356>
		switch (*sp) {
    2ab5:	7e 15                	jle    2acc <cbvprintf+0x8e>
    2ab7:	3c 2d                	cmp    $0x2d,%al
    2ab9:	75 1b                	jne    2ad6 <cbvprintf+0x98>
			conv->flag_dash = true;
    2abb:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
			++sp;
    2ac0:	48 ff c5             	inc    %rbp
		switch (*sp) {
    2ac3:	8a 45 00             	mov    0x0(%rbp),%al
    2ac6:	3c 2b                	cmp    $0x2b,%al
    2ac8:	75 eb                	jne    2ab5 <cbvprintf+0x77>
    2aca:	eb 25                	jmp    2af1 <cbvprintf+0xb3>
    2acc:	3c 20                	cmp    $0x20,%al
    2ace:	74 28                	je     2af8 <cbvprintf+0xba>
    2ad0:	3c 23                	cmp    $0x23,%al
    2ad2:	74 2b                	je     2aff <cbvprintf+0xc1>
    2ad4:	eb 04                	jmp    2ada <cbvprintf+0x9c>
    2ad6:	3c 30                	cmp    $0x30,%al
    2ad8:	74 2c                	je     2b06 <cbvprintf+0xc8>
	if (conv->flag_zero && conv->flag_dash) {
    2ada:	8a 44 24 40          	mov    0x40(%rsp),%al
    2ade:	89 c2                	mov    %eax,%edx
    2ae0:	83 e2 44             	and    $0x44,%edx
    2ae3:	80 fa 44             	cmp    $0x44,%dl
    2ae6:	75 25                	jne    2b0d <cbvprintf+0xcf>
		conv->flag_zero = false;
    2ae8:	83 e0 bf             	and    $0xffffffbf,%eax
    2aeb:	88 44 24 40          	mov    %al,0x40(%rsp)
    2aef:	eb 1c                	jmp    2b0d <cbvprintf+0xcf>
			conv->flag_plus = true;
    2af1:	80 4c 24 40 08       	orb    $0x8,0x40(%rsp)
			break;
    2af6:	eb c8                	jmp    2ac0 <cbvprintf+0x82>
			conv->flag_space = true;
    2af8:	80 4c 24 40 10       	orb    $0x10,0x40(%rsp)
			break;
    2afd:	eb c1                	jmp    2ac0 <cbvprintf+0x82>
			conv->flag_hash = true;
    2aff:	80 4c 24 40 20       	orb    $0x20,0x40(%rsp)
			break;
    2b04:	eb ba                	jmp    2ac0 <cbvprintf+0x82>
			conv->flag_zero = true;
    2b06:	80 4c 24 40 40       	orb    $0x40,0x40(%rsp)
			break;
    2b0b:	eb b3                	jmp    2ac0 <cbvprintf+0x82>
	conv->width_present = true;
    2b0d:	80 4c 24 40 80       	orb    $0x80,0x40(%rsp)
    2b12:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	if (*sp == '*') {
    2b17:	80 7d 00 2a          	cmpb   $0x2a,0x0(%rbp)
    2b1b:	75 0a                	jne    2b27 <cbvprintf+0xe9>
		conv->width_star = true;
    2b1d:	80 4c 24 41 01       	orb    $0x1,0x41(%rsp)
		return ++sp;
    2b22:	48 ff c5             	inc    %rbp
    2b25:	eb 5d                	jmp    2b84 <cbvprintf+0x146>
	size_t width = extract_decimal(&sp);
    2b27:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    2b2c:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    2b31:	e8 23 fe ff ff       	callq  2959 <extract_decimal>
	if (sp != wp) {
    2b36:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    2b3b:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    2b40:	48 39 e9             	cmp    %rbp,%rcx
    2b43:	74 3f                	je     2b84 <cbvprintf+0x146>
		conv->width_present = true;
    2b45:	8a 54 24 40          	mov    0x40(%rsp),%dl
		conv->width_value = width;
    2b49:	89 44 24 44          	mov    %eax,0x44(%rsp)
				      || (width != (size_t)conv->width_value));
    2b4d:	bf 01 00 00 00       	mov    $0x1,%edi
		conv->width_present = true;
    2b52:	83 ca 80             	or     $0xffffff80,%edx
    2b55:	88 54 24 40          	mov    %dl,0x40(%rsp)
		conv->unsupported |= ((conv->width_value < 0)
    2b59:	d0 ea                	shr    %dl
    2b5b:	83 e2 01             	and    $0x1,%edx
				      || (width != (size_t)conv->width_value));
    2b5e:	85 c0                	test   %eax,%eax
    2b60:	78 0e                	js     2b70 <cbvprintf+0x132>
    2b62:	48 63 f8             	movslq %eax,%rdi
    2b65:	48 39 c7             	cmp    %rax,%rdi
    2b68:	40 0f 95 c7          	setne  %dil
    2b6c:	40 0f b6 ff          	movzbl %dil,%edi
		conv->unsupported |= ((conv->width_value < 0)
    2b70:	8a 44 24 40          	mov    0x40(%rsp),%al
    2b74:	09 fa                	or     %edi,%edx
    2b76:	48 89 cd             	mov    %rcx,%rbp
    2b79:	01 d2                	add    %edx,%edx
    2b7b:	83 e0 fd             	and    $0xfffffffd,%eax
    2b7e:	09 c2                	or     %eax,%edx
    2b80:	88 54 24 40          	mov    %dl,0x40(%rsp)
	sp = extract_prec(conv, sp);
    2b84:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	conv->prec_present = (*sp == '.');
    2b89:	8a 4d 00             	mov    0x0(%rbp),%cl
    2b8c:	80 f9 2e             	cmp    $0x2e,%cl
    2b8f:	0f 94 c0             	sete   %al
    2b92:	8d 14 00             	lea    (%rax,%rax,1),%edx
    2b95:	8a 44 24 41          	mov    0x41(%rsp),%al
    2b99:	83 e0 fd             	and    $0xfffffffd,%eax
    2b9c:	09 d0                	or     %edx,%eax
    2b9e:	88 44 24 41          	mov    %al,0x41(%rsp)
	if (!conv->prec_present) {
    2ba2:	80 f9 2e             	cmp    $0x2e,%cl
    2ba5:	75 6b                	jne    2c12 <cbvprintf+0x1d4>
	++sp;
    2ba7:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    2bab:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
	if (*sp == '*') {
    2bb0:	80 7d 01 2a          	cmpb   $0x2a,0x1(%rbp)
    2bb4:	75 0d                	jne    2bc3 <cbvprintf+0x185>
		conv->prec_star = true;
    2bb6:	83 c8 04             	or     $0x4,%eax
		return ++sp;
    2bb9:	48 83 c5 02          	add    $0x2,%rbp
		conv->prec_star = true;
    2bbd:	88 44 24 41          	mov    %al,0x41(%rsp)
		return ++sp;
    2bc1:	eb 4f                	jmp    2c12 <cbvprintf+0x1d4>
	size_t prec = extract_decimal(&sp);
    2bc3:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    2bc8:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    2bcd:	e8 87 fd ff ff       	callq  2959 <extract_decimal>
			      || (prec != (size_t)conv->prec_value));
    2bd2:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    2bd7:	b9 01 00 00 00       	mov    $0x1,%ecx
	size_t prec = extract_decimal(&sp);
    2bdc:	48 89 c2             	mov    %rax,%rdx
	conv->prec_value = prec;
    2bdf:	89 44 24 48          	mov    %eax,0x48(%rsp)
	conv->unsupported |= ((conv->prec_value < 0)
    2be3:	8a 44 24 40          	mov    0x40(%rsp),%al
    2be7:	d0 e8                	shr    %al
    2be9:	83 e0 01             	and    $0x1,%eax
			      || (prec != (size_t)conv->prec_value));
    2bec:	85 d2                	test   %edx,%edx
    2bee:	78 0c                	js     2bfc <cbvprintf+0x1be>
    2bf0:	48 63 ca             	movslq %edx,%rcx
    2bf3:	48 39 d1             	cmp    %rdx,%rcx
    2bf6:	0f 95 c1             	setne  %cl
    2bf9:	0f b6 c9             	movzbl %cl,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    2bfc:	8a 54 24 40          	mov    0x40(%rsp),%dl
    2c00:	09 c8                	or     %ecx,%eax
	return sp;
    2c02:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
	conv->unsupported |= ((conv->prec_value < 0)
    2c07:	01 c0                	add    %eax,%eax
    2c09:	83 e2 fd             	and    $0xfffffffd,%edx
    2c0c:	09 d0                	or     %edx,%eax
    2c0e:	88 44 24 40          	mov    %al,0x40(%rsp)
	switch (*sp) {
    2c12:	8a 4d 00             	mov    0x0(%rbp),%cl
    2c15:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    2c19:	80 f9 6c             	cmp    $0x6c,%cl
    2c1c:	74 54                	je     2c72 <cbvprintf+0x234>
    2c1e:	7f 22                	jg     2c42 <cbvprintf+0x204>
    2c20:	80 f9 68             	cmp    $0x68,%cl
    2c23:	74 33                	je     2c58 <cbvprintf+0x21a>
    2c25:	80 f9 6a             	cmp    $0x6a,%cl
    2c28:	74 6e                	je     2c98 <cbvprintf+0x25a>
    2c2a:	80 f9 4c             	cmp    $0x4c,%cl
    2c2d:	75 7d                	jne    2cac <cbvprintf+0x26e>
		conv->unsupported = true;
    2c2f:	8b 44 24 40          	mov    0x40(%rsp),%eax
    2c33:	66 25 fd 87          	and    $0x87fd,%ax
    2c37:	66 0d 02 40          	or     $0x4002,%ax
    2c3b:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
		break;
    2c40:	eb 72                	jmp    2cb4 <cbvprintf+0x276>
	switch (*sp) {
    2c42:	80 f9 74             	cmp    $0x74,%cl
    2c45:	8a 44 24 41          	mov    0x41(%rsp),%al
    2c49:	74 59                	je     2ca4 <cbvprintf+0x266>
    2c4b:	80 f9 7a             	cmp    $0x7a,%cl
    2c4e:	75 5c                	jne    2cac <cbvprintf+0x26e>
		conv->length_mod = LENGTH_Z;
    2c50:	83 e0 87             	and    $0xffffff87,%eax
    2c53:	83 c8 30             	or     $0x30,%eax
    2c56:	eb 3a                	jmp    2c92 <cbvprintf+0x254>
		if (*++sp == 'h') {
    2c58:	80 7d 01 68          	cmpb   $0x68,0x1(%rbp)
    2c5c:	8a 44 24 41          	mov    0x41(%rsp),%al
    2c60:	75 08                	jne    2c6a <cbvprintf+0x22c>
			conv->length_mod = LENGTH_HH;
    2c62:	83 e0 87             	and    $0xffffff87,%eax
    2c65:	83 c8 08             	or     $0x8,%eax
    2c68:	eb 18                	jmp    2c82 <cbvprintf+0x244>
			conv->length_mod = LENGTH_H;
    2c6a:	83 e0 87             	and    $0xffffff87,%eax
    2c6d:	83 c8 10             	or     $0x10,%eax
    2c70:	eb 20                	jmp    2c92 <cbvprintf+0x254>
		if (*++sp == 'l') {
    2c72:	80 7d 01 6c          	cmpb   $0x6c,0x1(%rbp)
    2c76:	8a 44 24 41          	mov    0x41(%rsp),%al
    2c7a:	75 10                	jne    2c8c <cbvprintf+0x24e>
			conv->length_mod = LENGTH_LL;
    2c7c:	83 e0 87             	and    $0xffffff87,%eax
    2c7f:	83 c8 20             	or     $0x20,%eax
    2c82:	88 44 24 41          	mov    %al,0x41(%rsp)
			++sp;
    2c86:	48 8d 55 02          	lea    0x2(%rbp),%rdx
    2c8a:	eb 28                	jmp    2cb4 <cbvprintf+0x276>
			conv->length_mod = LENGTH_L;
    2c8c:	83 e0 87             	and    $0xffffff87,%eax
    2c8f:	83 c8 18             	or     $0x18,%eax
    2c92:	88 44 24 41          	mov    %al,0x41(%rsp)
    2c96:	eb 1c                	jmp    2cb4 <cbvprintf+0x276>
		conv->length_mod = LENGTH_J;
    2c98:	8a 44 24 41          	mov    0x41(%rsp),%al
    2c9c:	83 e0 87             	and    $0xffffff87,%eax
    2c9f:	83 c8 28             	or     $0x28,%eax
    2ca2:	eb ee                	jmp    2c92 <cbvprintf+0x254>
		conv->length_mod = LENGTH_T;
    2ca4:	83 e0 87             	and    $0xffffff87,%eax
    2ca7:	83 c8 38             	or     $0x38,%eax
    2caa:	eb e6                	jmp    2c92 <cbvprintf+0x254>
		conv->length_mod = LENGTH_NONE;
    2cac:	80 64 24 41 87       	andb   $0x87,0x41(%rsp)
		break;
    2cb1:	48 89 ea             	mov    %rbp,%rdx
	conv->specifier = *sp++;
    2cb4:	8a 02                	mov    (%rdx),%al
    2cb6:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
    2cba:	8a 54 24 41          	mov    0x41(%rsp),%dl
    2cbe:	88 44 24 43          	mov    %al,0x43(%rsp)
	switch (conv->specifier) {
    2cc2:	3c 78                	cmp    $0x78,%al
    2cc4:	0f 8f ab 00 00 00    	jg     2d75 <cbvprintf+0x337>
    2cca:	3c 57                	cmp    $0x57,%al
    2ccc:	7f 11                	jg     2cdf <cbvprintf+0x2a1>
    2cce:	3c 41                	cmp    $0x41,%al
    2cd0:	74 62                	je     2d34 <cbvprintf+0x2f6>
    2cd2:	83 e8 45             	sub    $0x45,%eax
    2cd5:	3c 02                	cmp    $0x2,%al
    2cd7:	0f 87 98 00 00 00    	ja     2d75 <cbvprintf+0x337>
    2cdd:	eb 55                	jmp    2d34 <cbvprintf+0x2f6>
    2cdf:	8d 48 a8             	lea    -0x58(%rax),%ecx
    2ce2:	80 f9 20             	cmp    $0x20,%cl
    2ce5:	0f 87 8a 00 00 00    	ja     2d75 <cbvprintf+0x337>
    2ceb:	48 8d 3d 5e 43 00 00 	lea    0x435e(%rip),%rdi        # 7050 <__func__.5051+0x50>
    2cf2:	0f b6 c9             	movzbl %cl,%ecx
    2cf5:	48 63 0c 8f          	movslq (%rdi,%rcx,4),%rcx
    2cf9:	48 01 f9             	add    %rdi,%rcx
    2cfc:	3e ff e1             	notrack jmpq *%rcx
		conv->specifier_cat = SPECIFIER_SINT;
    2cff:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    2d03:	83 e1 f8             	and    $0xfffffff8,%ecx
    2d06:	83 c9 01             	or     $0x1,%ecx
    2d09:	eb 0a                	jmp    2d15 <cbvprintf+0x2d7>
		conv->specifier_cat = SPECIFIER_UINT;
    2d0b:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    2d0f:	83 e1 f8             	and    $0xfffffff8,%ecx
    2d12:	83 c9 02             	or     $0x2,%ecx
    2d15:	f3 0f 1e fa          	endbr64 
		if (conv->length_mod == LENGTH_UPPER_L) {
    2d19:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
    2d1c:	88 4c 24 42          	mov    %cl,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    2d20:	80 fa 40             	cmp    $0x40,%dl
    2d23:	75 05                	jne    2d2a <cbvprintf+0x2ec>
			conv->invalid = true;
    2d25:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    2d2a:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    2d2c:	3c 63                	cmp    $0x63,%al
    2d2e:	75 4c                	jne    2d7c <cbvprintf+0x33e>
			unsupported = (conv->length_mod != LENGTH_NONE);
    2d30:	84 d2                	test   %dl,%dl
    2d32:	eb 3c                	jmp    2d70 <cbvprintf+0x332>
		conv->specifier_cat = SPECIFIER_FP;
    2d34:	8a 44 24 42          	mov    0x42(%rsp),%al
			unsupported = true;
    2d38:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    2d3a:	83 e0 f8             	and    $0xfffffff8,%eax
    2d3d:	83 c8 04             	or     $0x4,%eax
    2d40:	88 44 24 42          	mov    %al,0x42(%rsp)
			break;
    2d44:	eb 36                	jmp    2d7c <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    2d46:	8a 44 24 42          	mov    0x42(%rsp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    2d4a:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    2d4d:	83 e0 f8             	and    $0xfffffff8,%eax
    2d50:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    2d53:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    2d56:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    2d5a:	0f 94 c1             	sete   %cl
    2d5d:	eb 1d                	jmp    2d7c <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    2d5f:	8a 44 24 42          	mov    0x42(%rsp),%al
    2d63:	83 e0 f8             	and    $0xfffffff8,%eax
    2d66:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    2d69:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    2d6c:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod != LENGTH_NONE) {
    2d70:	0f 95 c1             	setne  %cl
    2d73:	eb 07                	jmp    2d7c <cbvprintf+0x33e>
		conv->invalid = true;
    2d75:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    2d7a:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    2d7c:	8a 54 24 40          	mov    0x40(%rsp),%dl
    2d80:	89 d0                	mov    %edx,%eax
    2d82:	83 e2 fd             	and    $0xfffffffd,%edx
    2d85:	d0 e8                	shr    %al
    2d87:	83 e0 01             	and    $0x1,%eax
    2d8a:	09 c8                	or     %ecx,%eax
    2d8c:	01 c0                	add    %eax,%eax
    2d8e:	09 d0                	or     %edx,%eax
    2d90:	88 44 24 40          	mov    %al,0x40(%rsp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv->width_star) {
    2d94:	8a 4c 24 41          	mov    0x41(%rsp),%cl
    2d98:	f6 c1 01             	test   $0x1,%cl
    2d9b:	74 3c                	je     2dd9 <cbvprintf+0x39b>
			width = va_arg(ap, int);
    2d9d:	41 8b 14 24          	mov    (%r12),%edx
    2da1:	83 fa 2f             	cmp    $0x2f,%edx
    2da4:	77 10                	ja     2db6 <cbvprintf+0x378>
    2da6:	89 d0                	mov    %edx,%eax
    2da8:	83 c2 08             	add    $0x8,%edx
    2dab:	49 03 44 24 10       	add    0x10(%r12),%rax
    2db0:	41 89 14 24          	mov    %edx,(%r12)
    2db4:	eb 0e                	jmp    2dc4 <cbvprintf+0x386>
    2db6:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    2dbb:	48 8d 50 08          	lea    0x8(%rax),%rdx
    2dbf:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    2dc4:	8b 00                	mov    (%rax),%eax
    2dc6:	89 44 24 08          	mov    %eax,0x8(%rsp)

			if (width < 0) {
    2dca:	85 c0                	test   %eax,%eax
    2dcc:	79 22                	jns    2df0 <cbvprintf+0x3b2>
				conv->flag_dash = true;
    2dce:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
				width = -width;
    2dd3:	f7 5c 24 08          	negl   0x8(%rsp)
    2dd7:	eb 17                	jmp    2df0 <cbvprintf+0x3b2>
			}
		} else if (conv->width_present) {
    2dd9:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
		int width = -1;
    2dde:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%rsp)
    2de5:	ff 
		} else if (conv->width_present) {
    2de6:	79 08                	jns    2df0 <cbvprintf+0x3b2>
			width = conv->width_value;
    2de8:	8b 44 24 44          	mov    0x44(%rsp),%eax
    2dec:	89 44 24 08          	mov    %eax,0x8(%rsp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    2df0:	f6 c1 04             	test   $0x4,%cl
    2df3:	74 3a                	je     2e2f <cbvprintf+0x3f1>
			int arg = va_arg(ap, int);
    2df5:	41 8b 14 24          	mov    (%r12),%edx
    2df9:	83 fa 2f             	cmp    $0x2f,%edx
    2dfc:	77 10                	ja     2e0e <cbvprintf+0x3d0>
    2dfe:	89 d0                	mov    %edx,%eax
    2e00:	83 c2 08             	add    $0x8,%edx
    2e03:	49 03 44 24 10       	add    0x10(%r12),%rax
    2e08:	41 89 14 24          	mov    %edx,(%r12)
    2e0c:	eb 0e                	jmp    2e1c <cbvprintf+0x3de>
    2e0e:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    2e13:	48 8d 50 08          	lea    0x8(%rax),%rdx
    2e17:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    2e1c:	44 8b 10             	mov    (%rax),%r10d

			if (arg < 0) {
    2e1f:	45 85 d2             	test   %r10d,%r10d
    2e22:	79 19                	jns    2e3d <cbvprintf+0x3ff>
				conv->prec_present = false;
    2e24:	80 64 24 41 fd       	andb   $0xfd,0x41(%rsp)
		int precision = -1;
    2e29:	41 83 ca ff          	or     $0xffffffff,%r10d
    2e2d:	eb 0e                	jmp    2e3d <cbvprintf+0x3ff>
    2e2f:	41 83 ca ff          	or     $0xffffffff,%r10d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    2e33:	80 e1 02             	and    $0x2,%cl
    2e36:	74 05                	je     2e3d <cbvprintf+0x3ff>
			precision = conv->prec_value;
    2e38:	44 8b 54 24 48       	mov    0x48(%rsp),%r10d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    2e3d:	8a 54 24 41          	mov    0x41(%rsp),%dl
			= (enum specifier_cat_enum)conv->specifier_cat;
    2e41:	8a 44 24 42          	mov    0x42(%rsp),%al
		conv->pad0_value = 0;
    2e45:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
    2e4c:	00 00 
			= (enum length_mod_enum)conv->length_mod;
    2e4e:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
    2e51:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    2e54:	83 e2 0f             	and    $0xf,%edx
		enum length_mod_enum length_mod
    2e57:	0f b6 ca             	movzbl %dl,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    2e5a:	83 f8 01             	cmp    $0x1,%eax
    2e5d:	0f 85 d8 00 00 00    	jne    2f3b <cbvprintf+0x4fd>
			switch (length_mod) {
    2e63:	41 8b 04 24          	mov    (%r12),%eax
    2e67:	80 fa 05             	cmp    $0x5,%dl
    2e6a:	0f 84 1e 01 00 00    	je     2f8e <cbvprintf+0x550>
    2e70:	77 10                	ja     2e82 <cbvprintf+0x444>
    2e72:	80 fa 03             	cmp    $0x3,%dl
    2e75:	74 3f                	je     2eb6 <cbvprintf+0x478>
    2e77:	80 fa 04             	cmp    $0x4,%dl
    2e7a:	0f 84 0e 01 00 00    	je     2f8e <cbvprintf+0x550>
    2e80:	eb 0c                	jmp    2e8e <cbvprintf+0x450>
    2e82:	8d 7a 0a             	lea    0xa(%rdx),%edi
    2e85:	83 e7 0f             	and    $0xf,%edi
    2e88:	40 80 ff 01          	cmp    $0x1,%dil
    2e8c:	76 5e                	jbe    2eec <cbvprintf+0x4ae>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    2e8e:	83 f8 2f             	cmp    $0x2f,%eax
    2e91:	77 10                	ja     2ea3 <cbvprintf+0x465>
    2e93:	89 c7                	mov    %eax,%edi
    2e95:	83 c0 08             	add    $0x8,%eax
    2e98:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    2e9d:	41 89 04 24          	mov    %eax,(%r12)
    2ea1:	eb 0e                	jmp    2eb1 <cbvprintf+0x473>
    2ea3:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    2ea8:	48 8d 47 08          	lea    0x8(%rdi),%rax
    2eac:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2eb1:	48 63 07             	movslq (%rdi),%rax
    2eb4:	eb 5c                	jmp    2f12 <cbvprintf+0x4d4>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
    2eb6:	80 7c 24 43 63       	cmpb   $0x63,0x43(%rsp)
    2ebb:	0f 85 cd 00 00 00    	jne    2f8e <cbvprintf+0x550>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
    2ec1:	83 f8 2f             	cmp    $0x2f,%eax
    2ec4:	77 10                	ja     2ed6 <cbvprintf+0x498>
    2ec6:	89 c1                	mov    %eax,%ecx
    2ec8:	83 c0 08             	add    $0x8,%eax
    2ecb:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    2ed0:	41 89 04 24          	mov    %eax,(%r12)
    2ed4:	eb 0e                	jmp    2ee4 <cbvprintf+0x4a6>
    2ed6:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    2edb:	48 8d 41 08          	lea    0x8(%rcx),%rax
    2edf:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2ee4:	48 63 01             	movslq (%rcx),%rax
    2ee7:	e9 b1 01 00 00       	jmpq   309d <cbvprintf+0x65f>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    2eec:	83 f8 2f             	cmp    $0x2f,%eax
    2eef:	77 10                	ja     2f01 <cbvprintf+0x4c3>
    2ef1:	89 c7                	mov    %eax,%edi
    2ef3:	83 c0 08             	add    $0x8,%eax
    2ef6:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    2efb:	41 89 04 24          	mov    %eax,(%r12)
    2eff:	eb 0e                	jmp    2f0f <cbvprintf+0x4d1>
    2f01:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    2f06:	48 8d 47 08          	lea    0x8(%rdi),%rax
    2f0a:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2f0f:	48 8b 07             	mov    (%rdi),%rax
				value->sint =
    2f12:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    2f17:	83 f9 01             	cmp    $0x1,%ecx
    2f1a:	75 0b                	jne    2f27 <cbvprintf+0x4e9>
				value->sint = (char)value->sint;
    2f1c:	48 0f be 44 24 30    	movsbq 0x30(%rsp),%rax
    2f22:	e9 76 01 00 00       	jmpq   309d <cbvprintf+0x65f>
			} else if (length_mod == LENGTH_H) {
    2f27:	83 f9 02             	cmp    $0x2,%ecx
    2f2a:	0f 85 72 01 00 00    	jne    30a2 <cbvprintf+0x664>
				value->sint = (short)value->sint;
    2f30:	48 0f bf 44 24 30    	movswq 0x30(%rsp),%rax
    2f36:	e9 62 01 00 00       	jmpq   309d <cbvprintf+0x65f>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    2f3b:	83 f8 02             	cmp    $0x2,%eax
    2f3e:	0f 85 ca 00 00 00    	jne    300e <cbvprintf+0x5d0>
			switch (length_mod) {
    2f44:	41 8b 04 24          	mov    (%r12),%eax
    2f48:	80 fa 05             	cmp    $0x5,%dl
    2f4b:	74 41                	je     2f8e <cbvprintf+0x550>
    2f4d:	77 0c                	ja     2f5b <cbvprintf+0x51d>
    2f4f:	80 fa 03             	cmp    $0x3,%dl
    2f52:	74 3a                	je     2f8e <cbvprintf+0x550>
    2f54:	80 fa 04             	cmp    $0x4,%dl
    2f57:	74 35                	je     2f8e <cbvprintf+0x550>
    2f59:	eb 0c                	jmp    2f67 <cbvprintf+0x529>
    2f5b:	8d 7a 0a             	lea    0xa(%rdx),%edi
    2f5e:	83 e7 0f             	and    $0xf,%edi
    2f61:	40 80 ff 01          	cmp    $0x1,%dil
    2f65:	76 52                	jbe    2fb9 <cbvprintf+0x57b>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
    2f67:	83 f8 2f             	cmp    $0x2f,%eax
    2f6a:	77 10                	ja     2f7c <cbvprintf+0x53e>
    2f6c:	89 c7                	mov    %eax,%edi
    2f6e:	83 c0 08             	add    $0x8,%eax
    2f71:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    2f76:	41 89 04 24          	mov    %eax,(%r12)
    2f7a:	eb 0e                	jmp    2f8a <cbvprintf+0x54c>
    2f7c:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    2f81:	48 8d 47 08          	lea    0x8(%rdi),%rax
    2f85:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2f8a:	8b 07                	mov    (%rdi),%eax
    2f8c:	eb 51                	jmp    2fdf <cbvprintf+0x5a1>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    2f8e:	83 f8 2f             	cmp    $0x2f,%eax
    2f91:	77 10                	ja     2fa3 <cbvprintf+0x565>
    2f93:	89 c1                	mov    %eax,%ecx
    2f95:	83 c0 08             	add    $0x8,%eax
    2f98:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    2f9d:	41 89 04 24          	mov    %eax,(%r12)
    2fa1:	eb 0e                	jmp    2fb1 <cbvprintf+0x573>
    2fa3:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    2fa8:	48 8d 41 08          	lea    0x8(%rcx),%rax
    2fac:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2fb1:	48 8b 01             	mov    (%rcx),%rax
    2fb4:	e9 e4 00 00 00       	jmpq   309d <cbvprintf+0x65f>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    2fb9:	83 f8 2f             	cmp    $0x2f,%eax
    2fbc:	77 10                	ja     2fce <cbvprintf+0x590>
    2fbe:	89 c7                	mov    %eax,%edi
    2fc0:	83 c0 08             	add    $0x8,%eax
    2fc3:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    2fc8:	41 89 04 24          	mov    %eax,(%r12)
    2fcc:	eb 0e                	jmp    2fdc <cbvprintf+0x59e>
    2fce:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    2fd3:	48 8d 47 08          	lea    0x8(%rdi),%rax
    2fd7:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    2fdc:	48 8b 07             	mov    (%rdi),%rax
				value->uint =
    2fdf:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    2fe4:	83 f9 01             	cmp    $0x1,%ecx
    2fe7:	75 0e                	jne    2ff7 <cbvprintf+0x5b9>
				value->uint = (unsigned char)value->uint;
    2fe9:	48 81 64 24 30 ff 00 	andq   $0xff,0x30(%rsp)
    2ff0:	00 00 
    2ff2:	e9 ab 00 00 00       	jmpq   30a2 <cbvprintf+0x664>
			} else if (length_mod == LENGTH_H) {
    2ff7:	83 f9 02             	cmp    $0x2,%ecx
    2ffa:	0f 85 a2 00 00 00    	jne    30a2 <cbvprintf+0x664>
				value->uint = (unsigned short)value->uint;
    3000:	48 81 64 24 30 ff ff 	andq   $0xffff,0x30(%rsp)
    3007:	00 00 
    3009:	e9 94 00 00 00       	jmpq   30a2 <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    300e:	83 f8 04             	cmp    $0x4,%eax
    3011:	75 5b                	jne    306e <cbvprintf+0x630>
			if (length_mod == LENGTH_UPPER_L) {
    3013:	83 f9 08             	cmp    $0x8,%ecx
    3016:	75 1e                	jne    3036 <cbvprintf+0x5f8>
				value->ldbl = va_arg(ap, long double);
    3018:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    301d:	48 83 c0 0f          	add    $0xf,%rax
    3021:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    3025:	48 8d 48 10          	lea    0x10(%rax),%rcx
    3029:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    302e:	db 28                	fldt   (%rax)
    3030:	db 7c 24 30          	fstpt  0x30(%rsp)
    3034:	eb 6c                	jmp    30a2 <cbvprintf+0x664>
			} else {
				value->dbl = va_arg(ap, double);
    3036:	41 8b 4c 24 04       	mov    0x4(%r12),%ecx
    303b:	81 f9 af 00 00 00    	cmp    $0xaf,%ecx
    3041:	77 11                	ja     3054 <cbvprintf+0x616>
    3043:	89 c8                	mov    %ecx,%eax
    3045:	83 c1 10             	add    $0x10,%ecx
    3048:	49 03 44 24 10       	add    0x10(%r12),%rax
    304d:	41 89 4c 24 04       	mov    %ecx,0x4(%r12)
    3052:	eb 0e                	jmp    3062 <cbvprintf+0x624>
    3054:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3059:	48 8d 48 08          	lea    0x8(%rax),%rcx
    305d:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    3062:	f2 0f 10 00          	movsd  (%rax),%xmm0
    3066:	f2 0f 11 44 24 30    	movsd  %xmm0,0x30(%rsp)
    306c:	eb 34                	jmp    30a2 <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    306e:	83 f8 03             	cmp    $0x3,%eax
    3071:	75 2f                	jne    30a2 <cbvprintf+0x664>
			value->ptr = va_arg(ap, void *);
    3073:	41 8b 0c 24          	mov    (%r12),%ecx
    3077:	83 f9 2f             	cmp    $0x2f,%ecx
    307a:	77 10                	ja     308c <cbvprintf+0x64e>
    307c:	89 c8                	mov    %ecx,%eax
    307e:	83 c1 08             	add    $0x8,%ecx
    3081:	49 03 44 24 10       	add    0x10(%r12),%rax
    3086:	41 89 0c 24          	mov    %ecx,(%r12)
    308a:	eb 0e                	jmp    309a <cbvprintf+0x65c>
    308c:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3091:	48 8d 48 08          	lea    0x8(%rax),%rcx
    3095:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    309a:	48 8b 00             	mov    (%rax),%rax
    309d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    30a2:	8a 4c 24 40          	mov    0x40(%rsp),%cl
    30a6:	f6 c1 03             	test   $0x3,%cl
    30a9:	74 23                	je     30ce <cbvprintf+0x690>
			OUTS(sp, fp);
    30ab:	48 89 e9             	mov    %rbp,%rcx
    30ae:	4c 89 ea             	mov    %r13,%rdx
    30b1:	4c 89 fe             	mov    %r15,%rsi
    30b4:	4c 89 f7             	mov    %r14,%rdi
    30b7:	e8 4c f8 ff ff       	callq  2908 <outs>
    30bc:	85 c0                	test   %eax,%eax
    30be:	0f 88 8c 03 00 00    	js     3450 <cbvprintf+0xa12>
    30c4:	48 98                	cltq   
    30c6:	48 01 c3             	add    %rax,%rbx
			continue;
    30c9:	e9 78 03 00 00       	jmpq   3446 <cbvprintf+0xa08>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    30ce:	8a 44 24 43          	mov    0x43(%rsp),%al
    30d2:	3c 78                	cmp    $0x78,%al
    30d4:	0f 8f 6c 03 00 00    	jg     3446 <cbvprintf+0xa08>
    30da:	3c 62                	cmp    $0x62,%al
    30dc:	7f 11                	jg     30ef <cbvprintf+0x6b1>
    30de:	3c 25                	cmp    $0x25,%al
    30e0:	74 2c                	je     310e <cbvprintf+0x6d0>
    30e2:	3c 58                	cmp    $0x58,%al
    30e4:	0f 84 c6 00 00 00    	je     31b0 <cbvprintf+0x772>
    30ea:	e9 57 03 00 00       	jmpq   3446 <cbvprintf+0xa08>
    30ef:	83 e8 63             	sub    $0x63,%eax
    30f2:	3c 15                	cmp    $0x15,%al
    30f4:	0f 87 4c 03 00 00    	ja     3446 <cbvprintf+0xa08>
    30fa:	48 8d 3d d3 3f 00 00 	lea    0x3fd3(%rip),%rdi        # 70d4 <__func__.5051+0xd4>
    3101:	0f b6 c0             	movzbl %al,%eax
    3104:	48 63 04 87          	movslq (%rdi,%rax,4),%rax
    3108:	48 01 f8             	add    %rdi,%rax
    310b:	3e ff e0             	notrack jmpq *%rax
		case '%':
			OUTC('%');
    310e:	4c 89 fe             	mov    %r15,%rsi
    3111:	bf 25 00 00 00       	mov    $0x25,%edi
    3116:	31 c0                	xor    %eax,%eax
    3118:	41 ff d6             	callq  *%r14
    311b:	85 c0                	test   %eax,%eax
    311d:	0f 88 2d 03 00 00    	js     3450 <cbvprintf+0xa12>
    3123:	48 ff c3             	inc    %rbx
			break;
    3126:	e9 1b 03 00 00       	jmpq   3446 <cbvprintf+0xa08>
		case 's': {
			bps = (const char *)value->ptr;
    312b:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13

			size_t len;

			if (precision >= 0) {
    3130:	45 85 d2             	test   %r10d,%r10d
    3133:	78 0d                	js     3142 <cbvprintf+0x704>
				len = strnlen(bps, precision);
    3135:	49 63 f2             	movslq %r10d,%rsi
    3138:	4c 89 ef             	mov    %r13,%rdi
    313b:	e8 60 f2 ff ff       	callq  23a0 <strnlen@plt>
    3140:	eb 14                	jmp    3156 <cbvprintf+0x718>
			} else {
				len = strlen(bps);
    3142:	31 c0                	xor    %eax,%eax
    3144:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3148:	4c 89 ef             	mov    %r13,%rdi
    314b:	f2 ae                	repnz scas %es:(%rdi),%al
    314d:	48 89 c8             	mov    %rcx,%rax
    3150:	48 f7 d0             	not    %rax
    3153:	48 ff c8             	dec    %rax
			}

			bpe = bps + len;
    3156:	4c 01 e8             	add    %r13,%rax
		char sign = 0;
    3159:	45 31 c9             	xor    %r9d,%r9d
			bpe = bps + len;
    315c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			precision = -1;

			break;
    3161:	e9 55 01 00 00       	jmpq   32bb <cbvprintf+0x87d>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    3166:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			bpe = buf + 1;
			break;
    316b:	45 31 c9             	xor    %r9d,%r9d
			bps = buf;
    316e:	4c 8d 6c 24 52       	lea    0x52(%rsp),%r13
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    3173:	88 44 24 52          	mov    %al,0x52(%rsp)
			bpe = buf + 1;
    3177:	48 8d 44 24 53       	lea    0x53(%rsp),%rax
    317c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			break;
    3181:	e9 3e 01 00 00       	jmpq   32c4 <cbvprintf+0x886>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
    3186:	41 b1 2b             	mov    $0x2b,%r9b
			if (conv->flag_plus) {
    3189:	f6 c1 08             	test   $0x8,%cl
    318c:	75 0b                	jne    3199 <cbvprintf+0x75b>
			} else if (conv->flag_space) {
				sign = ' ';
    318e:	80 e1 10             	and    $0x10,%cl
    3191:	41 0f 95 c1          	setne  %r9b
    3195:	41 c1 e1 05          	shl    $0x5,%r9d

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    3199:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			if (sint < 0) {
    319e:	48 85 c0             	test   %rax,%rax
    31a1:	79 10                	jns    31b3 <cbvprintf+0x775>
				sign = '-';
				value->uint = (uint_value_type)-sint;
    31a3:	48 f7 d8             	neg    %rax
				sign = '-';
    31a6:	41 b1 2d             	mov    $0x2d,%r9b
				value->uint = (uint_value_type)-sint;
    31a9:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    31ae:	eb 03                	jmp    31b3 <cbvprintf+0x775>
		switch (conv->specifier) {
    31b0:	45 31 c9             	xor    %r9d,%r9d
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    31b3:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    31b8:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    31bd:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    31c2:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    31c7:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    31cc:	e8 bf f7 ff ff       	callq  2990 <encode_uint>
    31d1:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
    31d6:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    31db:	49 89 c5             	mov    %rax,%r13
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    31de:	45 85 d2             	test   %r10d,%r10d
    31e1:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
    31e6:	0f 88 ca 00 00 00    	js     32b6 <cbvprintf+0x878>
				size_t len = bpe - bps;
    31ec:	48 89 c1             	mov    %rax,%rcx
				 * conversions with precision.
				 */
				conv->flag_zero = false;

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    31ef:	49 63 d2             	movslq %r10d,%rdx
				conv->flag_zero = false;
    31f2:	80 64 24 40 bf       	andb   $0xbf,0x40(%rsp)
				size_t len = bpe - bps;
    31f7:	4c 29 e9             	sub    %r13,%rcx
		const char *bpe = buf + sizeof(buf);
    31fa:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
				if (len < (size_t)precision) {
    31ff:	48 39 ca             	cmp    %rcx,%rdx
    3202:	0f 86 b3 00 00 00    	jbe    32bb <cbvprintf+0x87d>
					conv->pad0_value = precision - (int)len;
    3208:	41 29 ca             	sub    %ecx,%r10d
    320b:	44 89 54 24 44       	mov    %r10d,0x44(%rsp)
    3210:	e9 a6 00 00 00       	jmpq   32bb <cbvprintf+0x87d>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    3215:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    321a:	48 8d 05 ba 3f 00 00 	lea    0x3fba(%rip),%rax        # 71db <__func__.5051+0x1db>
    3221:	45 31 c9             	xor    %r9d,%r9d
    3224:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			bps = "(nil)";
    3229:	4c 8d 68 fb          	lea    -0x5(%rax),%r13
			if (value->ptr != NULL) {
    322d:	48 85 ff             	test   %rdi,%rdi
    3230:	0f 84 8e 00 00 00    	je     32c4 <cbvprintf+0x886>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3236:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    323b:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    3240:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    3245:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    324a:	e8 41 f7 ff ff       	callq  2990 <encode_uint>
				goto prec_int_pad0;
    324f:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    3254:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3259:	49 89 c5             	mov    %rax,%r13
				conv->altform_0c = true;
    325c:	66 8b 44 24 42       	mov    0x42(%rsp),%ax
    3261:	66 25 ef 00          	and    $0xef,%ax
    3265:	66 0d 10 78          	or     $0x7810,%ax
    3269:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
				goto prec_int_pad0;
    326e:	e9 6b ff ff ff       	jmpq   31de <cbvprintf+0x7a0>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    3273:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    3278:	48 63 c3             	movslq %ebx,%rax
    327b:	80 fa 07             	cmp    $0x7,%dl
    327e:	0f 87 c2 01 00 00    	ja     3446 <cbvprintf+0xa08>
    3284:	48 8d 35 a1 3e 00 00 	lea    0x3ea1(%rip),%rsi        # 712c <__func__.5051+0x12c>
    328b:	0f b6 d2             	movzbl %dl,%edx
    328e:	48 63 14 96          	movslq (%rsi,%rdx,4),%rdx
    3292:	48 01 f2             	add    %rsi,%rdx
    3295:	3e ff e2             	notrack jmpq *%rdx
		*(int *)dp = count;
    3298:	89 01                	mov    %eax,(%rcx)
		break;
    329a:	e9 a7 01 00 00       	jmpq   3446 <cbvprintf+0xa08>
		*(signed char *)dp = (signed char)count;
    329f:	88 19                	mov    %bl,(%rcx)
		break;
    32a1:	e9 a0 01 00 00       	jmpq   3446 <cbvprintf+0xa08>
		*(short *)dp = (short)count;
    32a6:	66 89 19             	mov    %bx,(%rcx)
		break;
    32a9:	e9 98 01 00 00       	jmpq   3446 <cbvprintf+0xa08>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    32ae:	48 89 01             	mov    %rax,(%rcx)
		break;
    32b1:	e9 90 01 00 00       	jmpq   3446 <cbvprintf+0xa08>
		const char *bpe = buf + sizeof(buf);
    32b6:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    32bb:	4d 85 ed             	test   %r13,%r13
    32be:	0f 84 82 01 00 00    	je     3446 <cbvprintf+0xa08>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    32c4:	48 8b 44 24 10       	mov    0x10(%rsp),%rax

		if (sign != 0) {
			nj_len += 1U;
		}

		if (conv->altform_0c) {
    32c9:	8a 4c 24 42          	mov    0x42(%rsp),%cl
		size_t nj_len = (bpe - bps);
    32cd:	4c 29 e8             	sub    %r13,%rax
			nj_len += 1U;
    32d0:	41 80 f9 01          	cmp    $0x1,%r9b
    32d4:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		if (conv->altform_0c) {
    32d8:	f6 c1 10             	test   $0x10,%cl
    32db:	74 06                	je     32e3 <cbvprintf+0x8a5>
			nj_len += 2U;
    32dd:	48 83 c0 02          	add    $0x2,%rax
    32e1:	eb 0c                	jmp    32ef <cbvprintf+0x8b1>
		} else if (conv->altform_0) {
    32e3:	89 ca                	mov    %ecx,%edx
    32e5:	83 e2 08             	and    $0x8,%edx
			nj_len += 1U;
    32e8:	80 fa 01             	cmp    $0x1,%dl
    32eb:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		}

		nj_len += conv->pad0_value;
    32ef:	48 63 54 24 44       	movslq 0x44(%rsp),%rdx
    32f4:	48 01 d0             	add    %rdx,%rax
		if (conv->pad_fp) {
    32f7:	80 e1 40             	and    $0x40,%cl
    32fa:	74 08                	je     3304 <cbvprintf+0x8c6>
			nj_len += conv->pad0_pre_exp;
    32fc:	48 63 54 24 48       	movslq 0x48(%rsp),%rdx
    3301:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    3304:	83 7c 24 08 00       	cmpl   $0x0,0x8(%rsp)
    3309:	7e 73                	jle    337e <cbvprintf+0x940>
			width -= (int)nj_len;
    330b:	29 44 24 08          	sub    %eax,0x8(%rsp)

			if (!conv->flag_dash) {
    330f:	8a 44 24 40          	mov    0x40(%rsp),%al
    3313:	a8 04                	test   $0x4,%al
    3315:	75 67                	jne    337e <cbvprintf+0x940>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    3317:	a8 40                	test   $0x40,%al
    3319:	74 21                	je     333c <cbvprintf+0x8fe>
					if (sign != 0) {
    331b:	45 84 c9             	test   %r9b,%r9b
    331e:	74 20                	je     3340 <cbvprintf+0x902>
						OUTC(sign);
    3320:	31 c0                	xor    %eax,%eax
    3322:	41 0f be f9          	movsbl %r9b,%edi
    3326:	4c 89 fe             	mov    %r15,%rsi
    3329:	41 ff d6             	callq  *%r14
    332c:	85 c0                	test   %eax,%eax
    332e:	0f 88 1c 01 00 00    	js     3450 <cbvprintf+0xa12>
    3334:	48 ff c3             	inc    %rbx
						sign = 0;
    3337:	45 31 c9             	xor    %r9d,%r9d
    333a:	eb 04                	jmp    3340 <cbvprintf+0x902>
				char pad = ' ';
    333c:	b0 20                	mov    $0x20,%al
    333e:	eb 02                	jmp    3342 <cbvprintf+0x904>
					}
					pad = '0';
    3340:	b0 30                	mov    $0x30,%al
    3342:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
				}

				while (width-- > 0) {
					OUTC(pad);
    3346:	0f be d0             	movsbl %al,%edx
				while (width-- > 0) {
    3349:	ff 4c 24 08          	decl   0x8(%rsp)
    334d:	85 c9                	test   %ecx,%ecx
    334f:	7e 2d                	jle    337e <cbvprintf+0x940>
					OUTC(pad);
    3351:	31 c0                	xor    %eax,%eax
    3353:	44 88 4c 24 1f       	mov    %r9b,0x1f(%rsp)
    3358:	4c 89 fe             	mov    %r15,%rsi
    335b:	89 d7                	mov    %edx,%edi
    335d:	89 54 24 18          	mov    %edx,0x18(%rsp)
    3361:	41 ff d6             	callq  *%r14
    3364:	85 c0                	test   %eax,%eax
    3366:	0f 88 e4 00 00 00    	js     3450 <cbvprintf+0xa12>
				while (width-- > 0) {
    336c:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
    3370:	8b 54 24 18          	mov    0x18(%rsp),%edx
					OUTC(pad);
    3374:	48 ff c3             	inc    %rbx
    3377:	44 8a 4c 24 1f       	mov    0x1f(%rsp),%r9b
    337c:	eb cb                	jmp    3349 <cbvprintf+0x90b>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    337e:	45 84 c9             	test   %r9b,%r9b
    3381:	74 17                	je     339a <cbvprintf+0x95c>
			OUTC(sign);
    3383:	31 c0                	xor    %eax,%eax
    3385:	41 0f be f9          	movsbl %r9b,%edi
    3389:	4c 89 fe             	mov    %r15,%rsi
    338c:	41 ff d6             	callq  *%r14
    338f:	85 c0                	test   %eax,%eax
    3391:	0f 88 b9 00 00 00    	js     3450 <cbvprintf+0xa12>
    3397:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    339a:	8a 44 24 42          	mov    0x42(%rsp),%al
    339e:	a8 10                	test   $0x10,%al
    33a0:	75 04                	jne    33a6 <cbvprintf+0x968>
    33a2:	a8 08                	test   $0x8,%al
    33a4:	74 18                	je     33be <cbvprintf+0x980>
				OUTC('0');
    33a6:	31 c0                	xor    %eax,%eax
    33a8:	4c 89 fe             	mov    %r15,%rsi
    33ab:	bf 30 00 00 00       	mov    $0x30,%edi
    33b0:	41 ff d6             	callq  *%r14
    33b3:	85 c0                	test   %eax,%eax
    33b5:	0f 88 95 00 00 00    	js     3450 <cbvprintf+0xa12>
    33bb:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
    33be:	f6 44 24 42 10       	testb  $0x10,0x42(%rsp)
    33c3:	74 14                	je     33d9 <cbvprintf+0x99b>
				OUTC(conv->specifier);
    33c5:	31 c0                	xor    %eax,%eax
    33c7:	0f be 7c 24 43       	movsbl 0x43(%rsp),%edi
    33cc:	4c 89 fe             	mov    %r15,%rsi
    33cf:	41 ff d6             	callq  *%r14
    33d2:	85 c0                	test   %eax,%eax
    33d4:	78 7a                	js     3450 <cbvprintf+0xa12>
    33d6:	48 ff c3             	inc    %rbx
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
    33d9:	8b 44 24 44          	mov    0x44(%rsp),%eax
    33dd:	01 d8                	add    %ebx,%eax
    33df:	89 44 24 18          	mov    %eax,0x18(%rsp)
    33e3:	8b 44 24 18          	mov    0x18(%rsp),%eax
    33e7:	29 d8                	sub    %ebx,%eax
    33e9:	85 c0                	test   %eax,%eax
    33eb:	7e 16                	jle    3403 <cbvprintf+0x9c5>
				OUTC('0');
    33ed:	31 c0                	xor    %eax,%eax
    33ef:	4c 89 fe             	mov    %r15,%rsi
    33f2:	bf 30 00 00 00       	mov    $0x30,%edi
    33f7:	41 ff d6             	callq  *%r14
    33fa:	85 c0                	test   %eax,%eax
    33fc:	78 52                	js     3450 <cbvprintf+0xa12>
    33fe:	48 ff c3             	inc    %rbx
    3401:	eb e0                	jmp    33e3 <cbvprintf+0x9a5>
			}

			OUTS(bps, bpe);
    3403:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    3408:	4c 89 ea             	mov    %r13,%rdx
    340b:	4c 89 fe             	mov    %r15,%rsi
    340e:	4c 89 f7             	mov    %r14,%rdi
    3411:	e8 f2 f4 ff ff       	callq  2908 <outs>
    3416:	85 c0                	test   %eax,%eax
    3418:	78 36                	js     3450 <cbvprintf+0xa12>
    341a:	44 8b 6c 24 08       	mov    0x8(%rsp),%r13d
    341f:	48 98                	cltq   
    3421:	48 01 c3             	add    %rax,%rbx
    3424:	41 01 dd             	add    %ebx,%r13d
		}

		/* Finish left justification */
		while (width > 0) {
    3427:	44 89 e8             	mov    %r13d,%eax
    342a:	29 d8                	sub    %ebx,%eax
    342c:	85 c0                	test   %eax,%eax
    342e:	7e 16                	jle    3446 <cbvprintf+0xa08>
			OUTC(' ');
    3430:	31 c0                	xor    %eax,%eax
    3432:	4c 89 fe             	mov    %r15,%rsi
    3435:	bf 20 00 00 00       	mov    $0x20,%edi
    343a:	41 ff d6             	callq  *%r14
    343d:	85 c0                	test   %eax,%eax
    343f:	78 0f                	js     3450 <cbvprintf+0xa12>
    3441:	48 ff c3             	inc    %rbx
			--width;
    3444:	eb e1                	jmp    3427 <cbvprintf+0x9e9>
			OUTS(bps, bpe);
    3446:	49 89 ed             	mov    %rbp,%r13
    3449:	e9 20 f6 ff ff       	jmpq   2a6e <cbvprintf+0x30>
		}
	}

	return count;
    344e:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
    3450:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    3455:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    345c:	00 00 
    345e:	74 05                	je     3465 <cbvprintf+0xa27>
    3460:	e8 0b ef ff ff       	callq  2370 <__stack_chk_fail@plt>
    3465:	48 83 c4 78          	add    $0x78,%rsp
    3469:	5b                   	pop    %rbx
    346a:	5d                   	pop    %rbp
    346b:	41 5c                	pop    %r12
    346d:	41 5d                	pop    %r13
    346f:	41 5e                	pop    %r14
    3471:	41 5f                	pop    %r15
    3473:	c3                   	retq   

0000000000003474 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    3474:	f3 0f 1e fa          	endbr64 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    3478:	c3                   	retq   

0000000000003479 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    3479:	f3 0f 1e fa          	endbr64 
    347d:	50                   	push   %rax
	setvbuf(stdout, NULL, _IOLBF, 512);
    347e:	48 8b 05 23 6b 00 00 	mov    0x6b23(%rip),%rax        # 9fa8 <stdout@GLIBC_2.2.5>
    3485:	b9 00 02 00 00       	mov    $0x200,%ecx
    348a:	31 f6                	xor    %esi,%esi
    348c:	ba 01 00 00 00       	mov    $0x1,%edx
    3491:	48 8b 38             	mov    (%rax),%rdi
    3494:	e8 a7 ef ff ff       	callq  2440 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
    3499:	48 8b 05 58 6b 00 00 	mov    0x6b58(%rip),%rax        # 9ff8 <stderr@GLIBC_2.2.5>
    34a0:	ba 01 00 00 00       	mov    $0x1,%edx
    34a5:	31 f6                	xor    %esi,%esi
    34a7:	b9 00 02 00 00       	mov    $0x200,%ecx
    34ac:	48 8b 38             	mov    (%rax),%rdi
    34af:	e8 8c ef ff ff       	callq  2440 <setvbuf@plt>
	__printk_hook_install(putchar);
    34b4:	48 8b 3d dd 6a 00 00 	mov    0x6add(%rip),%rdi        # 9f98 <putchar@GLIBC_2.2.5>
    34bb:	e8 b4 f1 ff ff       	callq  2674 <__printk_hook_install>
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    34c0:	31 c0                	xor    %eax,%eax
    34c2:	5a                   	pop    %rdx
    34c3:	c3                   	retq   

00000000000034c4 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    34c4:	f3 0f 1e fa          	endbr64 
    34c8:	50                   	push   %rax
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    34c9:	e8 e8 0a 00 00       	callq  3fb6 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    34ce:	48 8b 35 e3 81 00 00 	mov    0x81e3(%rip),%rsi        # b6b8 <last_tick_time>
    34d5:	48 8b 0d e4 81 00 00 	mov    0x81e4(%rip),%rcx        # b6c0 <tick_period>
    34dc:	31 d2                	xor    %edx,%edx
    34de:	48 29 f0             	sub    %rsi,%rax
    34e1:	48 f7 f1             	div    %rcx

	last_tick_time += elapsed_ticks*tick_period;
    34e4:	48 63 d0             	movslq %eax,%rdx
	z_clock_announce(elapsed_ticks);
    34e7:	89 c7                	mov    %eax,%edi
	last_tick_time += elapsed_ticks*tick_period;
    34e9:	48 0f af d1          	imul   %rcx,%rdx
    34ed:	48 01 f2             	add    %rsi,%rdx
    34f0:	48 89 15 c1 81 00 00 	mov    %rdx,0x81c1(%rip)        # b6b8 <last_tick_time>
}
    34f7:	5a                   	pop    %rdx
	z_clock_announce(elapsed_ticks);
    34f8:	e9 28 2d 00 00       	jmpq   6225 <z_clock_announce>

00000000000034fd <z_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int z_clock_driver_init(const struct device *device)
{
    34fd:	f3 0f 1e fa          	endbr64 
    3501:	50                   	push   %rax
	ARG_UNUSED(device);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    3502:	48 c7 05 b3 81 00 00 	movq   $0x2710,0x81b3(%rip)        # b6c0 <tick_period>
    3509:	10 27 00 00 

	last_tick_time = hwm_get_time();
    350d:	e8 a4 0a 00 00       	callq  3fb6 <hwm_get_time>
	hwtimer_enable(tick_period);
    3512:	48 8b 3d a7 81 00 00 	mov    0x81a7(%rip),%rdi        # b6c0 <tick_period>
	last_tick_time = hwm_get_time();
    3519:	48 89 05 98 81 00 00 	mov    %rax,0x8198(%rip)        # b6b8 <last_tick_time>
	hwtimer_enable(tick_period);
    3520:	e8 32 0d 00 00       	callq  4257 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    3525:	31 c9                	xor    %ecx,%ecx
    3527:	48 8d 15 96 ff ff ff 	lea    -0x6a(%rip),%rdx        # 34c4 <np_timer_isr>
    352e:	31 f6                	xor    %esi,%esi
    3530:	31 ff                	xor    %edi,%edi
    3532:	e8 0a 11 00 00       	callq  4641 <posix_isr_declare>
    3537:	31 d2                	xor    %edx,%edx
    3539:	be 01 00 00 00       	mov    $0x1,%esi
    353e:	31 ff                	xor    %edi,%edi
    3540:	e8 21 11 00 00       	callq  4666 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    3545:	31 ff                	xor    %edi,%edi
    3547:	e8 57 00 00 00       	callq  35a3 <arch_irq_enable>

	return 0;
}
    354c:	31 c0                	xor    %eax,%eax
    354e:	5a                   	pop    %rdx
    354f:	c3                   	retq   

0000000000003550 <z_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void z_clock_set_timeout(int32_t ticks, bool idle)
{
    3550:	f3 0f 1e fa          	endbr64 

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with z_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    3554:	49 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%r8
    355b:	ff ff 7f 
	if (ticks == K_TICKS_FOREVER) {
    355e:	83 ff ff             	cmp    $0xffffffff,%edi
    3561:	74 0c                	je     356f <z_clock_set_timeout+0x1f>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    3563:	45 31 c0             	xor    %r8d,%r8d
	} else if (ticks > 0) {
    3566:	85 ff                	test   %edi,%edi
    3568:	7e 05                	jle    356f <z_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
    356a:	ff cf                	dec    %edi
    356c:	4c 63 c7             	movslq %edi,%r8
	}
	hwtimer_set_silent_ticks(silent_ticks);
    356f:	4c 89 c7             	mov    %r8,%rdi
    3572:	e9 92 0e 00 00       	jmpq   4409 <hwtimer_set_silent_ticks>

0000000000003577 <z_clock_elapsed>:
 * last call to z_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t z_clock_elapsed(void)
{
    3577:	f3 0f 1e fa          	endbr64 
    357b:	50                   	push   %rax
	return (hwm_get_time() - last_tick_time)/tick_period;
    357c:	e8 35 0a 00 00       	callq  3fb6 <hwm_get_time>
    3581:	31 d2                	xor    %edx,%edx
    3583:	48 2b 05 2e 81 00 00 	sub    0x812e(%rip),%rax        # b6b8 <last_tick_time>
    358a:	48 f7 35 2f 81 00 00 	divq   0x812f(%rip)        # b6c0 <tick_period>
}
    3591:	5a                   	pop    %rdx
    3592:	c3                   	retq   

0000000000003593 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    3593:	f3 0f 1e fa          	endbr64 
    3597:	50                   	push   %rax
	sys_trace_idle();
	posix_irq_full_unlock();
    3598:	e8 90 10 00 00       	callq  462d <posix_irq_full_unlock>
	posix_halt_cpu();
}
    359d:	5a                   	pop    %rdx
	posix_halt_cpu();
    359e:	e9 5e 06 00 00       	jmpq   3c01 <posix_halt_cpu>

00000000000035a3 <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
    35a3:	f3 0f 1e fa          	endbr64 
	posix_irq_enable(irq);
    35a7:	e9 8c 10 00 00       	jmpq   4638 <posix_irq_enable>

00000000000035ac <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    35ac:	85 ff                	test   %edi,%edi
    35ae:	74 0e                	je     35be <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    35b0:	48 8d 3d 2f 3c 00 00 	lea    0x3c2f(%rip),%rdi        # 71e6 <__func__.5051+0x1e6>
    35b7:	31 c0                	xor    %eax,%eax
    35b9:	e9 ef 13 00 00       	jmpq   49ad <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    35be:	c3                   	retq   

00000000000035bf <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    35bf:	50                   	push   %rax
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    35c0:	48 8d 3d 19 7b 00 00 	lea    0x7b19(%rip),%rdi        # b0e0 <mtx_threads>
    35c7:	e8 44 ee ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    35cc:	48 8d 35 2d 3c 00 00 	lea    0x3c2d(%rip),%rsi        # 7200 <__func__.5051+0x200>
    35d3:	89 c7                	mov    %eax,%edi
    35d5:	e8 d2 ff ff ff       	callq  35ac <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    35da:	e8 71 ee ff ff       	callq  2450 <pthread_self@plt>
}
    35df:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    35e0:	48 89 c7             	mov    %rax,%rdi
    35e3:	e9 e8 ec ff ff       	jmpq   22d0 <pthread_detach@plt>

00000000000035e8 <abort_tail>:
{
    35e8:	50                   	push   %rax
    35e9:	58                   	pop    %rax
	threads_table[this_th_nbr].running = false;
    35ea:	48 63 ff             	movslq %edi,%rdi
{
    35ed:	50                   	push   %rax
	threads_table[this_th_nbr].running = false;
    35ee:	48 c1 e7 05          	shl    $0x5,%rdi
    35f2:	48 03 3d cf 80 00 00 	add    0x80cf(%rip),%rdi        # b6c8 <threads_table>
    35f9:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
	threads_table[this_th_nbr].state = ABORTED;
    35fd:	c7 07 03 00 00 00    	movl   $0x3,(%rdi)
	posix_preexit_cleanup();
    3603:	e8 b7 ff ff ff       	callq  35bf <posix_preexit_cleanup>
	pthread_exit(NULL);
    3608:	31 ff                	xor    %edi,%edi
    360a:	e8 11 ee ff ff       	callq  2420 <pthread_exit@plt>

000000000000360f <posix_wait_until_allowed>:
{
    360f:	41 54                	push   %r12
	threads_table[this_th_nbr].running = false;
    3611:	48 8b 05 b0 80 00 00 	mov    0x80b0(%rip),%rax        # b6c8 <threads_table>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    3618:	4c 8d 25 c1 7a 00 00 	lea    0x7ac1(%rip),%r12        # b0e0 <mtx_threads>
{
    361f:	55                   	push   %rbp
    3620:	53                   	push   %rbx
    3621:	48 63 df             	movslq %edi,%rbx
    3624:	48 89 dd             	mov    %rbx,%rbp
	threads_table[this_th_nbr].running = false;
    3627:	48 c1 e3 05          	shl    $0x5,%rbx
    362b:	c6 44 18 04 00       	movb   $0x0,0x4(%rax,%rbx,1)
	while (this_th_nbr != currently_allowed_thread) {
    3630:	39 2d 42 81 00 00    	cmp    %ebp,0x8142(%rip)        # b778 <currently_allowed_thread>
    3636:	74 28                	je     3660 <posix_wait_until_allowed+0x51>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    3638:	4c 89 e6             	mov    %r12,%rsi
    363b:	48 8d 3d de 7a 00 00 	lea    0x7ade(%rip),%rdi        # b120 <cond_threads>
    3642:	e8 19 ed ff ff       	callq  2360 <pthread_cond_wait@plt>
		if (threads_table &&
    3647:	48 8b 05 7a 80 00 00 	mov    0x807a(%rip),%rax        # b6c8 <threads_table>
    364e:	48 85 c0             	test   %rax,%rax
    3651:	74 dd                	je     3630 <posix_wait_until_allowed+0x21>
    3653:	83 3c 18 02          	cmpl   $0x2,(%rax,%rbx,1)
    3657:	75 d7                	jne    3630 <posix_wait_until_allowed+0x21>
			abort_tail(this_th_nbr);
    3659:	89 ef                	mov    %ebp,%edi
    365b:	e8 88 ff ff ff       	callq  35e8 <abort_tail>
	threads_table[this_th_nbr].running = true;
    3660:	48 8b 05 61 80 00 00 	mov    0x8061(%rip),%rax        # b6c8 <threads_table>
    3667:	c6 44 18 04 01       	movb   $0x1,0x4(%rax,%rbx,1)
}
    366c:	5b                   	pop    %rbx
    366d:	5d                   	pop    %rbp
    366e:	41 5c                	pop    %r12
    3670:	c3                   	retq   

0000000000003671 <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
    3671:	f3 0f 1e fa          	endbr64 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    3675:	80 3d 31 81 00 00 00 	cmpb   $0x0,0x8131(%rip)        # b7ad <terminate>
    367c:	74 29                	je     36a7 <posix_cleanup_handler+0x36>
{
    367e:	50                   	push   %rax
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    367f:	48 8d 3d 5a 7a 00 00 	lea    0x7a5a(%rip),%rdi        # b0e0 <mtx_threads>
    3686:	e8 85 ed ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    368b:	48 8d 35 6e 3b 00 00 	lea    0x3b6e(%rip),%rsi        # 7200 <__func__.5051+0x200>
    3692:	89 c7                	mov    %eax,%edi
    3694:	e8 13 ff ff ff       	callq  35ac <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    3699:	e8 b2 ed ff ff       	callq  2450 <pthread_self@plt>
}
    369e:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    369f:	48 89 c7             	mov    %rax,%rdi
    36a2:	e9 29 ec ff ff       	jmpq   22d0 <pthread_detach@plt>
    36a7:	c3                   	retq   

00000000000036a8 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    36a8:	f3 0f 1e fa          	endbr64 
    36ac:	50                   	push   %rax
    36ad:	58                   	pop    %rax
    36ae:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    36b5:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    36ba:	48 8d 3d 1f 7a 00 00 	lea    0x7a1f(%rip),%rdi        # b0e0 <mtx_threads>
{
    36c1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    36c8:	00 00 
    36ca:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    36cf:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    36d1:	e8 ea ed ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    36d6:	48 8d 35 46 3b 00 00 	lea    0x3b46(%rip),%rsi        # 7223 <__func__.5051+0x223>
    36dd:	89 c7                	mov    %eax,%edi
    36df:	e8 c8 fe ff ff       	callq  35ac <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    36e4:	48 83 3d dc 7f 00 00 	cmpq   $0x0,0x7fdc(%rip)        # b6c8 <threads_table>
    36eb:	00 
    36ec:	75 11                	jne    36ff <posix_thread_starter+0x57>
		posix_cleanup_handler(arg);
    36ee:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    36f3:	e8 79 ff ff ff       	callq  3671 <posix_cleanup_handler>
		pthread_exit(NULL);
    36f8:	31 ff                	xor    %edi,%edi
    36fa:	e8 21 ed ff ff       	callq  2420 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    36ff:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    3704:	31 f6                	xor    %esi,%esi
    3706:	e8 95 ed ff ff       	callq  24a0 <__sigsetjmp@plt>
    370b:	f3 0f 1e fa          	endbr64 
    370f:	85 c0                	test   %eax,%eax
    3711:	74 14                	je     3727 <posix_thread_starter+0x7f>
    3713:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    3718:	e8 54 ff ff ff       	callq  3671 <posix_cleanup_handler>
    371d:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    3722:	e8 49 ed ff ff       	callq  2470 <__pthread_unwind_next@plt>
    3727:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    372c:	e8 ff eb ff ff       	callq  2330 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    3731:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    3735:	e8 d5 fe ff ff       	callq  360f <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    373a:	e8 ae 03 00 00       	callq  3aed <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    373f:	48 63 44 24 08       	movslq 0x8(%rsp),%rax
    3744:	48 c1 e0 05          	shl    $0x5,%rax
    3748:	48 03 05 79 7f 00 00 	add    0x7f79(%rip),%rax        # b6c8 <threads_table>
    374f:	48 8b 40 18          	mov    0x18(%rax),%rax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    3753:	48 8b 48 18          	mov    0x18(%rax),%rcx
    3757:	48 8b 50 10          	mov    0x10(%rax),%rdx
    375b:	48 8b 70 08          	mov    0x8(%rax),%rsi
    375f:	48 8b 38             	mov    (%rax),%rdi
    3762:	e8 27 f0 ff ff       	callq  278e <z_thread_entry>

0000000000003767 <posix_swap>:
{
    3767:	f3 0f 1e fa          	endbr64 
    376b:	55                   	push   %rbp
    376c:	89 f5                	mov    %esi,%ebp
	currently_allowed_thread = next_allowed_th;
    376e:	89 3d 04 80 00 00    	mov    %edi,0x8004(%rip)        # b778 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    3774:	48 8d 3d a5 79 00 00 	lea    0x79a5(%rip),%rdi        # b120 <cond_threads>
    377b:	e8 70 eb ff ff       	callq  22f0 <pthread_cond_broadcast@plt>
    3780:	48 8d 35 bd 3a 00 00 	lea    0x3abd(%rip),%rsi        # 7244 <__func__.5051+0x244>
    3787:	89 c7                	mov    %eax,%edi
    3789:	e8 1e fe ff ff       	callq  35ac <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    378e:	48 63 c5             	movslq %ebp,%rax
		abort_tail(this_th_nbr);
    3791:	89 ef                	mov    %ebp,%edi
	if (threads_table[this_th_nbr].state == ABORTING) {
    3793:	48 c1 e0 05          	shl    $0x5,%rax
    3797:	48 03 05 2a 7f 00 00 	add    0x7f2a(%rip),%rax        # b6c8 <threads_table>
    379e:	83 38 02             	cmpl   $0x2,(%rax)
    37a1:	75 05                	jne    37a8 <posix_swap+0x41>
		abort_tail(this_th_nbr);
    37a3:	e8 40 fe ff ff       	callq  35e8 <abort_tail>
}
    37a8:	5d                   	pop    %rbp
		posix_wait_until_allowed(this_th_nbr);
    37a9:	e9 61 fe ff ff       	jmpq   360f <posix_wait_until_allowed>

00000000000037ae <posix_main_thread_start>:
{
    37ae:	f3 0f 1e fa          	endbr64 
    37b2:	50                   	push   %rax
	currently_allowed_thread = next_allowed_th;
    37b3:	89 3d bf 7f 00 00    	mov    %edi,0x7fbf(%rip)        # b778 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    37b9:	48 8d 3d 60 79 00 00 	lea    0x7960(%rip),%rdi        # b120 <cond_threads>
    37c0:	e8 2b eb ff ff       	callq  22f0 <pthread_cond_broadcast@plt>
    37c5:	48 8d 35 78 3a 00 00 	lea    0x3a78(%rip),%rsi        # 7244 <__func__.5051+0x244>
    37cc:	89 c7                	mov    %eax,%edi
    37ce:	e8 d9 fd ff ff       	callq  35ac <pc_safe_call>
	posix_preexit_cleanup();
    37d3:	e8 e7 fd ff ff       	callq  35bf <posix_preexit_cleanup>
	pthread_exit(NULL);
    37d8:	31 ff                	xor    %edi,%edi
    37da:	e8 41 ec ff ff       	callq  2420 <pthread_exit@plt>

00000000000037df <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    37df:	f3 0f 1e fa          	endbr64 
    37e3:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    37e4:	8b 35 96 7f 00 00    	mov    0x7f96(%rip),%esi        # b780 <threads_table_size>
{
    37ea:	48 89 fb             	mov    %rdi,%rbx
	for (int i = 0; i < threads_table_size; i++) {
    37ed:	31 c0                	xor    %eax,%eax
		if ((threads_table[i].state == NOTUSED)
    37ef:	48 8b 3d d2 7e 00 00 	mov    0x7ed2(%rip),%rdi        # b6c8 <threads_table>
    37f6:	41 89 c0             	mov    %eax,%r8d
	for (int i = 0; i < threads_table_size; i++) {
    37f9:	39 c6                	cmp    %eax,%esi
    37fb:	7e 13                	jle    3810 <posix_new_thread+0x31>
		if ((threads_table[i].state == NOTUSED)
    37fd:	48 ff c0             	inc    %rax
    3800:	48 89 c2             	mov    %rax,%rdx
    3803:	48 c1 e2 05          	shl    $0x5,%rdx
    3807:	83 7c 17 e0 00       	cmpl   $0x0,-0x20(%rdi,%rdx,1)
    380c:	75 e8                	jne    37f6 <posix_new_thread+0x17>
    380e:	eb 52                	jmp    3862 <posix_new_thread+0x83>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    3810:	83 c6 40             	add    $0x40,%esi
    3813:	48 63 f6             	movslq %esi,%rsi
	threads_table = realloc(threads_table,
    3816:	48 c1 e6 05          	shl    $0x5,%rsi
    381a:	e8 11 ec ff ff       	callq  2430 <realloc@plt>
    381f:	48 89 05 a2 7e 00 00 	mov    %rax,0x7ea2(%rip)        # b6c8 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    3826:	48 85 c0             	test   %rax,%rax
    3829:	75 0c                	jne    3837 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    382b:	48 8d 3d 38 3a 00 00 	lea    0x3a38(%rip),%rdi        # 726a <__func__.5051+0x26a>
    3832:	e8 76 11 00 00       	callq  49ad <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
    3837:	48 63 15 42 7f 00 00 	movslq 0x7f42(%rip),%rdx        # b780 <threads_table_size>
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    383e:	31 c0                	xor    %eax,%eax
    3840:	b9 00 02 00 00       	mov    $0x200,%ecx
    3845:	49 89 d0             	mov    %rdx,%r8
    3848:	48 c1 e2 05          	shl    $0x5,%rdx
    384c:	48 03 15 75 7e 00 00 	add    0x7e75(%rip),%rdx        # b6c8 <threads_table>
    3853:	48 89 d7             	mov    %rdx,%rdi
    3856:	f3 ab                	rep stos %eax,%es:(%rdi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    3858:	41 8d 40 40          	lea    0x40(%r8),%eax
    385c:	89 05 1e 7f 00 00    	mov    %eax,0x7f1e(%rip)        # b780 <threads_table_size>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
    3862:	49 63 c8             	movslq %r8d,%rcx
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3865:	8b 05 11 7f 00 00    	mov    0x7f11(%rip),%eax        # b77c <thread_create_count>
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    386b:	31 f6                	xor    %esi,%esi
	threads_table[t_slot].state = USED;
    386d:	48 89 cf             	mov    %rcx,%rdi
    3870:	48 c1 e7 05          	shl    $0x5,%rdi
    3874:	48 03 3d 4d 7e 00 00 	add    0x7e4d(%rip),%rdi        # b6c8 <threads_table>
	threads_table[t_slot].thead_cnt = thread_create_count++;
    387b:	8d 50 01             	lea    0x1(%rax),%edx
	threads_table[t_slot].t_status = ptr;
    387e:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    3882:	48 83 c7 08          	add    $0x8,%rdi
	threads_table[t_slot].state = USED;
    3886:	c7 47 f8 01 00 00 00 	movl   $0x1,-0x8(%rdi)
	threads_table[t_slot].running = false;
    388d:	c6 47 fc 00          	movb   $0x0,-0x4(%rdi)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3891:	89 47 08             	mov    %eax,0x8(%rdi)
	ptr->thread_idx = t_slot;
    3894:	44 89 43 20          	mov    %r8d,0x20(%rbx)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3898:	89 15 de 7e 00 00    	mov    %edx,0x7ede(%rip)        # b77c <thread_create_count>
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    389e:	48 8d 15 03 fe ff ff 	lea    -0x1fd(%rip),%rdx        # 36a8 <posix_thread_starter>
    38a5:	e8 06 ea ff ff       	callq  22b0 <pthread_create@plt>
    38aa:	48 8d 35 e1 39 00 00 	lea    0x39e1(%rip),%rsi        # 7292 <__func__.5051+0x292>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    38b1:	5b                   	pop    %rbx
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    38b2:	89 c7                	mov    %eax,%edi
    38b4:	e9 f3 fc ff ff       	jmpq   35ac <pc_safe_call>

00000000000038b9 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    38b9:	f3 0f 1e fa          	endbr64 
    38bd:	52                   	push   %rdx
	thread_create_count = 0;

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    38be:	be 20 00 00 00       	mov    $0x20,%esi
    38c3:	bf 40 00 00 00       	mov    $0x40,%edi
	thread_create_count = 0;
    38c8:	c7 05 aa 7e 00 00 00 	movl   $0x0,0x7eaa(%rip)        # b77c <thread_create_count>
    38cf:	00 00 00 
	currently_allowed_thread = -1;
    38d2:	c7 05 9c 7e 00 00 ff 	movl   $0xffffffff,0x7e9c(%rip)        # b778 <currently_allowed_thread>
    38d9:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    38dc:	e8 df ea ff ff       	callq  23c0 <calloc@plt>
    38e1:	48 89 05 e0 7d 00 00 	mov    %rax,0x7de0(%rip)        # b6c8 <threads_table>
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    38e8:	48 85 c0             	test   %rax,%rax
    38eb:	75 0c                	jne    38f9 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    38ed:	48 8d 3d 76 39 00 00 	lea    0x3976(%rip),%rdi        # 726a <__func__.5051+0x26a>
    38f4:	e8 b4 10 00 00       	callq  49ad <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    38f9:	48 8d 3d e0 77 00 00 	lea    0x77e0(%rip),%rdi        # b0e0 <mtx_threads>
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    3900:	c7 05 76 7e 00 00 40 	movl   $0x40,0x7e76(%rip)        # b780 <threads_table_size>
    3907:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    390a:	e8 b1 eb ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    390f:	48 8d 35 0d 39 00 00 	lea    0x390d(%rip),%rsi        # 7223 <__func__.5051+0x223>
    3916:	89 c7                	mov    %eax,%edi
}
    3918:	58                   	pop    %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3919:	e9 8e fc ff ff       	jmpq   35ac <pc_safe_call>

000000000000391e <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
    391e:	f3 0f 1e fa          	endbr64 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    3922:	48 83 3d 9e 7d 00 00 	cmpq   $0x0,0x7d9e(%rip)        # b6c8 <threads_table>
    3929:	00 
    392a:	74 62                	je     398e <posix_core_clean_up+0x70>
{
    392c:	55                   	push   %rbp
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
    392d:	48 8d 2d c2 39 00 00 	lea    0x39c2(%rip),%rbp        # 72f6 <__func__.5051+0x2f6>
{
    3934:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    3935:	31 db                	xor    %ebx,%ebx
{
    3937:	52                   	push   %rdx
	terminate = true;
    3938:	c6 05 6e 7e 00 00 01 	movb   $0x1,0x7e6e(%rip)        # b7ad <terminate>
	for (int i = 0; i < threads_table_size; i++) {
    393f:	39 1d 3b 7e 00 00    	cmp    %ebx,0x7e3b(%rip)        # b780 <threads_table_size>
    3945:	48 8b 3d 7c 7d 00 00 	mov    0x7d7c(%rip),%rdi        # b6c8 <threads_table>
    394c:	7e 2c                	jle    397a <posix_core_clean_up+0x5c>
		if (threads_table[i].state != USED) {
    394e:	48 63 c3             	movslq %ebx,%rax
    3951:	48 c1 e0 05          	shl    $0x5,%rax
    3955:	48 01 c7             	add    %rax,%rdi
    3958:	83 3f 01             	cmpl   $0x1,(%rdi)
    395b:	75 19                	jne    3976 <posix_core_clean_up+0x58>
		if (pthread_cancel(threads_table[i].thread)) {
    395d:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    3961:	e8 9a e9 ff ff       	callq  2300 <pthread_cancel@plt>
    3966:	85 c0                	test   %eax,%eax
    3968:	74 0c                	je     3976 <posix_core_clean_up+0x58>
			posix_print_warning(
    396a:	89 de                	mov    %ebx,%esi
    396c:	48 89 ef             	mov    %rbp,%rdi
    396f:	31 c0                	xor    %eax,%eax
    3971:	e8 10 11 00 00       	callq  4a86 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
    3976:	ff c3                	inc    %ebx
    3978:	eb c5                	jmp    393f <posix_core_clean_up+0x21>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    397a:	e8 21 e9 ff ff       	callq  22a0 <free@plt>
	threads_table = NULL;
    397f:	48 c7 05 3e 7d 00 00 	movq   $0x0,0x7d3e(%rip)        # b6c8 <threads_table>
    3986:	00 00 00 00 
}
    398a:	58                   	pop    %rax
    398b:	5b                   	pop    %rbx
    398c:	5d                   	pop    %rbp
    398d:	c3                   	retq   
    398e:	c3                   	retq   

000000000000398f <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    398f:	f3 0f 1e fa          	endbr64 
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    3993:	48 63 ff             	movslq %edi,%rdi
    3996:	48 c1 e7 05          	shl    $0x5,%rdi
    399a:	48 03 3d 27 7d 00 00 	add    0x7d27(%rip),%rdi        # b6c8 <threads_table>
    39a1:	83 3f 01             	cmpl   $0x1,(%rdi)
    39a4:	75 06                	jne    39ac <posix_abort_thread+0x1d>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    39a6:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    39ac:	c3                   	retq   

00000000000039ad <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    39ad:	f3 0f 1e fa          	endbr64 
    39b1:	41 56                	push   %r14
    39b3:	41 55                	push   %r13
    39b5:	41 54                	push   %r12
    39b7:	49 89 fc             	mov    %rdi,%r12
    39ba:	55                   	push   %rbp
    39bb:	53                   	push   %rbx
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    39bc:	4c 8b 6f 60          	mov    0x60(%rdi),%r13
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    39c0:	49 63 6d 20          	movslq 0x20(%r13),%rbp
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    39c4:	e8 4d 0c 00 00       	callq  4616 <posix_irq_lock>

	key = irq_lock();

	if (_current == thread) {
    39c9:	48 8d 1d 90 7c 00 00 	lea    0x7c90(%rip),%rbx        # b660 <_kernel>
    39d0:	4c 39 63 10          	cmp    %r12,0x10(%rbx)
    39d4:	75 4d                	jne    3a23 <z_impl_k_thread_abort+0x76>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    39d6:	41 83 7d 24 00       	cmpl   $0x0,0x24(%r13)
    39db:	75 0a                	jne    39e7 <z_impl_k_thread_abort+0x3a>
			tstatus->aborted = 1;
    39dd:	41 c7 45 24 01 00 00 	movl   $0x1,0x24(%r13)
    39e4:	00 
    39e5:	eb 10                	jmp    39f7 <z_impl_k_thread_abort+0x4a>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    39e7:	89 ee                	mov    %ebp,%esi
    39e9:	48 8d 3d 3a 39 00 00 	lea    0x393a(%rip),%rdi        # 732a <__func__.5051+0x32a>
    39f0:	31 c0                	xor    %eax,%eax
    39f2:	e8 8f 10 00 00       	callq  4a86 <posix_print_warning>
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    39f7:	48 c1 e5 05          	shl    $0x5,%rbp
    39fb:	48 03 2d c6 7c 00 00 	add    0x7cc6(%rip),%rbp        # b6c8 <threads_table>
			"as aborting\n",
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);

		if (arch_is_in_isr()) {
    3a02:	83 3b 00             	cmpl   $0x0,(%rbx)
		threads_table[thread_idx].state = ABORTING;
    3a05:	c7 45 00 02 00 00 00 	movl   $0x2,0x0(%rbp)
		if (arch_is_in_isr()) {
    3a0c:	74 10                	je     3a1e <z_impl_k_thread_abort+0x71>
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
}
    3a0e:	5b                   	pop    %rbx
			z_thread_single_abort(thread);
    3a0f:	4c 89 e7             	mov    %r12,%rdi
}
    3a12:	5d                   	pop    %rbp
    3a13:	41 5c                	pop    %r12
    3a15:	41 5d                	pop    %r13
    3a17:	41 5e                	pop    %r14
			z_thread_single_abort(thread);
    3a19:	e9 3b 22 00 00       	jmpq   5c59 <z_thread_single_abort>
		z_self_abort();
    3a1e:	e8 24 25 00 00       	callq  5f47 <z_self_abort>
	z_thread_single_abort(thread);
    3a23:	4c 89 e7             	mov    %r12,%rdi
    3a26:	41 89 c6             	mov    %eax,%r14d
    3a29:	e8 2b 22 00 00       	callq  5c59 <z_thread_single_abort>
	if (tstatus->aborted == 0) {
    3a2e:	41 83 7d 24 00       	cmpl   $0x0,0x24(%r13)
    3a33:	75 0f                	jne    3a44 <z_impl_k_thread_abort+0x97>
		tstatus->aborted = 1;
    3a35:	41 c7 45 24 01 00 00 	movl   $0x1,0x24(%r13)
    3a3c:	00 
		posix_abort_thread(thread_idx);
    3a3d:	89 ef                	mov    %ebp,%edi
    3a3f:	e8 4b ff ff ff       	callq  398f <posix_abort_thread>
}
    3a44:	5b                   	pop    %rbx
	z_reschedule_irqlock(key);
    3a45:	44 89 f7             	mov    %r14d,%edi
}
    3a48:	5d                   	pop    %rbp
    3a49:	41 5c                	pop    %r12
    3a4b:	41 5d                	pop    %r13
    3a4d:	41 5e                	pop    %r14
	z_reschedule_irqlock(key);
    3a4f:	e9 ed 1d 00 00       	jmpq   5841 <z_reschedule_irqlock>

0000000000003a54 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <power/power.h>

int arch_swap(unsigned int key)
{
    3a54:	f3 0f 1e fa          	endbr64 
    3a58:	53                   	push   %rbx
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    3a59:	48 8d 1d 00 7c 00 00 	lea    0x7c00(%rip),%rbx        # b660 <_kernel>
    3a60:	48 8b 43 10          	mov    0x10(%rbx),%rax
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    3a64:	48 8b 53 40          	mov    0x40(%rbx),%rdx
	_current->callee_saved.key = key;
    3a68:	89 78 58             	mov    %edi,0x58(%rax)
	posix_thread_status_t *ready_thread_ptr =
    3a6b:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
	_current->callee_saved.retval = -EAGAIN;
    3a6f:	c7 40 5c f5 ff ff ff 	movl   $0xfffffff5,0x5c(%rax)

	posix_thread_status_t *this_thread_ptr  =
    3a76:	48 8b 40 60          	mov    0x60(%rax),%rax
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    3a7a:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    3a7e:	8b 79 20             	mov    0x20(%rcx),%edi
    3a81:	8b 70 20             	mov    0x20(%rax),%esi
    3a84:	e8 de fc ff ff       	callq  3767 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    3a89:	48 8b 43 10          	mov    0x10(%rbx),%rax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    3a8d:	8b 78 58             	mov    0x58(%rax),%edi
    3a90:	e8 8f 0b 00 00       	callq  4624 <posix_irq_unlock>

	return _current->callee_saved.retval;
    3a95:	48 8b 43 10          	mov    0x10(%rbx),%rax
}
    3a99:	5b                   	pop    %rbx
	return _current->callee_saved.retval;
    3a9a:	8b 40 5c             	mov    0x5c(%rax),%eax
}
    3a9d:	c3                   	retq   

0000000000003a9e <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    3a9e:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    3aa2:	48 8d 05 b7 7b 00 00 	lea    0x7bb7(%rip),%rax        # b660 <_kernel>
    3aa9:	48 8b 50 40          	mov    0x40(%rax),%rdx
	posix_thread_status_t *ready_thread_ptr =
    3aad:	48 8b 4a 60          	mov    0x60(%rdx),%rcx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    3ab1:	48 89 50 10          	mov    %rdx,0x10(%rax)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    3ab5:	8b 79 20             	mov    0x20(%rcx),%edi
    3ab8:	e9 f1 fc ff ff       	jmpq   37ae <posix_main_thread_start>

0000000000003abd <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    3abd:	f3 0f 1e fa          	endbr64 

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
    3ac1:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
{
    3ac6:	49 89 fa             	mov    %rdi,%r10
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    3ac9:	48 8d 7a d8          	lea    -0x28(%rdx),%rdi
	thread_status->entry_point = entry;
    3acd:	48 89 4a d8          	mov    %rcx,-0x28(%rdx)
	thread_status->arg1 = p1;
    3ad1:	4c 89 42 e0          	mov    %r8,-0x20(%rdx)
	thread_status->arg2 = p2;
    3ad5:	4c 89 4a e8          	mov    %r9,-0x18(%rdx)
	thread_status->arg3 = p3;
    3ad9:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    3add:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%rdx)
#endif

	thread->callee_saved.thread_status = thread_status;
    3ae4:	49 89 7a 60          	mov    %rdi,0x60(%r10)

	posix_new_thread(thread_status);
    3ae8:	e9 f2 fc ff ff       	jmpq   37df <posix_new_thread>

0000000000003aed <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
    3aed:	f3 0f 1e fa          	endbr64 
	posix_irq_full_unlock();
    3af1:	e9 37 0b 00 00       	jmpq   462d <posix_irq_full_unlock>

0000000000003af6 <pc_safe_call>:
	if (unlikely(test)) {
    3af6:	85 ff                	test   %edi,%edi
    3af8:	74 0e                	je     3b08 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3afa:	48 8d 3d e5 36 00 00 	lea    0x36e5(%rip),%rdi        # 71e6 <__func__.5051+0x1e6>
    3b01:	31 c0                	xor    %eax,%eax
    3b03:	e9 a5 0e 00 00       	jmpq   49ad <posix_print_error_and_exit>
}
    3b08:	c3                   	retq   

0000000000003b09 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    3b09:	f3 0f 1e fa          	endbr64 
    3b0d:	50                   	push   %rax
    3b0e:	58                   	pop    %rax
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3b0f:	48 8d 3d 4a 76 00 00 	lea    0x764a(%rip),%rdi        # b160 <mtx_cpu>
{
    3b16:	50                   	push   %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3b17:	e8 a4 e9 ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    3b1c:	48 8d 35 83 38 00 00 	lea    0x3883(%rip),%rsi        # 73a6 <__func__.5051+0x3a6>
    3b23:	89 c7                	mov    %eax,%edi
    3b25:	e8 cc ff ff ff       	callq  3af6 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3b2a:	48 8d 3d 2f 76 00 00 	lea    0x762f(%rip),%rdi        # b160 <mtx_cpu>
    3b31:	e8 da e8 ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    3b36:	48 8d 35 86 38 00 00 	lea    0x3886(%rip),%rsi        # 73c3 <__func__.5051+0x3c3>
    3b3d:	89 c7                	mov    %eax,%edi
    3b3f:	e8 b2 ff ff ff       	callq  3af6 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    3b44:	e8 70 fd ff ff       	callq  38b9 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    3b49:	e8 fe 1a 00 00       	callq  564c <z_cstart>

0000000000003b4e <posix_is_cpu_running>:
{
    3b4e:	f3 0f 1e fa          	endbr64 
	return !cpu_halted;
    3b52:	8a 05 04 68 00 00    	mov    0x6804(%rip),%al        # a35c <cpu_halted>
    3b58:	83 f0 01             	xor    $0x1,%eax
    3b5b:	0f b6 c0             	movzbl %al,%eax
}
    3b5e:	c3                   	retq   

0000000000003b5f <posix_change_cpu_state_and_wait>:
{
    3b5f:	f3 0f 1e fa          	endbr64 
    3b63:	55                   	push   %rbp
    3b64:	89 fd                	mov    %edi,%ebp
    3b66:	53                   	push   %rbx
    3b67:	89 fb                	mov    %edi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3b69:	48 8d 3d f0 75 00 00 	lea    0x75f0(%rip),%rdi        # b160 <mtx_cpu>
{
    3b70:	52                   	push   %rdx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3b71:	e8 4a e9 ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    3b76:	48 8d 35 29 38 00 00 	lea    0x3829(%rip),%rsi        # 73a6 <__func__.5051+0x3a6>
    3b7d:	89 c7                	mov    %eax,%edi
    3b7f:	e8 72 ff ff ff       	callq  3af6 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3b84:	48 8d 3d 15 76 00 00 	lea    0x7615(%rip),%rdi        # b1a0 <cond_cpu>
	cpu_halted = halted;
    3b8b:	88 1d cb 67 00 00    	mov    %bl,0x67cb(%rip)        # a35c <cpu_halted>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3b91:	48 8d 1d c8 75 00 00 	lea    0x75c8(%rip),%rbx        # b160 <mtx_cpu>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3b98:	e8 53 e7 ff ff       	callq  22f0 <pthread_cond_broadcast@plt>
    3b9d:	48 8d 35 3e 38 00 00 	lea    0x383e(%rip),%rsi        # 73e2 <__func__.5051+0x3e2>
    3ba4:	89 c7                	mov    %eax,%edi
    3ba6:	e8 4b ff ff ff       	callq  3af6 <pc_safe_call>
	while (cpu_halted == halted) {
    3bab:	40 38 2d aa 67 00 00 	cmp    %bpl,0x67aa(%rip)        # a35c <cpu_halted>
    3bb2:	75 11                	jne    3bc5 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3bb4:	48 89 de             	mov    %rbx,%rsi
    3bb7:	48 8d 3d e2 75 00 00 	lea    0x75e2(%rip),%rdi        # b1a0 <cond_cpu>
    3bbe:	e8 9d e7 ff ff       	callq  2360 <pthread_cond_wait@plt>
    3bc3:	eb e6                	jmp    3bab <posix_change_cpu_state_and_wait+0x4c>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3bc5:	48 8d 3d 94 75 00 00 	lea    0x7594(%rip),%rdi        # b160 <mtx_cpu>
    3bcc:	e8 3f e8 ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    3bd1:	48 8d 35 eb 37 00 00 	lea    0x37eb(%rip),%rsi        # 73c3 <__func__.5051+0x3c3>
    3bd8:	89 c7                	mov    %eax,%edi
}
    3bda:	58                   	pop    %rax
    3bdb:	5b                   	pop    %rbx
    3bdc:	5d                   	pop    %rbp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3bdd:	e9 14 ff ff ff       	jmpq   3af6 <pc_safe_call>

0000000000003be2 <posix_interrupt_raised>:
{
    3be2:	f3 0f 1e fa          	endbr64 
    3be6:	51                   	push   %rcx
	posix_change_cpu_state_and_wait(false);
    3be7:	31 ff                	xor    %edi,%edi
    3be9:	e8 71 ff ff ff       	callq  3b5f <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    3bee:	80 3d b9 7b 00 00 00 	cmpb   $0x0,0x7bb9(%rip)        # b7ae <soc_terminate>
    3bf5:	74 08                	je     3bff <posix_interrupt_raised+0x1d>
		posix_exit(0);
    3bf7:	31 ff                	xor    %edi,%edi
}
    3bf9:	5a                   	pop    %rdx
		posix_exit(0);
    3bfa:	e9 b2 0c 00 00       	jmpq   48b1 <posix_exit>
}
    3bff:	58                   	pop    %rax
    3c00:	c3                   	retq   

0000000000003c01 <posix_halt_cpu>:
{
    3c01:	f3 0f 1e fa          	endbr64 
    3c05:	50                   	push   %rax
	posix_change_cpu_state_and_wait(true);
    3c06:	bf 01 00 00 00       	mov    $0x1,%edi
    3c0b:	e8 4f ff ff ff       	callq  3b5f <posix_change_cpu_state_and_wait>
}
    3c10:	5a                   	pop    %rdx
	posix_irq_handler();
    3c11:	e9 c6 08 00 00       	jmpq   44dc <posix_irq_handler>

0000000000003c16 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    3c16:	f3 0f 1e fa          	endbr64 
    3c1a:	53                   	push   %rbx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3c1b:	48 8d 3d 3e 75 00 00 	lea    0x753e(%rip),%rdi        # b160 <mtx_cpu>
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3c22:	48 8d 1d 37 75 00 00 	lea    0x7537(%rip),%rbx        # b160 <mtx_cpu>
{
    3c29:	48 83 ec 10          	sub    $0x10,%rsp
    3c2d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3c34:	00 00 
    3c36:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3c3b:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3c3d:	e8 7e e8 ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    3c42:	48 8d 35 5d 37 00 00 	lea    0x375d(%rip),%rsi        # 73a6 <__func__.5051+0x3a6>
    3c49:	89 c7                	mov    %eax,%edi
    3c4b:	e8 a6 fe ff ff       	callq  3af6 <pc_safe_call>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    3c50:	48 89 e7             	mov    %rsp,%rdi
    3c53:	31 c9                	xor    %ecx,%ecx
    3c55:	31 f6                	xor    %esi,%esi
    3c57:	48 8d 15 ab fe ff ff 	lea    -0x155(%rip),%rdx        # 3b09 <zephyr_wrapper>
	cpu_halted = false;
    3c5e:	c6 05 f7 66 00 00 00 	movb   $0x0,0x66f7(%rip)        # a35c <cpu_halted>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    3c65:	e8 46 e6 ff ff       	callq  22b0 <pthread_create@plt>
    3c6a:	48 8d 35 93 37 00 00 	lea    0x3793(%rip),%rsi        # 7404 <__func__.5051+0x404>
    3c71:	89 c7                	mov    %eax,%edi
    3c73:	e8 7e fe ff ff       	callq  3af6 <pc_safe_call>
	while (cpu_halted == false) {
    3c78:	80 3d dd 66 00 00 00 	cmpb   $0x0,0x66dd(%rip)        # a35c <cpu_halted>
    3c7f:	75 11                	jne    3c92 <posix_boot_cpu+0x7c>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3c81:	48 89 de             	mov    %rbx,%rsi
    3c84:	48 8d 3d 15 75 00 00 	lea    0x7515(%rip),%rdi        # b1a0 <cond_cpu>
    3c8b:	e8 d0 e6 ff ff       	callq  2360 <pthread_cond_wait@plt>
    3c90:	eb e6                	jmp    3c78 <posix_boot_cpu+0x62>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3c92:	48 8d 3d c7 74 00 00 	lea    0x74c7(%rip),%rdi        # b160 <mtx_cpu>
    3c99:	e8 72 e7 ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    3c9e:	48 8d 35 1e 37 00 00 	lea    0x371e(%rip),%rsi        # 73c3 <__func__.5051+0x3c3>
    3ca5:	89 c7                	mov    %eax,%edi
    3ca7:	e8 4a fe ff ff       	callq  3af6 <pc_safe_call>

	if (soc_terminate) {
    3cac:	80 3d fb 7a 00 00 00 	cmpb   $0x0,0x7afb(%rip)        # b7ae <soc_terminate>
    3cb3:	74 07                	je     3cbc <posix_boot_cpu+0xa6>
		posix_exit(0);
    3cb5:	31 ff                	xor    %edi,%edi
    3cb7:	e8 f5 0b 00 00       	callq  48b1 <posix_exit>
	}
}
    3cbc:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    3cc1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3cc8:	00 00 
    3cca:	74 05                	je     3cd1 <posix_boot_cpu+0xbb>
    3ccc:	e8 9f e6 ff ff       	callq  2370 <__stack_chk_fail@plt>
    3cd1:	48 83 c4 10          	add    $0x10,%rsp
    3cd5:	5b                   	pop    %rbx
    3cd6:	c3                   	retq   

0000000000003cd7 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    3cd7:	f3 0f 1e fa          	endbr64 
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    3cdb:	48 8d 05 fe 5e 00 00 	lea    0x5efe(%rip),%rax        # 9be0 <native_pre_tasks.6167>
    3ce2:	48 63 d7             	movslq %edi,%rdx
{
    3ce5:	41 54                	push   %r12
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    3ce7:	ff c7                	inc    %edi
{
    3ce9:	55                   	push   %rbp
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    3cea:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    3cee:	49 89 c4             	mov    %rax,%r12
{
    3cf1:	53                   	push   %rbx
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    3cf2:	48 63 df             	movslq %edi,%rbx
    3cf5:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    3cf9:	76 11                	jbe    3d0c <run_native_tasks+0x35>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    3cfb:	48 8b 45 00          	mov    0x0(%rbp),%rax
    3cff:	48 85 c0             	test   %rax,%rax
    3d02:	74 02                	je     3d06 <run_native_tasks+0x2f>
			(*fptr)();
    3d04:	ff d0                	callq  *%rax
		fptr++) {
    3d06:	48 83 c5 08          	add    $0x8,%rbp
    3d0a:	eb e9                	jmp    3cf5 <run_native_tasks+0x1e>
		}
	}
}
    3d0c:	5b                   	pop    %rbx
    3d0d:	5d                   	pop    %rbp
    3d0e:	41 5c                	pop    %r12
    3d10:	c3                   	retq   

0000000000003d11 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    3d11:	f3 0f 1e fa          	endbr64 
    3d15:	51                   	push   %rcx
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    3d16:	80 3d 3f 66 00 00 00 	cmpb   $0x0,0x663f(%rip)        # a35c <cpu_halted>
    3d1d:	74 10                	je     3d2f <posix_soc_clean_up+0x1e>

		posix_core_clean_up();
    3d1f:	e8 fa fb ff ff       	callq  391e <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    3d24:	bf 04 00 00 00       	mov    $0x4,%edi
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    3d29:	5a                   	pop    %rdx
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    3d2a:	e9 a8 ff ff ff       	jmpq   3cd7 <run_native_tasks>
	} else if (soc_terminate == false) {
    3d2f:	80 3d 78 7a 00 00 00 	cmpb   $0x0,0x7a78(%rip)        # b7ae <soc_terminate>
    3d36:	75 68                	jne    3da0 <posix_soc_clean_up+0x8f>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3d38:	48 8d 3d 21 74 00 00 	lea    0x7421(%rip),%rdi        # b160 <mtx_cpu>
		soc_terminate = true;
    3d3f:	c6 05 68 7a 00 00 01 	movb   $0x1,0x7a68(%rip)        # b7ae <soc_terminate>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3d46:	e8 75 e7 ff ff       	callq  24c0 <pthread_mutex_lock@plt>
    3d4b:	48 8d 35 54 36 00 00 	lea    0x3654(%rip),%rsi        # 73a6 <__func__.5051+0x3a6>
    3d52:	89 c7                	mov    %eax,%edi
    3d54:	e8 9d fd ff ff       	callq  3af6 <pc_safe_call>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3d59:	48 8d 3d 40 74 00 00 	lea    0x7440(%rip),%rdi        # b1a0 <cond_cpu>
		cpu_halted = true;
    3d60:	c6 05 f5 65 00 00 01 	movb   $0x1,0x65f5(%rip)        # a35c <cpu_halted>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3d67:	e8 84 e5 ff ff       	callq  22f0 <pthread_cond_broadcast@plt>
    3d6c:	48 8d 35 6f 36 00 00 	lea    0x366f(%rip),%rsi        # 73e2 <__func__.5051+0x3e2>
    3d73:	89 c7                	mov    %eax,%edi
    3d75:	e8 7c fd ff ff       	callq  3af6 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3d7a:	48 8d 3d df 73 00 00 	lea    0x73df(%rip),%rdi        # b160 <mtx_cpu>
    3d81:	e8 8a e6 ff ff       	callq  2410 <pthread_mutex_unlock@plt>
    3d86:	48 8d 35 36 36 00 00 	lea    0x3636(%rip),%rsi        # 73c3 <__func__.5051+0x3c3>
    3d8d:	89 c7                	mov    %eax,%edi
    3d8f:	e8 62 fd ff ff       	callq  3af6 <pc_safe_call>
			sleep(1);
    3d94:	bf 01 00 00 00       	mov    $0x1,%edi
    3d99:	e8 12 e7 ff ff       	callq  24b0 <sleep@plt>
		while (1) {
    3d9e:	eb f4                	jmp    3d94 <posix_soc_clean_up+0x83>
}
    3da0:	58                   	pop    %rax
    3da1:	c3                   	retq   

0000000000003da2 <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
    3da2:	f3 0f 1e fa          	endbr64 
	signaled_end = 1;
    3da6:	c7 05 d4 79 00 00 01 	movl   $0x1,0x79d4(%rip)        # b784 <signaled_end>
    3dad:	00 00 00 
}
    3db0:	c3                   	retq   

0000000000003db1 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    3db1:	f3 0f 1e fa          	endbr64 
    3db5:	55                   	push   %rbp
    3db6:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    3dbd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3dc4:	00 00 
    3dc6:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    3dcd:	00 
    3dce:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
    3dd0:	48 8d 05 cb ff ff ff 	lea    -0x35(%rip),%rax        # 3da2 <hwm_signal_end_handler>
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    3dd7:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
	act.sa_handler = hwm_signal_end_handler;
    3ddc:	48 89 04 24          	mov    %rax,(%rsp)
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    3de0:	e8 0b e6 ff ff       	callq  23f0 <sigemptyset@plt>
	if (unlikely(test)) {
    3de5:	85 c0                	test   %eax,%eax
    3de7:	74 15                	je     3dfe <hwm_set_sig_handler+0x4d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3de9:	48 8d 35 4f 36 00 00 	lea    0x364f(%rip),%rsi        # 743f <__func__.5051+0x43f>
    3df0:	48 8d 3d ef 33 00 00 	lea    0x33ef(%rip),%rdi        # 71e6 <__func__.5051+0x1e6>
    3df7:	31 c0                	xor    %eax,%eax
    3df9:	e8 af 0b 00 00       	callq  49ad <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    3dfe:	48 89 e5             	mov    %rsp,%rbp
    3e01:	31 d2                	xor    %edx,%edx
    3e03:	bf 0f 00 00 00       	mov    $0xf,%edi
	act.sa_flags = SA_RESETHAND;
    3e08:	c7 84 24 88 00 00 00 	movl   $0x80000000,0x88(%rsp)
    3e0f:	00 00 00 80 
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    3e13:	48 89 ee             	mov    %rbp,%rsi
    3e16:	e8 05 e5 ff ff       	callq  2320 <sigaction@plt>
	if (unlikely(test)) {
    3e1b:	85 c0                	test   %eax,%eax
    3e1d:	74 15                	je     3e34 <hwm_set_sig_handler+0x83>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3e1f:	48 8d 35 33 36 00 00 	lea    0x3633(%rip),%rsi        # 7459 <__func__.5051+0x459>
    3e26:	48 8d 3d b9 33 00 00 	lea    0x33b9(%rip),%rdi        # 71e6 <__func__.5051+0x1e6>
    3e2d:	31 c0                	xor    %eax,%eax
    3e2f:	e8 79 0b 00 00       	callq  49ad <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    3e34:	31 d2                	xor    %edx,%edx
    3e36:	48 89 ee             	mov    %rbp,%rsi
    3e39:	bf 02 00 00 00       	mov    $0x2,%edi
    3e3e:	e8 dd e4 ff ff       	callq  2320 <sigaction@plt>
	if (unlikely(test)) {
    3e43:	85 c0                	test   %eax,%eax
    3e45:	74 15                	je     3e5c <hwm_set_sig_handler+0xab>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3e47:	48 8d 35 2a 36 00 00 	lea    0x362a(%rip),%rsi        # 7478 <__func__.5051+0x478>
    3e4e:	48 8d 3d 91 33 00 00 	lea    0x3391(%rip),%rdi        # 71e6 <__func__.5051+0x1e6>
    3e55:	31 c0                	xor    %eax,%eax
    3e57:	e8 51 0b 00 00       	callq  49ad <posix_print_error_and_exit>
}
    3e5c:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    3e63:	00 
    3e64:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3e6b:	00 00 
    3e6d:	74 05                	je     3e74 <hwm_set_sig_handler+0xc3>
    3e6f:	e8 fc e4 ff ff       	callq  2370 <__stack_chk_fail@plt>
    3e74:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    3e7b:	5d                   	pop    %rbp
    3e7c:	c3                   	retq   

0000000000003e7d <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
    3e7d:	f3 0f 1e fa          	endbr64 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
    3e81:	48 8d 05 90 78 00 00 	lea    0x7890(%rip),%rax        # b718 <hw_timer_timer>
	next_timer_index = 0;
    3e88:	c7 05 be 64 00 00 00 	movl   $0x0,0x64be(%rip)        # a350 <next_timer_index>
    3e8f:	00 00 00 
	next_timer_time  = *Timer_list[0];
    3e92:	48 8b 10             	mov    (%rax),%rdx

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    3e95:	48 8d 05 a4 64 00 00 	lea    0x64a4(%rip),%rax        # a340 <irq_ctrl_timer>
    3e9c:	48 8b 00             	mov    (%rax),%rax
	next_timer_time  = *Timer_list[0];
    3e9f:	48 89 15 2a 78 00 00 	mov    %rdx,0x782a(%rip)        # b6d0 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    3ea6:	48 39 c2             	cmp    %rax,%rdx
    3ea9:	76 11                	jbe    3ebc <hwm_find_next_timer+0x3f>
			next_timer_index = i;
    3eab:	c7 05 9b 64 00 00 01 	movl   $0x1,0x649b(%rip)        # a350 <next_timer_index>
    3eb2:	00 00 00 
			next_timer_time = *Timer_list[i];
    3eb5:	48 89 05 14 78 00 00 	mov    %rax,0x7814(%rip)        # b6d0 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    3ebc:	48 8d 05 a5 78 00 00 	lea    0x78a5(%rip),%rax        # b768 <hw_counter_timer>
    3ec3:	48 8b 00             	mov    (%rax),%rax
    3ec6:	48 3b 05 03 78 00 00 	cmp    0x7803(%rip),%rax        # b6d0 <next_timer_time>
    3ecd:	73 11                	jae    3ee0 <hwm_find_next_timer+0x63>
			next_timer_index = i;
    3ecf:	c7 05 77 64 00 00 02 	movl   $0x2,0x6477(%rip)        # a350 <next_timer_index>
    3ed6:	00 00 00 
			next_timer_time = *Timer_list[i];
    3ed9:	48 89 05 f0 77 00 00 	mov    %rax,0x77f0(%rip)        # b6d0 <next_timer_time>
		}
	}
}
    3ee0:	c3                   	retq   

0000000000003ee1 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    3ee1:	f3 0f 1e fa          	endbr64 
    3ee5:	48 83 ec 18          	sub    $0x18,%rsp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    3ee9:	48 8b 35 e0 77 00 00 	mov    0x77e0(%rip),%rsi        # b6d0 <next_timer_time>
    3ef0:	48 8b 15 e1 77 00 00 	mov    0x77e1(%rip),%rdx        # b6d8 <simu_time>
    3ef7:	48 39 d6             	cmp    %rdx,%rsi
    3efa:	72 09                	jb     3f05 <hwm_main_loop+0x24>
		simu_time = next_timer_time;
    3efc:	48 89 35 d5 77 00 00 	mov    %rsi,0x77d5(%rip)        # b6d8 <simu_time>
    3f03:	eb 14                	jmp    3f19 <hwm_main_loop+0x38>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    3f05:	8b 0d 45 64 00 00    	mov    0x6445(%rip),%ecx        # a350 <next_timer_index>
    3f0b:	48 8d 3d 84 35 00 00 	lea    0x3584(%rip),%rdi        # 7496 <__func__.5051+0x496>
    3f12:	31 c0                	xor    %eax,%eax
    3f14:	e8 6d 0b 00 00       	callq  4a86 <posix_print_warning>
	if (signaled_end || (simu_time > end_of_time)) {
    3f19:	8b 15 65 78 00 00    	mov    0x7865(%rip),%edx        # b784 <signaled_end>
    3f1f:	48 8b 05 b2 77 00 00 	mov    0x77b2(%rip),%rax        # b6d8 <simu_time>
    3f26:	85 d2                	test   %edx,%edx
    3f28:	75 09                	jne    3f33 <hwm_main_loop+0x52>
    3f2a:	48 39 05 ff 63 00 00 	cmp    %rax,0x63ff(%rip)        # a330 <end_of_time>
    3f31:	73 36                	jae    3f69 <hwm_main_loop+0x88>
				((long double)simu_time)/1.0e6);
    3f33:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3f38:	df 6c 24 08          	fildll 0x8(%rsp)
    3f3c:	48 85 c0             	test   %rax,%rax
    3f3f:	79 06                	jns    3f47 <hwm_main_loop+0x66>
    3f41:	d8 05 05 32 00 00    	fadds  0x3205(%rip)        # 714c <__func__.5051+0x14c>
		posix_print_trace("\nStopped at %.3Lfs\n",
    3f47:	d8 35 03 32 00 00    	fdivs  0x3203(%rip)        # 7150 <__func__.5051+0x150>
    3f4d:	50                   	push   %rax
    3f4e:	48 8d 3d 76 35 00 00 	lea    0x3576(%rip),%rdi        # 74cb <__func__.5051+0x4cb>
    3f55:	50                   	push   %rax
    3f56:	31 c0                	xor    %eax,%eax
    3f58:	db 3c 24             	fstpt  (%rsp)
    3f5b:	e8 f5 0b 00 00       	callq  4b55 <posix_print_trace>
    3f60:	5a                   	pop    %rdx
		posix_exit(0);
    3f61:	31 ff                	xor    %edi,%edi
		posix_print_trace("\nStopped at %.3Lfs\n",
    3f63:	59                   	pop    %rcx
		posix_exit(0);
    3f64:	e8 48 09 00 00       	callq  48b1 <posix_exit>
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    3f69:	8b 05 e1 63 00 00    	mov    0x63e1(%rip),%eax        # a350 <next_timer_index>
    3f6f:	83 f8 01             	cmp    $0x1,%eax
    3f72:	74 10                	je     3f84 <hwm_main_loop+0xa3>
    3f74:	83 f8 02             	cmp    $0x2,%eax
    3f77:	74 12                	je     3f8b <hwm_main_loop+0xaa>
    3f79:	85 c0                	test   %eax,%eax
    3f7b:	75 15                	jne    3f92 <hwm_main_loop+0xb1>
		case HWTIMER:
			hwtimer_timer_reached();
    3f7d:	e8 02 03 00 00       	callq  4284 <hwtimer_timer_reached>
			break;
    3f82:	eb 1c                	jmp    3fa0 <hwm_main_loop+0xbf>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    3f84:	e8 11 09 00 00       	callq  489a <hw_irq_ctrl_timer_triggered>
			break;
    3f89:	eb 15                	jmp    3fa0 <hwm_main_loop+0xbf>
		case HW_COUNTER:
			hw_counter_triggered();
    3f8b:	e8 29 16 00 00       	callq  55b9 <hw_counter_triggered>
			break;
    3f90:	eb 0e                	jmp    3fa0 <hwm_main_loop+0xbf>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    3f92:	48 8d 3d 46 35 00 00 	lea    0x3546(%rip),%rdi        # 74df <__func__.5051+0x4df>
    3f99:	31 c0                	xor    %eax,%eax
    3f9b:	e8 0d 0a 00 00       	callq  49ad <posix_print_error_and_exit>
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    3fa0:	e8 d8 fe ff ff       	callq  3e7d <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    3fa5:	e9 3f ff ff ff       	jmpq   3ee9 <hwm_main_loop+0x8>

0000000000003faa <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
    3faa:	f3 0f 1e fa          	endbr64 
	end_of_time = new_end_of_time;
    3fae:	48 89 3d 7b 63 00 00 	mov    %rdi,0x637b(%rip)        # a330 <end_of_time>
}
    3fb5:	c3                   	retq   

0000000000003fb6 <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
    3fb6:	f3 0f 1e fa          	endbr64 
	return simu_time;
}
    3fba:	48 8b 05 17 77 00 00 	mov    0x7717(%rip),%rax        # b6d8 <simu_time>
    3fc1:	c3                   	retq   

0000000000003fc2 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    3fc2:	f3 0f 1e fa          	endbr64 
    3fc6:	50                   	push   %rax
	hwm_set_sig_handler();
    3fc7:	e8 e5 fd ff ff       	callq  3db1 <hwm_set_sig_handler>
	hwtimer_init();
    3fcc:	e8 7e 01 00 00       	callq  414f <hwtimer_init>
	hw_counter_init();
    3fd1:	e8 a8 15 00 00       	callq  557e <hw_counter_init>
	hw_irq_ctrl_init();
    3fd6:	e8 f3 06 00 00       	callq  46ce <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    3fdb:	5a                   	pop    %rdx
	hwm_find_next_timer();
    3fdc:	e9 9c fe ff ff       	jmpq   3e7d <hwm_find_next_timer>

0000000000003fe1 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    3fe1:	f3 0f 1e fa          	endbr64 
    3fe5:	50                   	push   %rax
	hwtimer_cleanup();
    3fe6:	e8 67 02 00 00       	callq  4252 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    3feb:	5a                   	pop    %rdx
	hw_irq_ctrl_cleanup();
    3fec:	e9 1c 07 00 00       	jmpq   470d <hw_irq_ctrl_cleanup>

0000000000003ff1 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    3ff1:	48 8d 15 10 77 00 00 	lea    0x7710(%rip),%rdx        # b708 <hw_timer_awake_timer>
    3ff8:	48 8d 05 11 77 00 00 	lea    0x7711(%rip),%rax        # b710 <hw_timer_tick_timer>
    3fff:	48 8b 00             	mov    (%rax),%rax
    4002:	48 39 02             	cmp    %rax,(%rdx)
    4005:	48 0f 46 02          	cmovbe (%rdx),%rax
    4009:	48 8d 15 08 77 00 00 	lea    0x7708(%rip),%rdx        # b718 <hw_timer_timer>
    4010:	48 89 02             	mov    %rax,(%rdx)
}
    4013:	c3                   	retq   

0000000000004014 <native_add_time_options>:
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}

static void native_add_time_options(void)
{
    4014:	f3 0f 1e fa          	endbr64 
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    4018:	48 8d 3d e1 5f 00 00 	lea    0x5fe1(%rip),%rdi        # a000 <timer_options.3187>
    401f:	e9 e8 13 00 00       	jmpq   540c <native_add_command_line_opts>

0000000000004024 <cmd_stop_at_found>:
{
    4024:	f3 0f 1e fa          	endbr64 
	if (args.stop_at < 0) {
    4028:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    402b:	52                   	push   %rdx
	if (args.stop_at < 0) {
    402c:	66 0f 2f 05 ac 71 00 	comisd 0x71ac(%rip),%xmm0        # b1e0 <args>
    4033:	00 
    4034:	76 11                	jbe    4047 <cmd_stop_at_found+0x23>
    4036:	48 89 fe             	mov    %rdi,%rsi
		posix_print_error_and_exit("Error: stop-at must be positive "
    4039:	31 c0                	xor    %eax,%eax
    403b:	48 8d 3d b9 34 00 00 	lea    0x34b9(%rip),%rdi        # 74fb <__func__.5051+0x4fb>
    4042:	e8 66 09 00 00       	callq  49ad <posix_print_error_and_exit>
	hwm_set_end_of_time(args.stop_at*1e6);
    4047:	f2 0f 10 05 d1 2f 00 	movsd  0x2fd1(%rip),%xmm0        # 7020 <__func__.5051+0x20>
    404e:	00 
    404f:	f2 0f 59 05 89 71 00 	mulsd  0x7189(%rip),%xmm0        # b1e0 <args>
    4056:	00 
    4057:	f2 0f 10 0d c9 2f 00 	movsd  0x2fc9(%rip),%xmm1        # 7028 <__func__.5051+0x28>
    405e:	00 
    405f:	66 0f 2f c1          	comisd %xmm1,%xmm0
    4063:	73 07                	jae    406c <cmd_stop_at_found+0x48>
    4065:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    406a:	eb 0e                	jmp    407a <cmd_stop_at_found+0x56>
    406c:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    4070:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    4075:	48 0f ba ff 3f       	btc    $0x3f,%rdi
}
    407a:	58                   	pop    %rax
	hwm_set_end_of_time(args.stop_at*1e6);
    407b:	e9 2a ff ff ff       	jmpq   3faa <hwm_set_end_of_time>

0000000000004080 <hwtimer_set_real_time_mode>:
{
    4080:	f3 0f 1e fa          	endbr64 
	real_time_mode = new_rt;
    4084:	40 88 3d d2 62 00 00 	mov    %dil,0x62d2(%rip)        # a35d <real_time_mode>
}
    408b:	c3                   	retq   

000000000000408c <cmd_no_realtime_found>:
{
    408c:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(false);
    4090:	31 ff                	xor    %edi,%edi
    4092:	e9 e9 ff ff ff       	jmpq   4080 <hwtimer_set_real_time_mode>

0000000000004097 <cmd_realtime_found>:
{
    4097:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(true);
    409b:	bf 01 00 00 00       	mov    $0x1,%edi
    40a0:	e9 db ff ff ff       	jmpq   4080 <hwtimer_set_real_time_mode>

00000000000040a5 <get_host_us_time>:
{
    40a5:	f3 0f 1e fa          	endbr64 
    40a9:	48 83 ec 28          	sub    $0x28,%rsp
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    40ad:	bf 04 00 00 00       	mov    $0x4,%edi
{
    40b2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    40b9:	00 00 
    40bb:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    40c0:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    40c2:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    40c7:	e8 84 e2 ff ff       	callq  2350 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    40cc:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    40d1:	48 85 d2             	test   %rdx,%rdx
    40d4:	78 07                	js     40dd <get_host_us_time+0x38>
    40d6:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    40db:	eb 15                	jmp    40f2 <get_host_us_time+0x4d>
    40dd:	48 89 d0             	mov    %rdx,%rax
    40e0:	83 e2 01             	and    $0x1,%edx
    40e3:	48 d1 e8             	shr    %rax
    40e6:	48 09 d0             	or     %rdx,%rax
    40e9:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    40ee:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    40f2:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    40f7:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    40fc:	f2 0f 59 05 1c 2f 00 	mulsd  0x2f1c(%rip),%xmm0        # 7020 <__func__.5051+0x20>
    4103:	00 
    4104:	48 99                	cqto   
    4106:	48 f7 f9             	idiv   %rcx
    4109:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    410e:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    4112:	f2 0f 10 0d 0e 2f 00 	movsd  0x2f0e(%rip),%xmm1        # 7028 <__func__.5051+0x28>
    4119:	00 
    411a:	66 0f 2f c1          	comisd %xmm1,%xmm0
    411e:	73 07                	jae    4127 <get_host_us_time+0x82>
    4120:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    4125:	eb 0e                	jmp    4135 <get_host_us_time+0x90>
    4127:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    412b:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    4130:	48 0f ba f8 3f       	btc    $0x3f,%rax
}
    4135:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    413a:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4141:	00 00 
    4143:	74 05                	je     414a <get_host_us_time+0xa5>
    4145:	e8 26 e2 ff ff       	callq  2370 <__stack_chk_fail@plt>
    414a:	48 83 c4 28          	add    $0x28,%rsp
    414e:	c3                   	retq   

000000000000414f <hwtimer_init>:
{
    414f:	f3 0f 1e fa          	endbr64 
    4153:	48 83 ec 28          	sub    $0x28,%rsp
    4157:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    415e:	00 00 
    4160:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4165:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    4167:	48 8d 05 a2 75 00 00 	lea    0x75a2(%rip),%rax        # b710 <hw_timer_tick_timer>
	silent_ticks = 0;
    416e:	48 c7 05 7f 75 00 00 	movq   $0x0,0x757f(%rip)        # b6f8 <silent_ticks>
    4175:	00 00 00 00 
	hw_timer_tick_timer = NEVER;
    4179:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hw_timer_awake_timer = NEVER;
    4180:	48 8d 05 81 75 00 00 	lea    0x7581(%rip),%rax        # b708 <hw_timer_awake_timer>
    4187:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    418e:	e8 5e fe ff ff       	callq  3ff1 <hwtimer_update_timer>
	if (real_time_mode) {
    4193:	80 3d c3 61 00 00 00 	cmpb   $0x0,0x61c3(%rip)        # a35d <real_time_mode>
    419a:	74 17                	je     41b3 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
    419c:	e8 04 ff ff ff       	callq  40a5 <get_host_us_time>
		last_radj_stime = 0U;
    41a1:	48 c7 05 34 75 00 00 	movq   $0x0,0x7534(%rip)        # b6e0 <last_radj_stime>
    41a8:	00 00 00 00 
		last_radj_rtime = boot_time;
    41ac:	48 89 05 35 75 00 00 	mov    %rax,0x7535(%rip)        # b6e8 <last_radj_rtime>
	if (!reset_rtc) {
    41b3:	80 3d f5 75 00 00 00 	cmpb   $0x0,0x75f5(%rip)        # b7af <reset_rtc>
    41ba:	75 7c                	jne    4238 <hwtimer_init+0xe9>
		clock_gettime(CLOCK_REALTIME, &tv);
    41bc:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    41c1:	31 ff                	xor    %edi,%edi
    41c3:	e8 88 e1 ff ff       	callq  2350 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    41c8:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    41cd:	48 85 d2             	test   %rdx,%rdx
    41d0:	78 07                	js     41d9 <hwtimer_init+0x8a>
    41d2:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    41d7:	eb 15                	jmp    41ee <hwtimer_init+0x9f>
    41d9:	48 89 d0             	mov    %rdx,%rax
    41dc:	83 e2 01             	and    $0x1,%edx
    41df:	48 d1 e8             	shr    %rax
    41e2:	48 09 d0             	or     %rdx,%rax
    41e5:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    41ea:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    41ee:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    41f3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    41f8:	f2 0f 59 05 20 2e 00 	mulsd  0x2e20(%rip),%xmm0        # 7020 <__func__.5051+0x20>
    41ff:	00 
    4200:	48 99                	cqto   
    4202:	48 f7 f9             	idiv   %rcx
    4205:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    420a:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    420e:	f2 0f 10 0d 12 2e 00 	movsd  0x2e12(%rip),%xmm1        # 7028 <__func__.5051+0x28>
    4215:	00 
    4216:	66 0f 2f c1          	comisd %xmm1,%xmm0
    421a:	73 07                	jae    4223 <hwtimer_init+0xd4>
    421c:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    4221:	eb 0e                	jmp    4231 <hwtimer_init+0xe2>
    4223:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    4227:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    422c:	48 0f ba f8 3f       	btc    $0x3f,%rax
		rtc_offset += realhosttime;
    4231:	48 01 05 b8 74 00 00 	add    %rax,0x74b8(%rip)        # b6f0 <rtc_offset>
}
    4238:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    423d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4244:	00 00 
    4246:	74 05                	je     424d <hwtimer_init+0xfe>
    4248:	e8 23 e1 ff ff       	callq  2370 <__stack_chk_fail@plt>
    424d:	48 83 c4 28          	add    $0x28,%rsp
    4251:	c3                   	retq   

0000000000004252 <hwtimer_cleanup>:
{
    4252:	f3 0f 1e fa          	endbr64 
}
    4256:	c3                   	retq   

0000000000004257 <hwtimer_enable>:
{
    4257:	f3 0f 1e fa          	endbr64 
    425b:	50                   	push   %rax
	tick_p = period;
    425c:	48 89 3d 9d 74 00 00 	mov    %rdi,0x749d(%rip)        # b700 <tick_p>
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    4263:	e8 4e fd ff ff       	callq  3fb6 <hwm_get_time>
    4268:	48 8d 15 a1 74 00 00 	lea    0x74a1(%rip),%rdx        # b710 <hw_timer_tick_timer>
    426f:	48 03 05 8a 74 00 00 	add    0x748a(%rip),%rax        # b700 <tick_p>
    4276:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    4279:	e8 73 fd ff ff       	callq  3ff1 <hwtimer_update_timer>
}
    427e:	5a                   	pop    %rdx
	hwm_find_next_timer();
    427f:	e9 f9 fb ff ff       	jmpq   3e7d <hwm_find_next_timer>

0000000000004284 <hwtimer_timer_reached>:
{
    4284:	f3 0f 1e fa          	endbr64 
    4288:	55                   	push   %rbp
    4289:	53                   	push   %rbx
    428a:	48 83 ec 38          	sub    $0x38,%rsp
    428e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4295:	00 00 
    4297:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    429c:	31 c0                	xor    %eax,%eax
	uint64_t Now = hw_timer_timer;
    429e:	48 8d 05 73 74 00 00 	lea    0x7473(%rip),%rax        # b718 <hw_timer_timer>
    42a5:	48 8b 18             	mov    (%rax),%rbx
	if (hw_timer_awake_timer == Now) {
    42a8:	48 8d 05 59 74 00 00 	lea    0x7459(%rip),%rax        # b708 <hw_timer_awake_timer>
    42af:	48 39 18             	cmp    %rbx,(%rax)
    42b2:	75 16                	jne    42ca <hwtimer_timer_reached+0x46>
	hw_timer_awake_timer = NEVER;
    42b4:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    42bb:	e8 31 fd ff ff       	callq  3ff1 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    42c0:	bf ff ff 00 00       	mov    $0xffff,%edi
    42c5:	e8 5a 05 00 00       	callq  4824 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
    42ca:	48 8d 2d 3f 74 00 00 	lea    0x743f(%rip),%rbp        # b710 <hw_timer_tick_timer>
    42d1:	48 39 5d 00          	cmp    %rbx,0x0(%rbp)
    42d5:	0f 85 12 01 00 00    	jne    43ed <hwtimer_timer_reached+0x169>
	if (real_time_mode) {
    42db:	80 3d 7b 60 00 00 00 	cmpb   $0x0,0x607b(%rip)        # a35d <real_time_mode>
    42e2:	0f 84 d6 00 00 00    	je     43be <hwtimer_timer_reached+0x13a>
				    / clock_ratio
    42e8:	48 2b 1d f1 73 00 00 	sub    0x73f1(%rip),%rbx        # b6e0 <last_radj_stime>
    42ef:	78 07                	js     42f8 <hwtimer_timer_reached+0x74>
    42f1:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    42f6:	eb 15                	jmp    430d <hwtimer_timer_reached+0x89>
    42f8:	48 89 d8             	mov    %rbx,%rax
    42fb:	83 e3 01             	and    $0x1,%ebx
    42fe:	48 d1 e8             	shr    %rax
    4301:	48 09 d8             	or     %rbx,%rax
    4304:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    4309:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
				    + last_radj_rtime;
    430d:	48 8b 15 d4 73 00 00 	mov    0x73d4(%rip),%rdx        # b6e8 <last_radj_rtime>
				    / clock_ratio
    4314:	f2 0f 5e 05 1c 60 00 	divsd  0x601c(%rip),%xmm0        # a338 <clock_ratio>
    431b:	00 
				    + last_radj_rtime;
    431c:	48 85 d2             	test   %rdx,%rdx
    431f:	78 07                	js     4328 <hwtimer_timer_reached+0xa4>
    4321:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
    4326:	eb 15                	jmp    433d <hwtimer_timer_reached+0xb9>
    4328:	48 89 d0             	mov    %rdx,%rax
    432b:	83 e2 01             	and    $0x1,%edx
    432e:	48 d1 e8             	shr    %rax
    4331:	48 09 d0             	or     %rdx,%rax
    4334:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    4339:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
    433d:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    4341:	f2 0f 10 0d df 2c 00 	movsd  0x2cdf(%rip),%xmm1        # 7028 <__func__.5051+0x28>
    4348:	00 
    4349:	66 0f 2f c1          	comisd %xmm1,%xmm0
    434d:	73 07                	jae    4356 <hwtimer_timer_reached+0xd2>
    434f:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    4354:	eb 0e                	jmp    4364 <hwtimer_timer_reached+0xe0>
    4356:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    435a:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    435f:	48 0f ba fb 3f       	btc    $0x3f,%rbx
		uint64_t real_time = get_host_us_time();
    4364:	e8 3c fd ff ff       	callq  40a5 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    4369:	48 29 c3             	sub    %rax,%rbx
		if (diff > 0) { /* we need to slow down */
    436c:	48 85 db             	test   %rbx,%rbx
    436f:	7e 4d                	jle    43be <hwtimer_timer_reached+0x13a>
			requested_time.tv_sec  = diff / 1e6;
    4371:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    4376:	f2 0f 10 1d a2 2c 00 	movsd  0x2ca2(%rip),%xmm3        # 7020 <__func__.5051+0x20>
    437d:	00 
			(void) nanosleep(&requested_time, &remaining);
    437e:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    4383:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
			requested_time.tv_sec  = diff / 1e6;
    4388:	66 0f 28 d0          	movapd %xmm0,%xmm2
    438c:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
    4390:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
						 requested_time.tv_sec*1e6)*1e3;
    4395:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
			requested_time.tv_sec  = diff / 1e6;
    439a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
						 requested_time.tv_sec*1e6)*1e3;
    439f:	f2 0f 59 cb          	mulsd  %xmm3,%xmm1
			requested_time.tv_nsec = (diff -
    43a3:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
						 requested_time.tv_sec*1e6)*1e3;
    43a7:	f2 0f 59 05 81 2c 00 	mulsd  0x2c81(%rip),%xmm0        # 7030 <__func__.5051+0x30>
    43ae:	00 
			requested_time.tv_nsec = (diff -
    43af:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    43b4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			(void) nanosleep(&requested_time, &remaining);
    43b9:	e8 d2 df ff ff       	callq  2390 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
    43be:	48 8b 05 3b 73 00 00 	mov    0x733b(%rip),%rax        # b700 <tick_p>
    43c5:	48 01 45 00          	add    %rax,0x0(%rbp)
	hwtimer_update_timer();
    43c9:	e8 23 fc ff ff       	callq  3ff1 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    43ce:	48 8b 05 23 73 00 00 	mov    0x7323(%rip),%rax        # b6f8 <silent_ticks>
    43d5:	48 85 c0             	test   %rax,%rax
    43d8:	7e 0c                	jle    43e6 <hwtimer_timer_reached+0x162>
		silent_ticks -= 1;
    43da:	48 ff c8             	dec    %rax
    43dd:	48 89 05 14 73 00 00 	mov    %rax,0x7314(%rip)        # b6f8 <silent_ticks>
    43e4:	eb 07                	jmp    43ed <hwtimer_timer_reached+0x169>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    43e6:	31 ff                	xor    %edi,%edi
    43e8:	e8 37 04 00 00       	callq  4824 <hw_irq_ctrl_set_irq>
}
    43ed:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    43f2:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    43f9:	00 00 
    43fb:	74 05                	je     4402 <hwtimer_timer_reached+0x17e>
    43fd:	e8 6e df ff ff       	callq  2370 <__stack_chk_fail@plt>
    4402:	48 83 c4 38          	add    $0x38,%rsp
    4406:	5b                   	pop    %rbx
    4407:	5d                   	pop    %rbp
    4408:	c3                   	retq   

0000000000004409 <hwtimer_set_silent_ticks>:
{
    4409:	f3 0f 1e fa          	endbr64 
	silent_ticks = sys_ticks;
    440d:	48 89 3d e4 72 00 00 	mov    %rdi,0x72e4(%rip)        # b6f8 <silent_ticks>
}
    4414:	c3                   	retq   

0000000000004415 <hwtimer_reset_rtc>:
{
    4415:	f3 0f 1e fa          	endbr64 
	reset_rtc = true;
    4419:	c6 05 8f 73 00 00 01 	movb   $0x1,0x738f(%rip)        # b7af <reset_rtc>
}
    4420:	c3                   	retq   

0000000000004421 <cmd_rtcreset_found>:
{
    4421:	f3 0f 1e fa          	endbr64 
	hwtimer_reset_rtc();
    4425:	e9 eb ff ff ff       	jmpq   4415 <hwtimer_reset_rtc>

000000000000442a <hwtimer_set_rtc_offset>:
{
    442a:	f3 0f 1e fa          	endbr64 
	rtc_offset = offset;
    442e:	48 89 3d bb 72 00 00 	mov    %rdi,0x72bb(%rip)        # b6f0 <rtc_offset>
}
    4435:	c3                   	retq   

0000000000004436 <cmd_rtcoffset_found>:
{
    4436:	f3 0f 1e fa          	endbr64 
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    443a:	f2 0f 10 05 de 2b 00 	movsd  0x2bde(%rip),%xmm0        # 7020 <__func__.5051+0x20>
    4441:	00 
    4442:	f2 0f 59 05 9e 6d 00 	mulsd  0x6d9e(%rip),%xmm0        # b1e8 <args+0x8>
    4449:	00 
    444a:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    444f:	e9 d6 ff ff ff       	jmpq   442a <hwtimer_set_rtc_offset>

0000000000004454 <hwtimer_set_rt_ratio>:
{
    4454:	f3 0f 1e fa          	endbr64 
	clock_ratio = ratio;
    4458:	f2 0f 11 05 d8 5e 00 	movsd  %xmm0,0x5ed8(%rip)        # a338 <clock_ratio>
    445f:	00 
}
    4460:	c3                   	retq   

0000000000004461 <cmd_rt_ratio_found>:
{
    4461:	f3 0f 1e fa          	endbr64 
	if ((args.rt_ratio <= 0)) {
    4465:	0f 57 c0             	xorps  %xmm0,%xmm0
    4468:	66 0f 2f 05 88 6d 00 	comisd 0x6d88(%rip),%xmm0        # b1f8 <args+0x18>
    446f:	00 
    4470:	72 1a                	jb     448c <cmd_rt_ratio_found+0x2b>
{
    4472:	50                   	push   %rax
		posix_print_error_and_exit("The ratio needs to be > 0. "
    4473:	48 8d 3d a7 30 00 00 	lea    0x30a7(%rip),%rdi        # 7521 <__func__.5051+0x521>
    447a:	31 c0                	xor    %eax,%eax
    447c:	e8 2c 05 00 00       	callq  49ad <posix_print_error_and_exit>
	hwtimer_set_rt_ratio(args.rt_ratio);
    4481:	f2 0f 10 05 6f 6d 00 	movsd  0x6d6f(%rip),%xmm0        # b1f8 <args+0x18>
    4488:	00 
}
    4489:	5a                   	pop    %rdx
    448a:	eb 08                	jmp    4494 <cmd_rt_ratio_found+0x33>
	hwtimer_set_rt_ratio(args.rt_ratio);
    448c:	f2 0f 10 05 64 6d 00 	movsd  0x6d64(%rip),%xmm0        # b1f8 <args+0x18>
    4493:	00 
    4494:	e9 bb ff ff ff       	jmpq   4454 <hwtimer_set_rt_ratio>

0000000000004499 <cmd_rt_drift_found>:
{
    4499:	f3 0f 1e fa          	endbr64 
    449d:	52                   	push   %rdx
	if (!(args.rt_drift > -1)) {
    449e:	f2 0f 10 05 4a 6d 00 	movsd  0x6d4a(%rip),%xmm0        # b1f0 <args+0x10>
    44a5:	00 
    44a6:	66 0f 2f 05 8a 2b 00 	comisd 0x2b8a(%rip),%xmm0        # 7038 <__func__.5051+0x38>
    44ad:	00 
    44ae:	77 0e                	ja     44be <cmd_rt_drift_found+0x25>
		posix_print_error_and_exit("The drift needs to be > -1. "
    44b0:	48 8d 3d a6 30 00 00 	lea    0x30a6(%rip),%rdi        # 755d <__func__.5051+0x55d>
    44b7:	31 c0                	xor    %eax,%eax
    44b9:	e8 ef 04 00 00       	callq  49ad <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
    44be:	f2 0f 10 05 7a 2b 00 	movsd  0x2b7a(%rip),%xmm0        # 7040 <__func__.5051+0x40>
    44c5:	00 
    44c6:	f2 0f 58 05 22 6d 00 	addsd  0x6d22(%rip),%xmm0        # b1f0 <args+0x10>
    44cd:	00 
    44ce:	f2 0f 11 05 22 6d 00 	movsd  %xmm0,0x6d22(%rip)        # b1f8 <args+0x18>
    44d5:	00 
}
    44d6:	58                   	pop    %rax
	hwtimer_set_rt_ratio(args.rt_ratio);
    44d7:	e9 78 ff ff ff       	jmpq   4454 <hwtimer_set_rt_ratio>

00000000000044dc <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    44dc:	f3 0f 1e fa          	endbr64 
    44e0:	41 56                	push   %r14
    44e2:	41 55                	push   %r13
    44e4:	41 54                	push   %r12
    44e6:	55                   	push   %rbp
    44e7:	53                   	push   %rbx
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    44e8:	e8 5e 02 00 00       	callq  474b <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    44ed:	85 c0                	test   %eax,%eax
    44ef:	0f 85 e6 00 00 00    	jne    45db <posix_irq_handler+0xff>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    44f5:	48 8d 1d 64 71 00 00 	lea    0x7164(%rip),%rbx        # b660 <_kernel>
    44fc:	8b 03                	mov    (%rbx),%eax
    44fe:	85 c0                	test   %eax,%eax
    4500:	75 0a                	jne    450c <posix_irq_handler+0x30>
		may_swap = 0;
    4502:	c7 05 7c 72 00 00 00 	movl   $0x0,0x727c(%rip)        # b788 <may_swap.5042>
    4509:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    450c:	ff c0                	inc    %eax
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    450e:	4c 8d 2d eb 6c 00 00 	lea    0x6ceb(%rip),%r13        # b200 <irq_vector_table>
	_kernel.cpus[0].nested++;
    4515:	89 03                	mov    %eax,(%rbx)

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    4517:	e8 7a 02 00 00       	callq  4796 <hw_irq_ctrl_get_highest_prio_irq>
    451c:	89 c5                	mov    %eax,%ebp
    451e:	83 f8 ff             	cmp    $0xffffffff,%eax
    4521:	0f 84 84 00 00 00    	je     45ab <posix_irq_handler+0xcf>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    4527:	e8 f1 01 00 00       	callq  471d <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    452c:	89 ef                	mov    %ebp,%edi
		int last_running_irq = currently_running_irq;
    452e:	44 8b 35 1f 5e 00 00 	mov    0x5e1f(%rip),%r14d        # a354 <currently_running_irq>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    4535:	41 89 c4             	mov    %eax,%r12d
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    4538:	e8 fd 01 00 00       	callq  473a <hw_irq_ctrl_get_prio>
    453d:	0f b6 f8             	movzbl %al,%edi
    4540:	e8 cd 01 00 00       	callq  4712 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    4545:	89 ef                	mov    %ebp,%edi
    4547:	e8 b9 02 00 00       	callq  4805 <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    454c:	48 63 c5             	movslq %ebp,%rax

		currently_running_irq = irq_nbr;
    454f:	89 2d ff 5d 00 00    	mov    %ebp,0x5dff(%rip)        # a354 <currently_running_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    4555:	48 6b c0 18          	imul   $0x18,%rax,%rax
    4559:	4c 01 e8             	add    %r13,%rax
    455c:	48 8b 50 08          	mov    0x8(%rax),%rdx
    4560:	48 85 d2             	test   %rdx,%rdx
    4563:	75 12                	jne    4577 <posix_irq_handler+0x9b>
		posix_print_error_and_exit("Received irq %i without a "
    4565:	89 ee                	mov    %ebp,%esi
    4567:	48 8d 3d 05 34 00 00 	lea    0x3405(%rip),%rdi        # 7973 <__func__.5051+0x973>
    456e:	31 c0                	xor    %eax,%eax
    4570:	e8 38 04 00 00       	callq  49ad <posix_print_error_and_exit>
    4575:	eb 20                	jmp    4597 <posix_irq_handler+0xbb>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    4577:	f6 40 04 01          	testb  $0x1,0x4(%rax)
    457b:	74 0a                	je     4587 <posix_irq_handler+0xab>
			*may_swap |= ((direct_irq_f_ptr)
    457d:	ff d2                	callq  *%rdx
    457f:	09 05 03 72 00 00    	or     %eax,0x7203(%rip)        # b788 <may_swap.5042>
    4585:	eb 10                	jmp    4597 <posix_irq_handler+0xbb>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    4587:	48 8b 78 10          	mov    0x10(%rax),%rdi
    458b:	ff d2                	callq  *%rdx
			*may_swap = 1;
    458d:	c7 05 f1 71 00 00 01 	movl   $0x1,0x71f1(%rip)        # b788 <may_swap.5042>
    4594:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    4597:	44 89 e7             	mov    %r12d,%edi
		currently_running_irq = last_running_irq;
    459a:	44 89 35 b3 5d 00 00 	mov    %r14d,0x5db3(%rip)        # a354 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    45a1:	e8 6c 01 00 00       	callq  4712 <hw_irq_ctrl_set_cur_prio>
    45a6:	e9 6c ff ff ff       	jmpq   4517 <posix_irq_handler+0x3b>
	}

	_kernel.cpus[0].nested--;
    45ab:	ff 0b                	decl   (%rbx)
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    45ad:	83 3d d4 71 00 00 00 	cmpl   $0x0,0x71d4(%rip)        # b788 <may_swap.5042>
    45b4:	74 25                	je     45db <posix_irq_handler+0xff>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    45b6:	e8 62 01 00 00       	callq  471d <hw_irq_ctrl_get_cur_prio>
    45bb:	3d 00 01 00 00       	cmp    $0x100,%eax
    45c0:	75 19                	jne    45db <posix_irq_handler+0xff>
		&& (_kernel.ready_q.cache != _current)) {
    45c2:	48 8b 43 10          	mov    0x10(%rbx),%rax
    45c6:	48 39 43 40          	cmp    %rax,0x40(%rbx)
    45ca:	74 0f                	je     45db <posix_irq_handler+0xff>

		(void)z_swap_irqlock(irq_lock);
	}
}
    45cc:	5b                   	pop    %rbx

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    45cd:	31 ff                	xor    %edi,%edi
    45cf:	5d                   	pop    %rbp
    45d0:	41 5c                	pop    %r12
    45d2:	41 5d                	pop    %r13
    45d4:	41 5e                	pop    %r14
    45d6:	e9 79 f4 ff ff       	jmpq   3a54 <arch_swap>
    45db:	5b                   	pop    %rbx
    45dc:	5d                   	pop    %rbp
    45dd:	41 5c                	pop    %r12
    45df:	41 5d                	pop    %r13
    45e1:	41 5e                	pop    %r14
    45e3:	c3                   	retq   

00000000000045e4 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    45e4:	f3 0f 1e fa          	endbr64 
    45e8:	51                   	push   %rcx
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    45e9:	e8 a8 01 00 00       	callq  4796 <hw_irq_ctrl_get_highest_prio_irq>
    45ee:	ff c0                	inc    %eax
    45f0:	74 22                	je     4614 <posix_irq_handler_im_from_sw+0x30>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    45f2:	e8 57 f5 ff ff       	callq  3b4e <posix_is_cpu_running>
    45f7:	85 c0                	test   %eax,%eax
    45f9:	75 13                	jne    460e <posix_irq_handler_im_from_sw+0x2a>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    45fb:	48 8d 35 fe 29 00 00 	lea    0x29fe(%rip),%rsi        # 7000 <__func__.5051>
    4602:	48 8d 3d 98 33 00 00 	lea    0x3398(%rip),%rdi        # 79a1 <__func__.5051+0x9a1>
    4609:	e8 9f 03 00 00       	callq  49ad <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    460e:	5a                   	pop    %rdx
		posix_irq_handler();
    460f:	e9 c8 fe ff ff       	jmpq   44dc <posix_irq_handler>
}
    4614:	58                   	pop    %rax
    4615:	c3                   	retq   

0000000000004616 <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    4616:	f3 0f 1e fa          	endbr64 
	return hw_irq_ctrl_change_lock(true);
    461a:	bf 01 00 00 00       	mov    $0x1,%edi
    461f:	e9 33 01 00 00       	jmpq   4757 <hw_irq_ctrl_change_lock>

0000000000004624 <posix_irq_unlock>:
 *
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
    4624:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(key);
    4628:	e9 2a 01 00 00       	jmpq   4757 <hw_irq_ctrl_change_lock>

000000000000462d <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
    462d:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(false);
    4631:	31 ff                	xor    %edi,%edi
    4633:	e9 1f 01 00 00       	jmpq   4757 <hw_irq_ctrl_change_lock>

0000000000004638 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
    4638:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_enable_irq(irq);
    463c:	e9 31 02 00 00       	jmpq   4872 <hw_irq_ctrl_enable_irq>

0000000000004641 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
    4641:	f3 0f 1e fa          	endbr64 
	irq_vector_table[irq_p].irq   = irq_p;
    4645:	89 f8                	mov    %edi,%eax
{
    4647:	49 89 d0             	mov    %rdx,%r8
	irq_vector_table[irq_p].irq   = irq_p;
    464a:	48 6b d0 18          	imul   $0x18,%rax,%rdx
    464e:	48 8d 05 ab 6b 00 00 	lea    0x6bab(%rip),%rax        # b200 <irq_vector_table>
    4655:	48 01 d0             	add    %rdx,%rax
    4658:	89 38                	mov    %edi,(%rax)
	irq_vector_table[irq_p].func  = isr_p;
    465a:	4c 89 40 08          	mov    %r8,0x8(%rax)
	irq_vector_table[irq_p].param = isr_param_p;
    465e:	48 89 48 10          	mov    %rcx,0x10(%rax)
	irq_vector_table[irq_p].flags = flags;
    4662:	89 70 04             	mov    %esi,0x4(%rax)
}
    4665:	c3                   	retq   

0000000000004666 <posix_irq_priority_set>:
 * Lower values take priority over higher values.
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    4666:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_prio_set(irq, prio);
    466a:	e9 b9 00 00 00       	jmpq   4728 <hw_irq_ctrl_prio_set>

000000000000466f <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    466f:	80 3d 3b 71 00 00 00 	cmpb   $0x0,0x713b(%rip)        # b7b1 <irqs_locked>
    4676:	74 09                	je     4681 <irq_raising_from_hw_now+0x12>
    4678:	80 3d 31 71 00 00 00 	cmpb   $0x0,0x7131(%rip)        # b7b0 <lock_ignore>
    467f:	74 0c                	je     468d <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    4681:	c6 05 28 71 00 00 00 	movb   $0x0,0x7128(%rip)        # b7b0 <lock_ignore>
		posix_interrupt_raised();
    4688:	e9 55 f5 ff ff       	jmpq   3be2 <posix_interrupt_raised>
	}
}
    468d:	c3                   	retq   

000000000000468e <hw_irq_ctrl_irq_raise_prefix>:
{
    468e:	89 f9                	mov    %edi,%ecx
	if (irq < N_IRQS) {
    4690:	83 ff 1f             	cmp    $0x1f,%edi
    4693:	77 29                	ja     46be <hw_irq_ctrl_irq_raise_prefix+0x30>
		if (irq_mask & (1 << irq)) {
    4695:	b8 01 00 00 00       	mov    $0x1,%eax
		irq_premask |= ((uint64_t)1<<irq);
    469a:	ba 01 00 00 00       	mov    $0x1,%edx
		if (irq_mask & (1 << irq)) {
    469f:	d3 e0                	shl    %cl,%eax
		irq_premask |= ((uint64_t)1<<irq);
    46a1:	48 d3 e2             	shl    %cl,%rdx
    46a4:	48 09 15 7d 70 00 00 	or     %rdx,0x707d(%rip)        # b728 <irq_premask>
		if (irq_mask & (1 << irq)) {
    46ab:	48 98                	cltq   
    46ad:	48 85 05 6c 70 00 00 	test   %rax,0x706c(%rip)        # b720 <irq_mask>
    46b4:	74 17                	je     46cd <hw_irq_ctrl_irq_raise_prefix+0x3f>
			irq_status |= ((uint64_t)1<<irq);
    46b6:	48 09 15 73 70 00 00 	or     %rdx,0x7073(%rip)        # b730 <irq_status>
    46bd:	c3                   	retq   
	} else if (irq == PHONY_HARD_IRQ) {
    46be:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
    46c4:	75 07                	jne    46cd <hw_irq_ctrl_irq_raise_prefix+0x3f>
		lock_ignore = true;
    46c6:	c6 05 e3 70 00 00 01 	movb   $0x1,0x70e3(%rip)        # b7b0 <lock_ignore>
}
    46cd:	c3                   	retq   

00000000000046ce <hw_irq_ctrl_init>:
{
    46ce:	f3 0f 1e fa          	endbr64 
	irqs_locked = false;
    46d2:	c6 05 d8 70 00 00 00 	movb   $0x0,0x70d8(%rip)        # b7b1 <irqs_locked>
    46d9:	48 8d 05 20 6e 00 00 	lea    0x6e20(%rip),%rax        # b500 <irq_prio>
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    46e0:	48 c7 05 35 70 00 00 	movq   $0x0,0x7035(%rip)        # b720 <irq_mask>
    46e7:	00 00 00 00 
	irq_premask = 0U;
    46eb:	48 8d 50 20          	lea    0x20(%rax),%rdx
    46ef:	48 c7 05 2e 70 00 00 	movq   $0x0,0x702e(%rip)        # b728 <irq_premask>
    46f6:	00 00 00 00 
	lock_ignore = false;
    46fa:	c6 05 af 70 00 00 00 	movb   $0x0,0x70af(%rip)        # b7b0 <lock_ignore>
		irq_prio[i] = 255U;
    4701:	c6 00 ff             	movb   $0xff,(%rax)
	for (int i = 0 ; i < N_IRQS; i++) {
    4704:	48 ff c0             	inc    %rax
    4707:	48 39 d0             	cmp    %rdx,%rax
    470a:	75 f5                	jne    4701 <hw_irq_ctrl_init+0x33>
}
    470c:	c3                   	retq   

000000000000470d <hw_irq_ctrl_cleanup>:
{
    470d:	f3 0f 1e fa          	endbr64 
}
    4711:	c3                   	retq   

0000000000004712 <hw_irq_ctrl_set_cur_prio>:
{
    4712:	f3 0f 1e fa          	endbr64 
	currently_running_prio = new;
    4716:	89 3d 3c 5c 00 00    	mov    %edi,0x5c3c(%rip)        # a358 <currently_running_prio>
}
    471c:	c3                   	retq   

000000000000471d <hw_irq_ctrl_get_cur_prio>:
{
    471d:	f3 0f 1e fa          	endbr64 
}
    4721:	8b 05 31 5c 00 00    	mov    0x5c31(%rip),%eax        # a358 <currently_running_prio>
    4727:	c3                   	retq   

0000000000004728 <hw_irq_ctrl_prio_set>:
{
    4728:	f3 0f 1e fa          	endbr64 
	irq_prio[irq] = prio;
    472c:	89 ff                	mov    %edi,%edi
    472e:	48 8d 05 cb 6d 00 00 	lea    0x6dcb(%rip),%rax        # b500 <irq_prio>
    4735:	40 88 34 38          	mov    %sil,(%rax,%rdi,1)
}
    4739:	c3                   	retq   

000000000000473a <hw_irq_ctrl_get_prio>:
{
    473a:	f3 0f 1e fa          	endbr64 
	return irq_prio[irq];
    473e:	89 ff                	mov    %edi,%edi
    4740:	48 8d 05 b9 6d 00 00 	lea    0x6db9(%rip),%rax        # b500 <irq_prio>
    4747:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
    474a:	c3                   	retq   

000000000000474b <hw_irq_ctrl_get_current_lock>:
{
    474b:	f3 0f 1e fa          	endbr64 
	return irqs_locked;
    474f:	0f b6 05 5b 70 00 00 	movzbl 0x705b(%rip),%eax        # b7b1 <irqs_locked>
}
    4756:	c3                   	retq   

0000000000004757 <hw_irq_ctrl_change_lock>:
{
    4757:	f3 0f 1e fa          	endbr64 
	irqs_locked = new_lock;
    475b:	85 ff                	test   %edi,%edi
{
    475d:	41 54                	push   %r12
	uint32_t previous_lock = irqs_locked;
    475f:	44 0f b6 25 4a 70 00 	movzbl 0x704a(%rip),%r12d        # b7b1 <irqs_locked>
    4766:	00 
	irqs_locked = new_lock;
    4767:	0f 95 05 43 70 00 00 	setne  0x7043(%rip)        # b7b1 <irqs_locked>
	if ((previous_lock == true) && (new_lock == false)) {
    476e:	75 14                	jne    4784 <hw_irq_ctrl_change_lock+0x2d>
    4770:	45 84 e4             	test   %r12b,%r12b
    4773:	74 0f                	je     4784 <hw_irq_ctrl_change_lock+0x2d>
		if (irq_status != 0U) {
    4775:	48 83 3d b3 6f 00 00 	cmpq   $0x0,0x6fb3(%rip)        # b730 <irq_status>
    477c:	00 
    477d:	74 05                	je     4784 <hw_irq_ctrl_change_lock+0x2d>
			posix_irq_handler_im_from_sw();
    477f:	e8 60 fe ff ff       	callq  45e4 <posix_irq_handler_im_from_sw>
}
    4784:	44 89 e0             	mov    %r12d,%eax
    4787:	41 5c                	pop    %r12
    4789:	c3                   	retq   

000000000000478a <hw_irq_ctrl_get_irq_status>:
{
    478a:	f3 0f 1e fa          	endbr64 
}
    478e:	48 8b 05 9b 6f 00 00 	mov    0x6f9b(%rip),%rax        # b730 <irq_status>
    4795:	c3                   	retq   

0000000000004796 <hw_irq_ctrl_get_highest_prio_irq>:
{
    4796:	f3 0f 1e fa          	endbr64 
	if (irqs_locked) {
    479a:	80 3d 10 70 00 00 00 	cmpb   $0x0,0x7010(%rip)        # b7b1 <irqs_locked>
    47a1:	75 55                	jne    47f8 <hw_irq_ctrl_get_highest_prio_irq+0x62>
{
    47a3:	51                   	push   %rcx
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
    47a4:	e8 e1 ff ff ff       	callq  478a <hw_irq_ctrl_get_irq_status>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    47a9:	8b 3d a9 5b 00 00    	mov    0x5ba9(%rip),%edi        # a358 <currently_running_prio>
	int winner_prio = 256;
    47af:	be 00 01 00 00       	mov    $0x100,%esi
	int winner = -1;
    47b4:	41 83 c8 ff          	or     $0xffffffff,%r8d
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	return __builtin_ffs(op);
    47b8:	41 83 c9 ff          	or     $0xffffffff,%r9d
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    47bc:	41 ba 01 00 00 00    	mov    $0x1,%r10d
		if ((winner_prio > (int)irq_prio[irq_nbr])
    47c2:	4c 8d 1d 37 6d 00 00 	lea    0x6d37(%rip),%r11        # b500 <irq_prio>
	while (irq_status != 0U) {
    47c9:	48 85 c0             	test   %rax,%rax
    47cc:	74 32                	je     4800 <hw_irq_ctrl_get_highest_prio_irq+0x6a>
    47ce:	0f bc c8             	bsf    %eax,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    47d1:	4c 89 d2             	mov    %r10,%rdx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    47d4:	41 0f 44 c9          	cmove  %r9d,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    47d8:	48 d3 e2             	shl    %cl,%rdx
    47db:	48 f7 d2             	not    %rdx
    47de:	48 21 d0             	and    %rdx,%rax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    47e1:	48 63 d1             	movslq %ecx,%rdx
    47e4:	41 0f b6 14 13       	movzbl (%r11,%rdx,1),%edx
    47e9:	39 f2                	cmp    %esi,%edx
    47eb:	7d dc                	jge    47c9 <hw_irq_ctrl_get_highest_prio_irq+0x33>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    47ed:	39 fa                	cmp    %edi,%edx
    47ef:	0f 4c f2             	cmovl  %edx,%esi
    47f2:	44 0f 4c c1          	cmovl  %ecx,%r8d
    47f6:	eb d1                	jmp    47c9 <hw_irq_ctrl_get_highest_prio_irq+0x33>
    47f8:	41 83 c8 ff          	or     $0xffffffff,%r8d
}
    47fc:	44 89 c0             	mov    %r8d,%eax
    47ff:	c3                   	retq   
    4800:	44 89 c0             	mov    %r8d,%eax
    4803:	5a                   	pop    %rdx
    4804:	c3                   	retq   

0000000000004805 <hw_irq_ctrl_clear_irq>:
{
    4805:	f3 0f 1e fa          	endbr64 
	irq_status  &= ~((uint64_t)1<<irq);
    4809:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    4810:	89 f9                	mov    %edi,%ecx
    4812:	48 d3 c0             	rol    %cl,%rax
    4815:	48 21 05 14 6f 00 00 	and    %rax,0x6f14(%rip)        # b730 <irq_status>
	irq_premask &= ~((uint64_t)1<<irq);
    481c:	48 21 05 05 6f 00 00 	and    %rax,0x6f05(%rip)        # b728 <irq_premask>
}
    4823:	c3                   	retq   

0000000000004824 <hw_irq_ctrl_set_irq>:
{
    4824:	f3 0f 1e fa          	endbr64 
    4828:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    4829:	e8 60 fe ff ff       	callq  468e <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    482e:	80 3d 7c 6f 00 00 00 	cmpb   $0x0,0x6f7c(%rip)        # b7b1 <irqs_locked>
    4835:	74 09                	je     4840 <hw_irq_ctrl_set_irq+0x1c>
    4837:	80 3d 72 6f 00 00 00 	cmpb   $0x0,0x6f72(%rip)        # b7b0 <lock_ignore>
    483e:	74 15                	je     4855 <hw_irq_ctrl_set_irq+0x31>
		irq_ctrl_timer = hwm_get_time();
    4840:	e8 71 f7 ff ff       	callq  3fb6 <hwm_get_time>
    4845:	48 8d 15 f4 5a 00 00 	lea    0x5af4(%rip),%rdx        # a340 <irq_ctrl_timer>
    484c:	48 89 02             	mov    %rax,(%rdx)
}
    484f:	5a                   	pop    %rdx
		hwm_find_next_timer();
    4850:	e9 28 f6 ff ff       	jmpq   3e7d <hwm_find_next_timer>
}
    4855:	58                   	pop    %rax
    4856:	c3                   	retq   

0000000000004857 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    4857:	f3 0f 1e fa          	endbr64 
    485b:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    485c:	e8 2d fe ff ff       	callq  468e <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    4861:	80 3d 49 6f 00 00 00 	cmpb   $0x0,0x6f49(%rip)        # b7b1 <irqs_locked>
    4868:	75 06                	jne    4870 <hw_irq_ctrl_raise_im_from_sw+0x19>
		posix_irq_handler_im_from_sw();
	}
}
    486a:	5a                   	pop    %rdx
		posix_irq_handler_im_from_sw();
    486b:	e9 74 fd ff ff       	jmpq   45e4 <posix_irq_handler_im_from_sw>
}
    4870:	58                   	pop    %rax
    4871:	c3                   	retq   

0000000000004872 <hw_irq_ctrl_enable_irq>:
{
    4872:	f3 0f 1e fa          	endbr64 
	irq_mask |= ((uint64_t)1<<irq);
    4876:	b8 01 00 00 00       	mov    $0x1,%eax
    487b:	89 f9                	mov    %edi,%ecx
    487d:	48 d3 e0             	shl    %cl,%rax
    4880:	48 09 05 99 6e 00 00 	or     %rax,0x6e99(%rip)        # b720 <irq_mask>
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    4887:	48 8b 05 9a 6e 00 00 	mov    0x6e9a(%rip),%rax        # b728 <irq_premask>
    488e:	48 0f a3 f8          	bt     %rdi,%rax
    4892:	73 05                	jae    4899 <hw_irq_ctrl_enable_irq+0x27>
		hw_irq_ctrl_raise_im_from_sw(irq);
    4894:	e9 be ff ff ff       	jmpq   4857 <hw_irq_ctrl_raise_im_from_sw>
}
    4899:	c3                   	retq   

000000000000489a <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
    489a:	f3 0f 1e fa          	endbr64 
	irq_ctrl_timer = NEVER;
    489e:	48 8d 05 9b 5a 00 00 	lea    0x5a9b(%rip),%rax        # a340 <irq_ctrl_timer>
    48a5:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	irq_raising_from_hw_now();
    48ac:	e9 be fd ff ff       	jmpq   466f <irq_raising_from_hw_now>

00000000000048b1 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    48b1:	f3 0f 1e fa          	endbr64 
    48b5:	50                   	push   %rax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    48b6:	39 3d d0 6e 00 00    	cmp    %edi,0x6ed0(%rip)        # b78c <max_exit_code.2396>
    48bc:	0f 4d 3d c9 6e 00 00 	cmovge 0x6ec9(%rip),%edi        # b78c <max_exit_code.2396>
    48c3:	89 3d c3 6e 00 00    	mov    %edi,0x6ec3(%rip)        # b78c <max_exit_code.2396>
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    48c9:	e8 43 f4 ff ff       	callq  3d11 <posix_soc_clean_up>
	hwm_cleanup();
    48ce:	e8 0e f7 ff ff       	callq  3fe1 <hwm_cleanup>
	native_cleanup_cmd_line();
    48d3:	e8 10 0b 00 00       	callq  53e8 <native_cleanup_cmd_line>
	exit(max_exit_code);
    48d8:	8b 3d ae 6e 00 00    	mov    0x6eae(%rip),%edi        # b78c <max_exit_code.2396>
    48de:	e8 9d db ff ff       	callq  2480 <exit@plt>

00000000000048e3 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    48e3:	f3 0f 1e fa          	endbr64 
    48e7:	55                   	push   %rbp
    48e8:	89 fd                	mov    %edi,%ebp
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    48ea:	31 ff                	xor    %edi,%edi
{
    48ec:	48 83 ec 10          	sub    $0x10,%rsp
    48f0:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    48f5:	e8 dd f3 ff ff       	callq  3cd7 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
    48fa:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    48ff:	89 ef                	mov    %ebp,%edi
    4901:	e8 bd 0b 00 00       	callq  54c3 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    4906:	bf 01 00 00 00       	mov    $0x1,%edi
    490b:	e8 c7 f3 ff ff       	callq  3cd7 <run_native_tasks>

	hwm_init();
    4910:	e8 ad f6 ff ff       	callq  3fc2 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    4915:	bf 02 00 00 00       	mov    $0x2,%edi
    491a:	e8 b8 f3 ff ff       	callq  3cd7 <run_native_tasks>

	posix_boot_cpu();
    491f:	e8 f2 f2 ff ff       	callq  3c16 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    4924:	bf 03 00 00 00       	mov    $0x3,%edi
    4929:	e8 a9 f3 ff ff       	callq  3cd7 <run_native_tasks>

	hwm_main_loop();
    492e:	e8 ae f5 ff ff       	callq  3ee1 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    4933:	48 83 c4 10          	add    $0x10,%rsp
    4937:	b8 01 00 00 00       	mov    $0x1,%eax
    493c:	5d                   	pop    %rbp
    493d:	c3                   	retq   

000000000000493e <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
    493e:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 0;
    4942:	48 c7 05 fb 59 00 00 	movq   $0x0,0x59fb(%rip)        # a348 <is_a_tty>
    4949:	00 00 00 00 
	is_a_tty[1] = 0;
}
    494d:	c3                   	retq   

000000000000494e <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
    494e:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = -1;
    4952:	48 c7 05 eb 59 00 00 	movq   $0xffffffffffffffff,0x59eb(%rip)        # a348 <is_a_tty>
    4959:	ff ff ff ff 
	is_a_tty[1] = -1;

}
    495d:	c3                   	retq   

000000000000495e <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
    495e:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 1;
    4962:	48 b8 01 00 00 00 01 	movabs $0x100000001,%rax
    4969:	00 00 00 
    496c:	48 89 05 d5 59 00 00 	mov    %rax,0x59d5(%rip)        # a348 <is_a_tty>
	is_a_tty[1] = 1;
}
    4973:	c3                   	retq   

0000000000004974 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    4974:	f3 0f 1e fa          	endbr64 
    4978:	52                   	push   %rdx
	if (is_a_tty[0] == -1) {
    4979:	83 3d c8 59 00 00 ff 	cmpl   $0xffffffff,0x59c8(%rip)        # a348 <is_a_tty>
    4980:	75 10                	jne    4992 <decide_about_color+0x1e>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    4982:	bf 01 00 00 00       	mov    $0x1,%edi
    4987:	e8 84 d9 ff ff       	callq  2310 <isatty@plt>
    498c:	89 05 b6 59 00 00    	mov    %eax,0x59b6(%rip)        # a348 <is_a_tty>
	}
	if (is_a_tty[1] == -1) {
    4992:	83 3d b3 59 00 00 ff 	cmpl   $0xffffffff,0x59b3(%rip)        # a34c <is_a_tty+0x4>
    4999:	75 10                	jne    49ab <decide_about_color+0x37>
		is_a_tty[1] = isatty(STDERR_FILENO);
    499b:	bf 02 00 00 00       	mov    $0x2,%edi
    49a0:	e8 6b d9 ff ff       	callq  2310 <isatty@plt>
    49a5:	89 05 a1 59 00 00    	mov    %eax,0x59a1(%rip)        # a34c <is_a_tty+0x4>
	}
}
    49ab:	58                   	pop    %rax
    49ac:	c3                   	retq   

00000000000049ad <posix_print_error_and_exit>:
{
    49ad:	f3 0f 1e fa          	endbr64 
    49b1:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    49b8:	49 89 fa             	mov    %rdi,%r10
    49bb:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    49c0:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    49c5:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    49ca:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    49cf:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    49d4:	84 c0                	test   %al,%al
    49d6:	74 37                	je     4a0f <posix_print_error_and_exit+0x62>
    49d8:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    49dd:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    49e2:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    49e7:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    49ee:	00 
    49ef:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    49f6:	00 
    49f7:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    49fe:	00 
    49ff:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4a06:	00 
    4a07:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4a0e:	00 
    4a0f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4a16:	00 00 
    4a18:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4a1d:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    4a1f:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    4a26:	00 

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    4a27:	48 89 e1             	mov    %rsp,%rcx
    4a2a:	4c 89 d2             	mov    %r10,%rdx
    4a2d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4a32:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4a37:	be 01 00 00 00       	mov    $0x1,%esi
    4a3c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    4a41:	48 8b 05 b0 55 00 00 	mov    0x55b0(%rip),%rax        # 9ff8 <stderr@GLIBC_2.2.5>
    4a48:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    4a4f:	48 8b 38             	mov    (%rax),%rdi
    4a52:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    4a59:	00 
    4a5a:	e8 81 d8 ff ff       	callq  22e0 <__vfprintf_chk@plt>
	posix_exit(1);
    4a5f:	bf 01 00 00 00       	mov    $0x1,%edi
    4a64:	e8 48 fe ff ff       	callq  48b1 <posix_exit>
}
    4a69:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4a6e:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4a75:	00 00 
    4a77:	74 05                	je     4a7e <posix_print_error_and_exit+0xd1>
    4a79:	e8 f2 d8 ff ff       	callq  2370 <__stack_chk_fail@plt>
    4a7e:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    4a85:	c3                   	retq   

0000000000004a86 <posix_print_warning>:
{
    4a86:	f3 0f 1e fa          	endbr64 
    4a8a:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4a91:	49 89 fa             	mov    %rdi,%r10
    4a94:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    4a99:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4a9e:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4aa3:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    4aa8:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4aad:	84 c0                	test   %al,%al
    4aaf:	74 37                	je     4ae8 <posix_print_warning+0x62>
    4ab1:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    4ab6:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4abb:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4ac0:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    4ac7:	00 
    4ac8:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4acf:	00 
    4ad0:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    4ad7:	00 
    4ad8:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4adf:	00 
    4ae0:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4ae7:	00 
    4ae8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4aef:	00 00 
    4af1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4af6:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    4af8:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    4aff:	00 
    4b00:	48 89 e1             	mov    %rsp,%rcx
    4b03:	4c 89 d2             	mov    %r10,%rdx
    4b06:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4b0b:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4b10:	be 01 00 00 00       	mov    $0x1,%esi
    4b15:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    4b1a:	48 8b 05 d7 54 00 00 	mov    0x54d7(%rip),%rax        # 9ff8 <stderr@GLIBC_2.2.5>
    4b21:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    4b28:	48 8b 38             	mov    (%rax),%rdi
    4b2b:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    4b32:	00 
    4b33:	e8 a8 d7 ff ff       	callq  22e0 <__vfprintf_chk@plt>
}
    4b38:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4b3d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4b44:	00 00 
    4b46:	74 05                	je     4b4d <posix_print_warning+0xc7>
    4b48:	e8 23 d8 ff ff       	callq  2370 <__stack_chk_fail@plt>
    4b4d:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    4b54:	c3                   	retq   

0000000000004b55 <posix_print_trace>:
{
    4b55:	f3 0f 1e fa          	endbr64 
    4b59:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4b60:	49 89 fa             	mov    %rdi,%r10
    4b63:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    4b68:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4b6d:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4b72:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    4b77:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4b7c:	84 c0                	test   %al,%al
    4b7e:	74 37                	je     4bb7 <posix_print_trace+0x62>
    4b80:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    4b85:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4b8a:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4b8f:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    4b96:	00 
    4b97:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4b9e:	00 
    4b9f:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    4ba6:	00 
    4ba7:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4bae:	00 
    4baf:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4bb6:	00 
    4bb7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4bbe:	00 00 
    4bc0:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4bc5:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    4bc7:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    4bce:	00 
    4bcf:	48 89 e1             	mov    %rsp,%rcx
    4bd2:	4c 89 d2             	mov    %r10,%rdx
    4bd5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4bda:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4bdf:	be 01 00 00 00       	mov    $0x1,%esi
    4be4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    4be9:	48 8b 05 b8 53 00 00 	mov    0x53b8(%rip),%rax        # 9fa8 <stdout@GLIBC_2.2.5>
    4bf0:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    4bf7:	48 8b 38             	mov    (%rax),%rdi
    4bfa:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    4c01:	00 
    4c02:	e8 d9 d6 ff ff       	callq  22e0 <__vfprintf_chk@plt>
}
    4c07:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4c0c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4c13:	00 00 
    4c15:	74 05                	je     4c1c <posix_print_trace+0xc7>
    4c17:	e8 54 d7 ff ff       	callq  2370 <__stack_chk_fail@plt>
    4c1c:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    4c23:	c3                   	retq   

0000000000004c24 <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    4c24:	f3 0f 1e fa          	endbr64 
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    4c28:	48 8d 3d 91 55 00 00 	lea    0x5591(%rip),%rdi        # a1c0 <trace_options.3560>
    4c2f:	e9 d8 07 00 00       	jmpq   540c <native_add_command_line_opts>

0000000000004c34 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    4c34:	41 55                	push   %r13
    4c36:	41 bd 46 00 00 00    	mov    $0x46,%r13d
    4c3c:	41 54                	push   %r12
    4c3e:	49 89 f4             	mov    %rsi,%r12
    4c41:	55                   	push   %rbp
    4c42:	48 89 fd             	mov    %rdi,%rbp
    4c45:	53                   	push   %rbx
    4c46:	41 53                	push   %r11

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    4c48:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
    4c4c:	75 0c                	jne    4c5a <cmd_gen_switch_syntax.constprop.0+0x26>
		*buf++ = '[';
    4c4e:	c6 07 5b             	movb   $0x5b,(%rdi)
    4c51:	48 ff c5             	inc    %rbp
		size--;
    4c54:	41 bd 45 00 00 00    	mov    $0x45,%r13d
	}

	if (args_s_el->is_switch == true) {
    4c5a:	41 80 7c 24 02 00    	cmpb   $0x0,0x2(%r12)
    4c60:	4d 8b 4c 24 08       	mov    0x8(%r12),%r9
    4c65:	49 63 f5             	movslq %r13d,%rsi
    4c68:	74 1c                	je     4c86 <cmd_gen_switch_syntax.constprop.0+0x52>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    4c6a:	4c 8d 05 1d 2e 00 00 	lea    0x2e1d(%rip),%r8        # 7a8e <__func__.5051+0xa8e>
    4c71:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    4c75:	48 89 ef             	mov    %rbp,%rdi
    4c78:	31 c0                	xor    %eax,%eax
    4c7a:	ba 01 00 00 00       	mov    $0x1,%edx
    4c7f:	e8 0c d6 ff ff       	callq  2290 <__snprintf_chk@plt>
    4c84:	eb 38                	jmp    4cbe <cmd_gen_switch_syntax.constprop.0+0x8a>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    4c86:	41 80 7c 24 18 6c    	cmpb   $0x6c,0x18(%r12)
    4c8c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    4c91:	74 0c                	je     4c9f <cmd_gen_switch_syntax.constprop.0+0x6b>
    4c93:	4c 8d 05 f8 2d 00 00 	lea    0x2df8(%rip),%r8        # 7a92 <__func__.5051+0xa92>
    4c9a:	41 52                	push   %r10
    4c9c:	50                   	push   %rax
    4c9d:	eb 0a                	jmp    4ca9 <cmd_gen_switch_syntax.constprop.0+0x75>
    4c9f:	41 50                	push   %r8
    4ca1:	4c 8d 05 f3 2d 00 00 	lea    0x2df3(%rip),%r8        # 7a9b <__func__.5051+0xa9b>
    4ca8:	50                   	push   %rax
    4ca9:	48 89 ef             	mov    %rbp,%rdi
    4cac:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    4cb0:	ba 01 00 00 00       	mov    $0x1,%edx
    4cb5:	31 c0                	xor    %eax,%eax
    4cb7:	e8 d4 d5 ff ff       	callq  2290 <__snprintf_chk@plt>
    4cbc:	5e                   	pop    %rsi
    4cbd:	5f                   	pop    %rdi
    4cbe:	48 63 d8             	movslq %eax,%rbx
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    4cc1:	85 db                	test   %ebx,%ebx
    4cc3:	79 1a                	jns    4cdf <cmd_gen_switch_syntax.constprop.0+0xab>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    4cc5:	ba 07 01 00 00       	mov    $0x107,%edx
    4cca:	48 8d 35 d6 2d 00 00 	lea    0x2dd6(%rip),%rsi        # 7aa7 <__func__.5051+0xaa7>
    4cd1:	48 8d 3d 0d 2e 00 00 	lea    0x2e0d(%rip),%rdi        # 7ae5 <__func__.5051+0xae5>
    4cd8:	31 c0                	xor    %eax,%eax
    4cda:	e8 ce fc ff ff       	callq  49ad <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    4cdf:	41 29 dd             	sub    %ebx,%r13d
    4ce2:	78 2c                	js     4d10 <cmd_gen_switch_syntax.constprop.0+0xdc>
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    4ce4:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
	buf += ret;
    4cea:	48 8d 7c 1d 00       	lea    0x0(%rbp,%rbx,1),%rdi
	if (args_s_el->is_mandatory == false) {
    4cef:	49 63 f5             	movslq %r13d,%rsi
    4cf2:	48 8d 15 07 2e 00 00 	lea    0x2e07(%rip),%rdx        # 7b00 <__func__.5051+0xb00>
    4cf9:	74 07                	je     4d02 <cmd_gen_switch_syntax.constprop.0+0xce>
    4cfb:	48 8d 15 ff 2d 00 00 	lea    0x2dff(%rip),%rdx        # 7b01 <__func__.5051+0xb01>
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    4d02:	59                   	pop    %rcx
    4d03:	31 c0                	xor    %eax,%eax
    4d05:	5b                   	pop    %rbx
    4d06:	5d                   	pop    %rbp
    4d07:	41 5c                	pop    %r12
    4d09:	41 5d                	pop    %r13
    4d0b:	e9 70 d6 ff ff       	jmpq   2380 <snprintf@plt>
    4d10:	58                   	pop    %rax
    4d11:	5b                   	pop    %rbx
    4d12:	5d                   	pop    %rbp
    4d13:	41 5c                	pop    %r12
    4d15:	41 5d                	pop    %r13
    4d17:	c3                   	retq   

0000000000004d18 <cmd_is_option>:
{
    4d18:	f3 0f 1e fa          	endbr64 
    4d1c:	41 54                	push   %r12
    4d1e:	49 89 f8             	mov    %rdi,%r8
    4d21:	41 89 d4             	mov    %edx,%r12d
    4d24:	55                   	push   %rbp
    4d25:	48 89 f5             	mov    %rsi,%rbp
    4d28:	53                   	push   %rbx
	int of = 0;
    4d29:	31 db                	xor    %ebx,%ebx
    4d2b:	80 3f 2d             	cmpb   $0x2d,(%rdi)
	if (arg[of] == '-') {
    4d2e:	0f 94 c0             	sete   %al
	int of = 0;
    4d31:	0f 94 c3             	sete   %bl
	if (arg[of] == '-') {
    4d34:	0f b6 c0             	movzbl %al,%eax
    4d37:	80 3c 07 2d          	cmpb   $0x2d,(%rdi,%rax,1)
    4d3b:	75 02                	jne    4d3f <cmd_is_option+0x27>
		of++;
    4d3d:	ff c3                	inc    %ebx
	if (!with_value) {
    4d3f:	45 85 e4             	test   %r12d,%r12d
    4d42:	75 28                	jne    4d6c <cmd_is_option+0x54>
		if (strcmp(&arg[of], option) != 0) {
    4d44:	48 63 fb             	movslq %ebx,%rdi
    4d47:	48 89 ee             	mov    %rbp,%rsi
    4d4a:	4c 01 c7             	add    %r8,%rdi
    4d4d:	e8 7e d6 ff ff       	callq  23d0 <strcmp@plt>
    4d52:	85 c0                	test   %eax,%eax
    4d54:	75 68                	jne    4dbe <cmd_is_option+0xa6>
	size_t to_match_len = strlen(option);
    4d56:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    4d5a:	48 89 ef             	mov    %rbp,%rdi
    4d5d:	f2 ae                	repnz scas %es:(%rdi),%al
    4d5f:	48 89 c8             	mov    %rcx,%rax
    4d62:	48 f7 d0             	not    %rax
			return of + to_match_len;
    4d65:	44 8d 64 03 ff       	lea    -0x1(%rbx,%rax,1),%r12d
    4d6a:	eb 52                	jmp    4dbe <cmd_is_option+0xa6>
    4d6c:	31 d2                	xor    %edx,%edx
    4d6e:	44 8d 24 13          	lea    (%rbx,%rdx,1),%r12d
	while (!(arg[of] == 0 && *option == 0)) {
    4d72:	8a 4c 15 00          	mov    0x0(%rbp,%rdx,1),%cl
    4d76:	49 63 c4             	movslq %r12d,%rax
    4d79:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    4d7d:	89 c6                	mov    %eax,%esi
    4d7f:	40 08 ce             	or     %cl,%sil
    4d82:	74 24                	je     4da8 <cmd_is_option+0x90>
		if (*option == 0) {
    4d84:	84 c9                	test   %cl,%cl
    4d86:	75 17                	jne    4d9f <cmd_is_option+0x87>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    4d88:	3c 3a                	cmp    $0x3a,%al
    4d8a:	74 04                	je     4d90 <cmd_is_option+0x78>
    4d8c:	3c 3d                	cmp    $0x3d,%al
    4d8e:	75 2b                	jne    4dbb <cmd_is_option+0xa3>
				of++;
    4d90:	41 ff c4             	inc    %r12d
	if (arg[of] == 0) { /* we need a value to follow */
    4d93:	49 63 c4             	movslq %r12d,%rax
    4d96:	41 80 3c 00 00       	cmpb   $0x0,(%r8,%rax,1)
    4d9b:	75 21                	jne    4dbe <cmd_is_option+0xa6>
    4d9d:	eb 09                	jmp    4da8 <cmd_is_option+0x90>
		if (arg[of] != *option) {
    4d9f:	48 ff c2             	inc    %rdx
    4da2:	38 c8                	cmp    %cl,%al
    4da4:	74 c8                	je     4d6e <cmd_is_option+0x56>
    4da6:	eb 13                	jmp    4dbb <cmd_is_option+0xa3>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    4da8:	4c 89 c6             	mov    %r8,%rsi
    4dab:	48 8d 3d 51 2d 00 00 	lea    0x2d51(%rip),%rdi        # 7b03 <__func__.5051+0xb03>
    4db2:	31 c0                	xor    %eax,%eax
    4db4:	e8 f4 fb ff ff       	callq  49ad <posix_print_error_and_exit>
    4db9:	eb 03                	jmp    4dbe <cmd_is_option+0xa6>
			return 0;
    4dbb:	45 31 e4             	xor    %r12d,%r12d
}
    4dbe:	44 89 e0             	mov    %r12d,%eax
    4dc1:	5b                   	pop    %rbx
    4dc2:	5d                   	pop    %rbp
    4dc3:	41 5c                	pop    %r12
    4dc5:	c3                   	retq   

0000000000004dc6 <cmd_is_help_option>:
{
    4dc6:	f3 0f 1e fa          	endbr64 
    4dca:	55                   	push   %rbp
	if (arg[0] == '-') {
    4dcb:	80 3f 2d             	cmpb   $0x2d,(%rdi)
{
    4dce:	48 89 fd             	mov    %rdi,%rbp
	if (arg[0] == '-') {
    4dd1:	75 0f                	jne    4de2 <cmd_is_help_option+0x1c>
	if (arg[0] == '-') {
    4dd3:	80 7f 01 2d          	cmpb   $0x2d,0x1(%rdi)
    4dd7:	74 05                	je     4dde <cmd_is_help_option+0x18>
		arg++;
    4dd9:	48 ff c5             	inc    %rbp
    4ddc:	eb 04                	jmp    4de2 <cmd_is_help_option+0x1c>
		arg++;
    4dde:	48 83 c5 02          	add    $0x2,%rbp
	if ((strcasecmp(arg, "?") == 0) ||
    4de2:	48 8d 35 74 2d 00 00 	lea    0x2d74(%rip),%rsi        # 7b5d <__func__.5051+0xb5d>
    4de9:	48 89 ef             	mov    %rbp,%rdi
    4dec:	e8 cf d4 ff ff       	callq  22c0 <strcasecmp@plt>
    4df1:	41 89 c0             	mov    %eax,%r8d
		return 1;
    4df4:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    4df9:	45 85 c0             	test   %r8d,%r8d
    4dfc:	74 33                	je     4e31 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
    4dfe:	48 8d 35 5a 2d 00 00 	lea    0x2d5a(%rip),%rsi        # 7b5f <__func__.5051+0xb5f>
    4e05:	48 89 ef             	mov    %rbp,%rdi
    4e08:	e8 b3 d4 ff ff       	callq  22c0 <strcasecmp@plt>
    4e0d:	41 89 c0             	mov    %eax,%r8d
		return 1;
    4e10:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    4e15:	45 85 c0             	test   %r8d,%r8d
    4e18:	74 17                	je     4e31 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
    4e1a:	48 8d 35 e0 2d 00 00 	lea    0x2de0(%rip),%rsi        # 7c01 <__func__.5051+0xc01>
    4e21:	48 89 ef             	mov    %rbp,%rdi
    4e24:	e8 97 d4 ff ff       	callq  22c0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
    4e29:	85 c0                	test   %eax,%eax
    4e2b:	0f 94 c0             	sete   %al
    4e2e:	0f b6 c0             	movzbl %al,%eax
}
    4e31:	5d                   	pop    %rbp
    4e32:	c3                   	retq   

0000000000004e33 <cmd_read_option_value>:
{
    4e33:	f3 0f 1e fa          	endbr64 
    4e37:	41 54                	push   %r12
    4e39:	49 89 fc             	mov    %rdi,%r12
    4e3c:	55                   	push   %rbp
    4e3d:	48 89 cd             	mov    %rcx,%rbp
    4e40:	53                   	push   %rbx
    4e41:	48 89 f3             	mov    %rsi,%rbx
    4e44:	48 83 ec 10          	sub    $0x10,%rsp
    4e48:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4e4f:	00 00 
    4e51:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4e56:	31 c0                	xor    %eax,%eax
	char *endptr = NULL;
    4e58:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    4e5f:	00 
	switch (type) {
    4e60:	80 fa 64             	cmp    $0x64,%dl
    4e63:	0f 84 11 01 00 00    	je     4f7a <cmd_read_option_value+0x147>
    4e69:	7f 26                	jg     4e91 <cmd_read_option_value+0x5e>
    4e6b:	80 fa 55             	cmp    $0x55,%dl
    4e6e:	0f 84 f1 00 00 00    	je     4f65 <cmd_read_option_value+0x132>
    4e74:	80 fa 62             	cmp    $0x62,%dl
    4e77:	74 42                	je     4ebb <cmd_read_option_value+0x88>
    4e79:	80 fa 49             	cmp    $0x49,%dl
    4e7c:	0f 85 06 01 00 00    	jne    4f88 <cmd_read_option_value+0x155>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    4e82:	48 89 e6             	mov    %rsp,%rsi
    4e85:	31 d2                	xor    %edx,%edx
    4e87:	e8 54 d5 ff ff       	callq  23e0 <strtoll@plt>
    4e8c:	e9 e4 00 00 00       	jmpq   4f75 <cmd_read_option_value+0x142>
	switch (type) {
    4e91:	80 fa 73             	cmp    $0x73,%dl
    4e94:	0f 84 aa 00 00 00    	je     4f44 <cmd_read_option_value+0x111>
    4e9a:	80 fa 75             	cmp    $0x75,%dl
    4e9d:	0f 84 b6 00 00 00    	je     4f59 <cmd_read_option_value+0x126>
    4ea3:	80 fa 69             	cmp    $0x69,%dl
    4ea6:	0f 85 dc 00 00 00    	jne    4f88 <cmd_read_option_value+0x155>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    4eac:	48 89 e6             	mov    %rsp,%rsi
    4eaf:	31 d2                	xor    %edx,%edx
    4eb1:	e8 4a d5 ff ff       	callq  2400 <strtol@plt>
    4eb6:	e9 b6 00 00 00       	jmpq   4f71 <cmd_read_option_value+0x13e>
		if (strcasecmp(str, "false") == 0) {
    4ebb:	48 8d 35 9f 2c 00 00 	lea    0x2c9f(%rip),%rsi        # 7b61 <__func__.5051+0xb61>
    4ec2:	e8 f9 d3 ff ff       	callq  22c0 <strcasecmp@plt>
    4ec7:	85 c0                	test   %eax,%eax
    4ec9:	75 0a                	jne    4ed5 <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
    4ecb:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 5;
    4ece:	49 8d 44 24 05       	lea    0x5(%r12),%rax
    4ed3:	eb 1b                	jmp    4ef0 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "0") == 0) {
    4ed5:	48 8d 35 8b 2c 00 00 	lea    0x2c8b(%rip),%rsi        # 7b67 <__func__.5051+0xb67>
    4edc:	4c 89 e7             	mov    %r12,%rdi
    4edf:	e8 ec d4 ff ff       	callq  23d0 <strcmp@plt>
    4ee4:	85 c0                	test   %eax,%eax
    4ee6:	75 11                	jne    4ef9 <cmd_read_option_value+0xc6>
			*(bool *)dest = false;
    4ee8:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 1;
    4eeb:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    4ef0:	48 89 04 24          	mov    %rax,(%rsp)
	if (!error && endptr && *endptr != 0) {
    4ef4:	e9 a0 00 00 00       	jmpq   4f99 <cmd_read_option_value+0x166>
		} else if (strcasecmp(str, "true") == 0) {
    4ef9:	48 8d 35 69 2c 00 00 	lea    0x2c69(%rip),%rsi        # 7b69 <__func__.5051+0xb69>
    4f00:	4c 89 e7             	mov    %r12,%rdi
    4f03:	e8 b8 d3 ff ff       	callq  22c0 <strcasecmp@plt>
    4f08:	85 c0                	test   %eax,%eax
    4f0a:	75 0a                	jne    4f16 <cmd_read_option_value+0xe3>
			*(bool *)dest = true;
    4f0c:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 4;
    4f0f:	49 8d 44 24 04       	lea    0x4(%r12),%rax
    4f14:	eb da                	jmp    4ef0 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "1") == 0) {
    4f16:	48 8d 35 51 2c 00 00 	lea    0x2c51(%rip),%rsi        # 7b6e <__func__.5051+0xb6e>
    4f1d:	4c 89 e7             	mov    %r12,%rdi
    4f20:	e8 ab d4 ff ff       	callq  23d0 <strcmp@plt>
    4f25:	85 c0                	test   %eax,%eax
    4f27:	74 16                	je     4f3f <cmd_read_option_value+0x10c>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    4f29:	4c 89 e2             	mov    %r12,%rdx
    4f2c:	48 89 ee             	mov    %rbp,%rsi
    4f2f:	48 8d 3d 3a 2c 00 00 	lea    0x2c3a(%rip),%rdi        # 7b70 <__func__.5051+0xb70>
    4f36:	31 c0                	xor    %eax,%eax
    4f38:	e8 70 fa ff ff       	callq  49ad <posix_print_error_and_exit>
    4f3d:	eb 68                	jmp    4fa7 <cmd_read_option_value+0x174>
			*(bool *)dest = true;
    4f3f:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 1;
    4f42:	eb a7                	jmp    4eeb <cmd_read_option_value+0xb8>
		*(char **)dest = (char *)str;
    4f44:	48 89 3b             	mov    %rdi,(%rbx)
		endptr = (char *)str + strlen(str);
    4f47:	31 c0                	xor    %eax,%eax
    4f49:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    4f4d:	f2 ae                	repnz scas %es:(%rdi),%al
    4f4f:	48 f7 d1             	not    %rcx
    4f52:	49 8d 44 0c ff       	lea    -0x1(%r12,%rcx,1),%rax
    4f57:	eb 97                	jmp    4ef0 <cmd_read_option_value+0xbd>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    4f59:	48 89 e6             	mov    %rsp,%rsi
    4f5c:	31 d2                	xor    %edx,%edx
    4f5e:	e8 fd d4 ff ff       	callq  2460 <strtoul@plt>
    4f63:	eb 0c                	jmp    4f71 <cmd_read_option_value+0x13e>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    4f65:	48 89 e6             	mov    %rsp,%rsi
    4f68:	31 d2                	xor    %edx,%edx
    4f6a:	e8 41 d4 ff ff       	callq  23b0 <strtoull@plt>
    4f6f:	eb 04                	jmp    4f75 <cmd_read_option_value+0x142>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    4f71:	89 03                	mov    %eax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    4f73:	eb 24                	jmp    4f99 <cmd_read_option_value+0x166>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    4f75:	48 89 03             	mov    %rax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    4f78:	eb 1f                	jmp    4f99 <cmd_read_option_value+0x166>
		*(double *)dest = strtod(str, &endptr);
    4f7a:	48 89 e6             	mov    %rsp,%rsi
    4f7d:	e8 be d3 ff ff       	callq  2340 <strtod@plt>
    4f82:	f2 0f 11 03          	movsd  %xmm0,(%rbx)
	if (!error && endptr && *endptr != 0) {
    4f86:	eb 11                	jmp    4f99 <cmd_read_option_value+0x166>
	switch (type) {
    4f88:	0f be f2             	movsbl %dl,%esi
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    4f8b:	48 8d 3d 20 2c 00 00 	lea    0x2c20(%rip),%rdi        # 7bb2 <__func__.5051+0xbb2>
    4f92:	31 c0                	xor    %eax,%eax
    4f94:	e8 14 fa ff ff       	callq  49ad <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
    4f99:	48 8b 04 24          	mov    (%rsp),%rax
    4f9d:	48 85 c0             	test   %rax,%rax
    4fa0:	74 05                	je     4fa7 <cmd_read_option_value+0x174>
    4fa2:	80 38 00             	cmpb   $0x0,(%rax)
    4fa5:	75 82                	jne    4f29 <cmd_read_option_value+0xf6>
}
    4fa7:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    4fac:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4fb3:	00 00 
    4fb5:	74 05                	je     4fbc <cmd_read_option_value+0x189>
    4fb7:	e8 b4 d3 ff ff       	callq  2370 <__stack_chk_fail@plt>
    4fbc:	48 83 c4 10          	add    $0x10,%rsp
    4fc0:	5b                   	pop    %rbx
    4fc1:	5d                   	pop    %rbp
    4fc2:	41 5c                	pop    %r12
    4fc4:	c3                   	retq   

0000000000004fc5 <cmd_args_set_defaults>:
{
    4fc5:	f3 0f 1e fa          	endbr64 
    4fc9:	55                   	push   %rbp
	int count = 0;
    4fca:	31 ed                	xor    %ebp,%ebp
{
    4fcc:	53                   	push   %rbx
    4fcd:	48 89 fb             	mov    %rdi,%rbx
    4fd0:	52                   	push   %rdx
	while (args_struct[count].option != NULL) {
    4fd1:	48 63 d5             	movslq %ebp,%rdx
    4fd4:	48 6b d2 38          	imul   $0x38,%rdx,%rdx
    4fd8:	48 01 da             	add    %rbx,%rdx
    4fdb:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
    4fe0:	0f 84 a0 00 00 00    	je     5086 <cmd_args_set_defaults+0xc1>
		if (args_struct[count].dest == NULL) {
    4fe6:	48 8b 42 20          	mov    0x20(%rdx),%rax
    4fea:	ff c5                	inc    %ebp
    4fec:	48 85 c0             	test   %rax,%rax
    4fef:	74 e0                	je     4fd1 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    4ff1:	0f be 72 18          	movsbl 0x18(%rdx),%esi
    4ff5:	40 80 fe 64          	cmp    $0x64,%sil
    4ff9:	74 69                	je     5064 <cmd_args_set_defaults+0x9f>
    4ffb:	7f 2d                	jg     502a <cmd_args_set_defaults+0x65>
    4ffd:	40 80 fe 55          	cmp    $0x55,%sil
    5001:	74 55                	je     5058 <cmd_args_set_defaults+0x93>
    5003:	7f 1a                	jg     501f <cmd_args_set_defaults+0x5a>
    5005:	40 84 f6             	test   %sil,%sil
    5008:	74 c7                	je     4fd1 <cmd_args_set_defaults+0xc>
    500a:	40 80 fe 49          	cmp    $0x49,%sil
    500e:	75 63                	jne    5073 <cmd_args_set_defaults+0xae>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    5010:	48 b9 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rcx
    5017:	ff ff 7f 
    501a:	48 89 08             	mov    %rcx,(%rax)
			break;
    501d:	eb b2                	jmp    4fd1 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    501f:	40 80 fe 62          	cmp    $0x62,%sil
    5023:	75 4e                	jne    5073 <cmd_args_set_defaults+0xae>
			*(bool *)args_struct[count].dest = false;
    5025:	c6 00 00             	movb   $0x0,(%rax)
			break;
    5028:	eb a7                	jmp    4fd1 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    502a:	40 80 fe 73          	cmp    $0x73,%sil
    502e:	74 14                	je     5044 <cmd_args_set_defaults+0x7f>
    5030:	40 80 fe 75          	cmp    $0x75,%sil
    5034:	74 17                	je     504d <cmd_args_set_defaults+0x88>
    5036:	40 80 fe 69          	cmp    $0x69,%sil
    503a:	75 37                	jne    5073 <cmd_args_set_defaults+0xae>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    503c:	c7 00 ff ff ff 7f    	movl   $0x7fffffff,(%rax)
			break;
    5042:	eb 8d                	jmp    4fd1 <cmd_args_set_defaults+0xc>
			*(char **)args_struct[count].dest = NULL;
    5044:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			break;
    504b:	eb 84                	jmp    4fd1 <cmd_args_set_defaults+0xc>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    504d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
			break;
    5053:	e9 79 ff ff ff       	jmpq   4fd1 <cmd_args_set_defaults+0xc>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    5058:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
			break;
    505f:	e9 6d ff ff ff       	jmpq   4fd1 <cmd_args_set_defaults+0xc>
			*(double *)args_struct[count].dest = NAN;
    5064:	48 8b 0d dd 1f 00 00 	mov    0x1fdd(%rip),%rcx        # 7048 <__func__.5051+0x48>
    506b:	48 89 08             	mov    %rcx,(%rax)
			break;
    506e:	e9 5e ff ff ff       	jmpq   4fd1 <cmd_args_set_defaults+0xc>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    5073:	48 8d 3d 38 2b 00 00 	lea    0x2b38(%rip),%rdi        # 7bb2 <__func__.5051+0xbb2>
    507a:	31 c0                	xor    %eax,%eax
    507c:	e8 2c f9 ff ff       	callq  49ad <posix_print_error_and_exit>
			break;
    5081:	e9 4b ff ff ff       	jmpq   4fd1 <cmd_args_set_defaults+0xc>
}
    5086:	58                   	pop    %rax
    5087:	5b                   	pop    %rbx
    5088:	5d                   	pop    %rbp
    5089:	c3                   	retq   

000000000000508a <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    508a:	f3 0f 1e fa          	endbr64 
    508e:	41 56                	push   %r14
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    5090:	be 01 00 00 00       	mov    $0x1,%esi
    5095:	48 8d 0d 3b 2b 00 00 	lea    0x2b3b(%rip),%rcx        # 7bd7 <__func__.5051+0xbd7>
    509c:	48 8d 15 4d 2b 00 00 	lea    0x2b4d(%rip),%rdx        # 7bf0 <__func__.5051+0xbf0>
    50a3:	41 55                	push   %r13
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    50a5:	41 be 19 00 00 00    	mov    $0x19,%r14d
	int count = 0;
    50ab:	45 31 ed             	xor    %r13d,%r13d
{
    50ae:	41 54                	push   %r12
    50b0:	49 89 fc             	mov    %rdi,%r12
    50b3:	55                   	push   %rbp
    50b4:	53                   	push   %rbx
    50b5:	48 83 ec 50          	sub    $0x50,%rsp

	fprintf(stdout, "%s ", _HELP_SWITCH);
    50b9:	48 8b 1d e8 4e 00 00 	mov    0x4ee8(%rip),%rbx        # 9fa8 <stdout@GLIBC_2.2.5>
{
    50c0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    50c7:	00 00 
    50c9:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    50ce:	31 c0                	xor    %eax,%eax

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    50d0:	48 8d 6c 24 02       	lea    0x2(%rsp),%rbp
    50d5:	48 8b 3b             	mov    (%rbx),%rdi
    50d8:	e8 b3 d3 ff ff       	callq  2490 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
    50dd:	49 63 f5             	movslq %r13d,%rsi
    50e0:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    50e4:	4c 01 e6             	add    %r12,%rsi
    50e7:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
    50ec:	74 6e                	je     515c <cmd_print_switches_help+0xd2>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    50ee:	48 89 ef             	mov    %rbp,%rdi
    50f1:	e8 3e fb ff ff       	callq  4c34 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    50f6:	31 c0                	xor    %eax,%eax
    50f8:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    50fc:	48 89 ef             	mov    %rbp,%rdi
    50ff:	f2 ae                	repnz scas %es:(%rdi),%al
    5101:	49 63 c6             	movslq %r14d,%rax
    5104:	48 f7 d1             	not    %rcx
    5107:	48 8d 44 01 ff       	lea    -0x1(%rcx,%rax,1),%rax
    510c:	48 83 f8 64          	cmp    $0x64,%rax
    5110:	76 19                	jbe    512b <cmd_print_switches_help+0xa1>
    5112:	48 8b 3b             	mov    (%rbx),%rdi
    5115:	48 8d 15 54 2b 00 00 	lea    0x2b54(%rip),%rdx        # 7c70 <__func__.5051+0xc70>
    511c:	31 c0                	xor    %eax,%eax
			fprintf(stdout, "\n");
			printed_in_line = 0;
    511e:	45 31 f6             	xor    %r14d,%r14d
    5121:	be 01 00 00 00       	mov    $0x1,%esi
    5126:	e8 65 d3 ff ff       	callq  2490 <__fprintf_chk@plt>
    512b:	48 8b 3b             	mov    (%rbx),%rdi
    512e:	48 89 e9             	mov    %rbp,%rcx
    5131:	48 8d 15 57 29 00 00 	lea    0x2957(%rip),%rdx        # 7a8f <__func__.5051+0xa8f>
    5138:	31 c0                	xor    %eax,%eax
    513a:	be 01 00 00 00       	mov    $0x1,%esi
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
		count++;
    513f:	41 ff c5             	inc    %r13d
    5142:	e8 49 d3 ff ff       	callq  2490 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
    5147:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    514b:	31 c0                	xor    %eax,%eax
    514d:	48 89 ef             	mov    %rbp,%rdi
    5150:	f2 ae                	repnz scas %es:(%rdi),%al
    5152:	48 f7 d1             	not    %rcx
    5155:	45 8d 74 0e ff       	lea    -0x1(%r14,%rcx,1),%r14d
		count++;
    515a:	eb 81                	jmp    50dd <cmd_print_switches_help+0x53>
    515c:	48 8b 3b             	mov    (%rbx),%rdi
    515f:	31 c0                	xor    %eax,%eax
    5161:	be 01 00 00 00       	mov    $0x1,%esi
    5166:	48 8d 15 03 2b 00 00 	lea    0x2b03(%rip),%rdx        # 7c70 <__func__.5051+0xc70>
    516d:	e8 1e d3 ff ff       	callq  2490 <__fprintf_chk@plt>
	}

	fprintf(stdout, "\n");
}
    5172:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    5177:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    517e:	00 00 
    5180:	74 05                	je     5187 <cmd_print_switches_help+0xfd>
    5182:	e8 e9 d1 ff ff       	callq  2370 <__stack_chk_fail@plt>
    5187:	48 83 c4 50          	add    $0x50,%rsp
    518b:	5b                   	pop    %rbx
    518c:	5d                   	pop    %rbp
    518d:	41 5c                	pop    %r12
    518f:	41 5d                	pop    %r13
    5191:	41 5e                	pop    %r14
    5193:	c3                   	retq   

0000000000005194 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    5194:	f3 0f 1e fa          	endbr64 
    5198:	41 57                	push   %r15
    519a:	4c 8d 3d d0 2a 00 00 	lea    0x2ad0(%rip),%r15        # 7c71 <__func__.5051+0xc71>
    51a1:	41 56                	push   %r14
    51a3:	41 55                	push   %r13
	int ret;
	int count = 0;
    51a5:	45 31 ed             	xor    %r13d,%r13d
{
    51a8:	41 54                	push   %r12
    51aa:	49 89 fc             	mov    %rdi,%r12
    51ad:	55                   	push   %rbp
    51ae:	53                   	push   %rbx
    51af:	48 83 ec 68          	sub    $0x68,%rsp
    51b3:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    51ba:	00 00 
    51bc:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    51c1:	31 c0                	xor    %eax,%eax
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    51c3:	e8 c2 fe ff ff       	callq  508a <cmd_print_switches_help>

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
    51c8:	48 8b 1d d9 4d 00 00 	mov    0x4dd9(%rip),%rbx        # 9fa8 <stdout@GLIBC_2.2.5>
    51cf:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    51d4:	31 c0                	xor    %eax,%eax
    51d6:	4c 8d 0d 17 2a 00 00 	lea    0x2a17(%rip),%r9        # 7bf4 <__func__.5051+0xbf4>
    51dd:	4c 8d 05 f3 29 00 00 	lea    0x29f3(%rip),%r8        # 7bd7 <__func__.5051+0xbd7>
    51e4:	be 01 00 00 00       	mov    $0x1,%esi
    51e9:	48 8b 3b             	mov    (%rbx),%rdi
    51ec:	48 8d 15 13 2a 00 00 	lea    0x2a13(%rip),%rdx        # 7c06 <__func__.5051+0xc06>
    51f3:	e8 98 d2 ff ff       	callq  2490 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    51f8:	49 63 ed             	movslq %r13d,%rbp
    51fb:	48 6b ed 38          	imul   $0x38,%rbp,%rbp
    51ff:	4c 01 e5             	add    %r12,%rbp
    5202:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
    5207:	0f 84 c8 00 00 00    	je     52d5 <cmd_print_long_help+0x141>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    520d:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
    5212:	48 89 ee             	mov    %rbp,%rsi
    5215:	4c 89 c7             	mov    %r8,%rdi
    5218:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    521d:	e8 12 fa ff ff       	callq  4c34 <cmd_gen_switch_syntax.constprop.0>
    5222:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    5227:	48 8b 3b             	mov    (%rbx),%rdi
    522a:	31 c0                	xor    %eax,%eax
    522c:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    5231:	48 8d 15 d9 29 00 00 	lea    0x29d9(%rip),%rdx        # 7c11 <__func__.5051+0xc11>
    5238:	be 01 00 00 00       	mov    $0x1,%esi
    523d:	e8 4e d2 ff ff       	callq  2490 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    5242:	4c 8b 75 30          	mov    0x30(%rbp),%r14
		total_to_print = strlen(toprint);
    5246:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    524a:	48 8d 15 c7 29 00 00 	lea    0x29c7(%rip),%rdx        # 7c18 <__func__.5051+0xc18>
    5251:	41 89 c0             	mov    %eax,%r8d
    5254:	31 c0                	xor    %eax,%eax
    5256:	be 01 00 00 00       	mov    $0x1,%esi
    525b:	4c 89 f7             	mov    %r14,%rdi
    525e:	f2 ae                	repnz scas %es:(%rdi),%al
    5260:	48 8b 3b             	mov    (%rbx),%rdi
    5263:	48 f7 d1             	not    %rcx
    5266:	8d 41 ff             	lea    -0x1(%rcx),%eax
		ret = fprintf(stdout, "%.*s\n",
    5269:	b9 64 00 00 00       	mov    $0x64,%ecx
		total_to_print = strlen(toprint);
    526e:	89 44 24 08          	mov    %eax,0x8(%rsp)
		ret = fprintf(stdout, "%.*s\n",
    5272:	44 29 c1             	sub    %r8d,%ecx
    5275:	31 c0                	xor    %eax,%eax
    5277:	4d 89 f0             	mov    %r14,%r8
    527a:	e8 11 d2 ff ff       	callq  2490 <__fprintf_chk@plt>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    527f:	8d 68 ff             	lea    -0x1(%rax),%ebp

		while (printed_right < total_to_print) {
    5282:	3b 6c 24 08          	cmp    0x8(%rsp),%ebp
    5286:	7d 45                	jge    52cd <cmd_print_long_help+0x139>
    5288:	48 8b 3b             	mov    (%rbx),%rdi
    528b:	4d 89 f8             	mov    %r15,%r8
    528e:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    5293:	be 01 00 00 00       	mov    $0x1,%esi
    5298:	48 8d 15 7f 29 00 00 	lea    0x297f(%rip),%rdx        # 7c1e <__func__.5051+0xc1e>
    529f:	31 c0                	xor    %eax,%eax
    52a1:	e8 ea d1 ff ff       	callq  2490 <__fprintf_chk@plt>
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    52a6:	4c 63 c5             	movslq %ebp,%r8
    52a9:	48 8b 3b             	mov    (%rbx),%rdi
    52ac:	b9 46 00 00 00       	mov    $0x46,%ecx
    52b1:	4d 01 f0             	add    %r14,%r8
    52b4:	48 8d 15 5d 29 00 00 	lea    0x295d(%rip),%rdx        # 7c18 <__func__.5051+0xc18>
    52bb:	be 01 00 00 00       	mov    $0x1,%esi
    52c0:	31 c0                	xor    %eax,%eax
    52c2:	e8 c9 d1 ff ff       	callq  2490 <__fprintf_chk@plt>
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    52c7:	8d 6c 05 ff          	lea    -0x1(%rbp,%rax,1),%ebp
    52cb:	eb b5                	jmp    5282 <cmd_print_long_help+0xee>
		}
		count++;
    52cd:	41 ff c5             	inc    %r13d
    52d0:	e9 23 ff ff ff       	jmpq   51f8 <cmd_print_long_help+0x64>
    52d5:	48 8b 3b             	mov    (%rbx),%rdi
    52d8:	48 8d 15 91 29 00 00 	lea    0x2991(%rip),%rdx        # 7c70 <__func__.5051+0xc70>
    52df:	be 01 00 00 00       	mov    $0x1,%esi
    52e4:	31 c0                	xor    %eax,%eax
    52e6:	e8 a5 d1 ff ff       	callq  2490 <__fprintf_chk@plt>
    52eb:	48 8b 3b             	mov    (%rbx),%rdi
    52ee:	31 c0                	xor    %eax,%eax
    52f0:	be 01 00 00 00       	mov    $0x1,%esi
    52f5:	48 8d 15 26 29 00 00 	lea    0x2926(%rip),%rdx        # 7c22 <__func__.5051+0xc22>
    52fc:	e8 8f d1 ff ff       	callq  2490 <__fprintf_chk@plt>
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    5301:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    5306:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    530d:	00 00 
    530f:	74 05                	je     5316 <cmd_print_long_help+0x182>
    5311:	e8 5a d0 ff ff       	callq  2370 <__stack_chk_fail@plt>
    5316:	48 83 c4 68          	add    $0x68,%rsp
    531a:	5b                   	pop    %rbx
    531b:	5d                   	pop    %rbp
    531c:	41 5c                	pop    %r12
    531e:	41 5d                	pop    %r13
    5320:	41 5e                	pop    %r14
    5322:	41 5f                	pop    %r15
    5324:	c3                   	retq   

0000000000005325 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    5325:	f3 0f 1e fa          	endbr64 
    5329:	41 56                	push   %r14
    532b:	41 55                	push   %r13
    532d:	49 89 f5             	mov    %rsi,%r13
    5330:	41 54                	push   %r12
    5332:	55                   	push   %rbp
    5333:	48 89 fd             	mov    %rdi,%rbp
    5336:	53                   	push   %rbx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    5337:	e8 8a fa ff ff       	callq  4dc6 <cmd_is_help_option>
    533c:	85 c0                	test   %eax,%eax
    533e:	74 0f                	je     534f <cmd_parse_one_arg+0x2a>
		cmd_print_long_help(args_struct);
    5340:	4c 89 ef             	mov    %r13,%rdi
    5343:	e8 4c fe ff ff       	callq  5194 <cmd_print_long_help>
		posix_exit(0);
    5348:	31 ff                	xor    %edi,%edi
    534a:	e8 62 f5 ff ff       	callq  48b1 <posix_exit>
{
    534f:	45 31 f6             	xor    %r14d,%r14d
	}

	while (args_struct[count].option != NULL) {
    5352:	49 63 de             	movslq %r14d,%rbx
    5355:	48 6b db 38          	imul   $0x38,%rbx,%rbx
    5359:	4c 01 eb             	add    %r13,%rbx
    535c:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    5360:	48 85 f6             	test   %rsi,%rsi
    5363:	74 78                	je     53dd <cmd_parse_one_arg+0xb8>
		if (args_struct[count].manual) {
    5365:	80 3b 00             	cmpb   $0x0,(%rbx)
    5368:	75 6b                	jne    53d5 <cmd_parse_one_arg+0xb0>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
				    !args_struct[count].is_switch);
    536a:	8a 53 02             	mov    0x2(%rbx),%dl
		ret = cmd_is_option(argv, args_struct[count].option,
    536d:	48 89 ef             	mov    %rbp,%rdi
				    !args_struct[count].is_switch);
    5370:	83 f2 01             	xor    $0x1,%edx
		ret = cmd_is_option(argv, args_struct[count].option,
    5373:	0f b6 d2             	movzbl %dl,%edx
    5376:	e8 9d f9 ff ff       	callq  4d18 <cmd_is_option>
    537b:	41 89 c4             	mov    %eax,%r12d
		if (ret) {
    537e:	85 c0                	test   %eax,%eax
    5380:	74 53                	je     53d5 <cmd_parse_one_arg+0xb0>
	if (arg_element->dest != NULL) {
    5382:	48 8b 73 20          	mov    0x20(%rbx),%rsi
    5386:	48 85 f6             	test   %rsi,%rsi
    5389:	74 33                	je     53be <cmd_parse_one_arg+0x99>
		if (arg_element->is_switch) {
    538b:	80 7b 02 00          	cmpb   $0x0,0x2(%rbx)
    538f:	0f be 53 18          	movsbl 0x18(%rbx),%edx
    5393:	74 1a                	je     53af <cmd_parse_one_arg+0x8a>
			if (arg_element->type == 'b') {
    5395:	80 fa 62             	cmp    $0x62,%dl
    5398:	75 05                	jne    539f <cmd_parse_one_arg+0x7a>
				*(bool *)arg_element->dest = true;
    539a:	c6 06 01             	movb   $0x1,(%rsi)
    539d:	eb 1f                	jmp    53be <cmd_parse_one_arg+0x99>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    539f:	48 8d 3d cc 28 00 00 	lea    0x28cc(%rip),%rdi        # 7c72 <__func__.5051+0xc72>
    53a6:	31 c0                	xor    %eax,%eax
    53a8:	e8 00 f6 ff ff       	callq  49ad <posix_print_error_and_exit>
    53ad:	eb 0f                	jmp    53be <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
    53af:	48 63 f8             	movslq %eax,%rdi
    53b2:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    53b6:	48 01 ef             	add    %rbp,%rdi
    53b9:	e8 75 fa ff ff       	callq  4e33 <cmd_read_option_value>
	if (arg_element->call_when_found) {
    53be:	48 8b 53 28          	mov    0x28(%rbx),%rdx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    53c2:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    53c4:	48 85 d2             	test   %rdx,%rdx
    53c7:	74 16                	je     53df <cmd_parse_one_arg+0xba>
		arg_element->call_when_found(argv, offset);
    53c9:	44 89 e6             	mov    %r12d,%esi
    53cc:	48 89 ef             	mov    %rbp,%rdi
    53cf:	ff d2                	callq  *%rdx
			return true;
    53d1:	b0 01                	mov    $0x1,%al
    53d3:	eb 0a                	jmp    53df <cmd_parse_one_arg+0xba>
    53d5:	41 ff c6             	inc    %r14d
    53d8:	e9 75 ff ff ff       	jmpq   5352 <cmd_parse_one_arg+0x2d>
		}
		count++;
	}
	return false;
    53dd:	31 c0                	xor    %eax,%eax
}
    53df:	5b                   	pop    %rbx
    53e0:	5d                   	pop    %rbp
    53e1:	41 5c                	pop    %r12
    53e3:	41 5d                	pop    %r13
    53e5:	41 5e                	pop    %r14
    53e7:	c3                   	retq   

00000000000053e8 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
    53e8:	f3 0f 1e fa          	endbr64 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    53ec:	48 8b 3d 45 63 00 00 	mov    0x6345(%rip),%rdi        # b738 <args_struct>
    53f3:	48 85 ff             	test   %rdi,%rdi
    53f6:	74 13                	je     540b <native_cleanup_cmd_line+0x23>
{
    53f8:	50                   	push   %rax
		free(args_struct);
    53f9:	e8 a2 ce ff ff       	callq  22a0 <free@plt>
		args_struct = NULL;
    53fe:	48 c7 05 2f 63 00 00 	movq   $0x0,0x632f(%rip)        # b738 <args_struct>
    5405:	00 00 00 00 
	}
}
    5409:	5a                   	pop    %rdx
    540a:	c3                   	retq   
    540b:	c3                   	retq   

000000000000540c <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    540c:	f3 0f 1e fa          	endbr64 
    5410:	41 54                	push   %r12
    5412:	55                   	push   %rbp
    5413:	48 89 fd             	mov    %rdi,%rbp
    5416:	53                   	push   %rbx
	int count = 0;
    5417:	31 db                	xor    %ebx,%ebx

	while (args[count].option != NULL) {
    5419:	48 63 c3             	movslq %ebx,%rax
    541c:	ff c3                	inc    %ebx
    541e:	48 6b c0 38          	imul   $0x38,%rax,%rax
    5422:	48 83 7c 05 08 00    	cmpq   $0x0,0x8(%rbp,%rax,1)
    5428:	75 ef                	jne    5419 <native_add_command_line_opts+0xd>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    542a:	8b 15 64 63 00 00    	mov    0x6364(%rip),%edx        # b794 <used_args>
    5430:	8b 05 5a 63 00 00    	mov    0x635a(%rip),%eax        # b790 <args_aval>
    5436:	01 da                	add    %ebx,%edx
    5438:	39 c2                	cmp    %eax,%edx
    543a:	7c 44                	jl     5480 <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    543c:	83 fb 14             	cmp    $0x14,%ebx
    543f:	41 bc 14 00 00 00    	mov    $0x14,%r12d
		struct args_struct_t *new_args_struct = realloc(args_struct,
    5445:	48 8b 3d ec 62 00 00 	mov    0x62ec(%rip),%rdi        # b738 <args_struct>
				      (args_aval + growby)*
    544c:	44 0f 4d e3          	cmovge %ebx,%r12d
    5450:	41 01 c4             	add    %eax,%r12d
    5453:	49 63 f4             	movslq %r12d,%rsi
		struct args_struct_t *new_args_struct = realloc(args_struct,
    5456:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    545a:	e8 d1 cf ff ff       	callq  2430 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    545f:	44 89 25 2a 63 00 00 	mov    %r12d,0x632a(%rip)        # b790 <args_aval>
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    5466:	48 85 c0             	test   %rax,%rax
    5469:	75 0e                	jne    5479 <native_add_command_line_opts+0x6d>
			posix_print_error_and_exit("Could not allocate memory");
    546b:	48 8d 3d 4b 28 00 00 	lea    0x284b(%rip),%rdi        # 7cbd <__func__.5051+0xcbd>
    5472:	e8 36 f5 ff ff       	callq  49ad <posix_print_error_and_exit>
    5477:	eb 07                	jmp    5480 <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
    5479:	48 89 05 b8 62 00 00 	mov    %rax,0x62b8(%rip)        # b738 <args_struct>
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    5480:	48 63 05 0d 63 00 00 	movslq 0x630d(%rip),%rax        # b794 <used_args>
    5487:	48 63 cb             	movslq %ebx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    548a:	48 89 ee             	mov    %rbp,%rsi
    548d:	48 6b c9 38          	imul   $0x38,%rcx,%rcx
    5491:	48 89 c2             	mov    %rax,%rdx
    5494:	48 6b c0 38          	imul   $0x38,%rax,%rax
    5498:	48 03 05 99 62 00 00 	add    0x6299(%rip),%rax        # b738 <args_struct>
    549f:	48 89 c7             	mov    %rax,%rdi
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    54a2:	8d 44 1a ff          	lea    -0x1(%rdx,%rbx,1),%eax
    54a6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    54a8:	89 05 e6 62 00 00    	mov    %eax,0x62e6(%rip)        # b794 <used_args>
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    54ae:	5b                   	pop    %rbx
    54af:	5d                   	pop    %rbp
    54b0:	41 5c                	pop    %r12
    54b2:	c3                   	retq   

00000000000054b3 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    54b3:	f3 0f 1e fa          	endbr64 
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    54b7:	48 8d 3d e2 4d 00 00 	lea    0x4de2(%rip),%rdi        # a2a0 <testargs_options.2552>
    54be:	e9 49 ff ff ff       	jmpq   540c <native_add_command_line_opts>

00000000000054c3 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    54c3:	f3 0f 1e fa          	endbr64 
    54c7:	41 57                	push   %r15

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    54c9:	4c 8d 3d 07 28 00 00 	lea    0x2807(%rip),%r15        # 7cd7 <__func__.5051+0xcd7>
{
    54d0:	41 56                	push   %r14
    54d2:	41 55                	push   %r13
    54d4:	41 54                	push   %r12
    54d6:	49 89 f4             	mov    %rsi,%r12
    54d9:	55                   	push   %rbp
	for (i = 1; i < argc; i++) {
    54da:	bd 01 00 00 00       	mov    $0x1,%ebp
{
    54df:	53                   	push   %rbx
    54e0:	89 fb                	mov    %edi,%ebx
    54e2:	52                   	push   %rdx
	native_add_tracing_options();
    54e3:	e8 3c f7 ff ff       	callq  4c24 <native_add_tracing_options>
	native_add_testargs_option();
    54e8:	e8 c6 ff ff ff       	callq  54b3 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    54ed:	48 8b 3d 44 62 00 00 	mov    0x6244(%rip),%rdi        # b738 <args_struct>
	s_argv = argv;
    54f4:	4c 89 25 4d 62 00 00 	mov    %r12,0x624d(%rip)        # b748 <s_argv>
	s_argc = argc;
    54fb:	89 1d 9b 62 00 00    	mov    %ebx,0x629b(%rip)        # b79c <s_argc>
	cmd_args_set_defaults(args_struct);
    5501:	e8 bf fa ff ff       	callq  4fc5 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
    5506:	41 89 ee             	mov    %ebp,%r14d
    5509:	39 eb                	cmp    %ebp,%ebx
    550b:	7e 65                	jle    5572 <native_handle_cmd_line+0xaf>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
    550d:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    5511:	31 d2                	xor    %edx,%edx
    5513:	4c 89 fe             	mov    %r15,%rsi
    5516:	4c 8d 6d 01          	lea    0x1(%rbp),%r13
    551a:	e8 f9 f7 ff ff       	callq  4d18 <cmd_is_option>
    551f:	85 c0                	test   %eax,%eax
    5521:	74 18                	je     553b <native_handle_cmd_line+0x78>
			test_argc = argc - i - 1;
    5523:	ff cb                	dec    %ebx
			test_argv = &argv[i+1];
    5525:	4b 8d 04 ec          	lea    (%r12,%r13,8),%rax
			test_argc = argc - i - 1;
    5529:	44 29 f3             	sub    %r14d,%ebx
			test_argv = &argv[i+1];
    552c:	48 89 05 0d 62 00 00 	mov    %rax,0x620d(%rip)        # b740 <test_argv>
			test_argc = argc - i - 1;
    5533:	89 1d 5f 62 00 00    	mov    %ebx,0x625f(%rip)        # b798 <test_argc>
			break;
    5539:	eb 37                	jmp    5572 <native_handle_cmd_line+0xaf>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    553b:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    553f:	48 8b 35 f2 61 00 00 	mov    0x61f2(%rip),%rsi        # b738 <args_struct>
    5546:	e8 da fd ff ff       	callq  5325 <cmd_parse_one_arg>
    554b:	84 c0                	test   %al,%al
    554d:	75 1e                	jne    556d <native_handle_cmd_line+0xaa>
			cmd_print_switches_help(args_struct);
    554f:	48 8b 3d e2 61 00 00 	mov    0x61e2(%rip),%rdi        # b738 <args_struct>
    5556:	e8 2f fb ff ff       	callq  508a <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    555b:	49 8b 34 ec          	mov    (%r12,%rbp,8),%rsi
    555f:	48 8d 3d 7a 27 00 00 	lea    0x277a(%rip),%rdi        # 7ce0 <__func__.5051+0xce0>
    5566:	31 c0                	xor    %eax,%eax
    5568:	e8 40 f4 ff ff       	callq  49ad <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
    556d:	4c 89 ed             	mov    %r13,%rbp
    5570:	eb 94                	jmp    5506 <native_handle_cmd_line+0x43>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    5572:	58                   	pop    %rax
    5573:	5b                   	pop    %rbx
    5574:	5d                   	pop    %rbp
    5575:	41 5c                	pop    %r12
    5577:	41 5d                	pop    %r13
    5579:	41 5e                	pop    %r14
    557b:	41 5f                	pop    %r15
    557d:	c3                   	retq   

000000000000557e <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
    557e:	f3 0f 1e fa          	endbr64 
	hw_counter_timer = NEVER;
    5582:	48 8d 05 df 61 00 00 	lea    0x61df(%rip),%rax        # b768 <hw_counter_timer>
	counter_target = NEVER;
	counter_value = 0;
	counter_running = false;
    5589:	c6 05 22 62 00 00 00 	movb   $0x0,0x6222(%rip)        # b7b2 <counter_running>
	counter_target = NEVER;
    5590:	48 c7 05 bd 61 00 00 	movq   $0xffffffffffffffff,0x61bd(%rip)        # b758 <counter_target>
    5597:	ff ff ff ff 
	hw_counter_timer = NEVER;
    559b:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	counter_value = 0;
    55a2:	48 c7 05 b3 61 00 00 	movq   $0x0,0x61b3(%rip)        # b760 <counter_value>
    55a9:	00 00 00 00 
	counter_period = NEVER;
    55ad:	48 c7 05 98 61 00 00 	movq   $0xffffffffffffffff,0x6198(%rip)        # b750 <counter_period>
    55b4:	ff ff ff ff 
}
    55b8:	c3                   	retq   

00000000000055b9 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
    55b9:	f3 0f 1e fa          	endbr64 
	if (!counter_running) {
    55bd:	80 3d ee 61 00 00 00 	cmpb   $0x0,0x61ee(%rip)        # b7b2 <counter_running>
{
    55c4:	53                   	push   %rbx
    55c5:	48 8d 1d 9c 61 00 00 	lea    0x619c(%rip),%rbx        # b768 <hw_counter_timer>
	if (!counter_running) {
    55cc:	75 09                	jne    55d7 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
    55ce:	48 c7 03 ff ff ff ff 	movq   $0xffffffffffffffff,(%rbx)
		return;
    55d5:	eb 34                	jmp    560b <hw_counter_triggered+0x52>
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    55d7:	e8 da e9 ff ff       	callq  3fb6 <hwm_get_time>
    55dc:	48 03 05 6d 61 00 00 	add    0x616d(%rip),%rax        # b750 <counter_period>
    55e3:	48 89 03             	mov    %rax,(%rbx)
	counter_value = counter_value + 1;
    55e6:	48 8b 05 73 61 00 00 	mov    0x6173(%rip),%rax        # b760 <counter_value>
    55ed:	48 ff c0             	inc    %rax

	if (counter_value == counter_target) {
    55f0:	48 3b 05 61 61 00 00 	cmp    0x6161(%rip),%rax        # b758 <counter_target>
	counter_value = counter_value + 1;
    55f7:	48 89 05 62 61 00 00 	mov    %rax,0x6162(%rip)        # b760 <counter_value>
	if (counter_value == counter_target) {
    55fe:	75 0b                	jne    560b <hw_counter_triggered+0x52>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    5600:	bf 02 00 00 00       	mov    $0x2,%edi
	}
}
    5605:	5b                   	pop    %rbx
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    5606:	e9 19 f2 ff ff       	jmpq   4824 <hw_irq_ctrl_set_irq>
}
    560b:	5b                   	pop    %rbx
    560c:	c3                   	retq   

000000000000560d <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    560d:	f3 0f 1e fa          	endbr64 
    5611:	50                   	push   %rax
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    5612:	48 8d 05 9a 61 00 00 	lea    0x619a(%rip),%rax        # b7b3 <z_sys_post_kernel>

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    5619:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
    561e:	c6 00 01             	movb   $0x1,(%rax)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    5621:	e8 b9 0c 00 00       	callq  62df <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    5626:	e8 5d 09 00 00       	callq  5f88 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    562b:	bf 03 00 00 00       	mov    $0x3,%edi
    5630:	e8 aa 0c 00 00       	callq  62df <z_sys_init_run_level>

	z_init_static_threads();
    5635:	e8 58 08 00 00       	callq  5e92 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    563a:	e8 06 d0 ff ff       	callq  2645 <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    563f:	48 8d 05 7a 5f 00 00 	lea    0x5f7a(%rip),%rax        # b5c0 <z_main_thread>
    5646:	80 60 18 fe          	andb   $0xfe,0x18(%rax)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    564a:	5a                   	pop    %rdx
    564b:	c3                   	retq   

000000000000564c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    564c:	f3 0f 1e fa          	endbr64 
    5650:	41 55                	push   %r13
#endif
#if defined(CONFIG_MMU) && defined(CONFIG_USERSPACE)
	z_kernel_map_fixup();
#endif
	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    5652:	31 ff                	xor    %edi,%edi
{
    5654:	41 54                	push   %r12
    5656:	55                   	push   %rbp
    5657:	53                   	push   %rbx
    5658:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    565f:	48 8d 1d fa 5f 00 00 	lea    0x5ffa(%rip),%rbx        # b660 <_kernel>
    5666:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    566d:	00 00 
    566f:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    5676:	00 
    5677:	31 c0                	xor    %eax,%eax
    5679:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
	dummy_thread->base.user_options = K_ESSENTIAL;
    567e:	66 c7 44 24 20 01 01 	movw   $0x101,0x20(%rsp)
	_current_cpu->current = dummy_thread;
    5685:	48 89 43 10          	mov    %rax,0x10(%rbx)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    5689:	e8 51 0c 00 00       	callq  62df <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    568e:	bf 01 00 00 00       	mov    $0x1,%edi
    5693:	e8 47 0c 00 00       	callq  62df <z_sys_init_run_level>
	z_sched_init();
    5698:	e8 ef 06 00 00       	callq  5d8c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    569d:	45 31 c9             	xor    %r9d,%r9d
    56a0:	45 31 c0             	xor    %r8d,%r8d
    56a3:	ba 00 04 00 00       	mov    $0x400,%edx
	_kernel.ready_q.cache = &z_main_thread;
    56a8:	48 8d 2d 11 5f 00 00 	lea    0x5f11(%rip),%rbp        # b5c0 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    56af:	48 8d 05 e6 26 00 00 	lea    0x26e6(%rip),%rax        # 7d9c <__func__.5051+0xd9c>
    56b6:	48 8d 35 a3 4d 00 00 	lea    0x4da3(%rip),%rsi        # a460 <z_main_stack>
    56bd:	48 8d 0d 49 ff ff ff 	lea    -0xb7(%rip),%rcx        # 560d <bg_thread_main>
	_kernel.ready_q.cache = &z_main_thread;
    56c4:	48 89 6b 40          	mov    %rbp,0x40(%rbx)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    56c8:	48 89 ef             	mov    %rbp,%rdi
    56cb:	50                   	push   %rax
    56cc:	6a 01                	pushq  $0x1
    56ce:	6a 00                	pushq  $0x0
    56d0:	6a 00                	pushq  $0x0
    56d2:	e8 11 07 00 00       	callq  5de8 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    56d7:	80 65 19 fb          	andb   $0xfb,0x19(%rbp)
    56db:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
    56df:	48 89 ef             	mov    %rbp,%rdi
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    56e2:	49 89 c5             	mov    %rax,%r13
	z_ready_thread(&z_main_thread);
    56e5:	e8 b7 04 00 00       	callq  5ba1 <z_ready_thread>
	z_setup_new_thread(thread, stack,
    56ea:	6a 00                	pushq  $0x0
    56ec:	45 31 c9             	xor    %r9d,%r9d
    56ef:	49 89 d8             	mov    %rbx,%r8
    56f2:	6a 01                	pushq  $0x1
    56f4:	4c 8d 25 25 5e 00 00 	lea    0x5e25(%rip),%r12        # b520 <z_idle_threads>
    56fb:	ba 00 01 00 00       	mov    $0x100,%edx
    5700:	48 8d 35 59 4c 00 00 	lea    0x4c59(%rip),%rsi        # a360 <__TMC_END__>
    5707:	6a 0f                	pushq  $0xf
    5709:	48 8d 0d 39 0c 00 00 	lea    0xc39(%rip),%rcx        # 6349 <idle>
    5710:	6a 00                	pushq  $0x0
    5712:	4c 89 e7             	mov    %r12,%rdi
    5715:	e8 ce 06 00 00       	callq  5de8 <z_setup_new_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    571a:	4c 89 63 18          	mov    %r12,0x18(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    571e:	4c 89 ee             	mov    %r13,%rsi
    5721:	48 89 ef             	mov    %rbp,%rdi
		_kernel.cpus[i].irq_stack =
    5724:	48 8d 05 35 51 00 00 	lea    0x5135(%rip),%rax        # a860 <z_interrupt_stacks>
		_kernel.cpus[i].id = i;
    572b:	c6 43 2c 00          	movb   $0x0,0x2c(%rbx)
	z_setup_new_thread(thread, stack,
    572f:	48 83 c4 20          	add    $0x20,%rsp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5733:	48 8d 15 d3 fe ff ff 	lea    -0x12d(%rip),%rdx        # 560d <bg_thread_main>
    573a:	41 80 64 24 19 fb    	andb   $0xfb,0x19(%r12)
		_kernel.cpus[i].irq_stack =
    5740:	48 05 00 08 00 00    	add    $0x800,%rax
    5746:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    574a:	48 8d 43 30          	lea    0x30(%rbx),%rax
    574e:	48 89 43 30          	mov    %rax,0x30(%rbx)
	list->tail = (sys_dnode_t *)list;
    5752:	48 89 43 38          	mov    %rax,0x38(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5756:	e8 43 e3 ff ff       	callq  3a9e <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    575b:	ba 27 01 00 00       	mov    $0x127,%edx
    5760:	48 8d 35 3a 26 00 00 	lea    0x263a(%rip),%rsi        # 7da1 <__func__.5051+0xda1>
    5767:	31 c0                	xor    %eax,%eax
    5769:	48 8d 3d 41 1a 00 00 	lea    0x1a41(%rip),%rdi        # 71b1 <__func__.5051+0x1b1>
    5770:	e8 38 f2 ff ff       	callq  49ad <posix_print_error_and_exit>

0000000000005775 <z_is_t1_higher_prio_than_t2>:
}
#endif

bool z_is_t1_higher_prio_than_t2(struct k_thread *thread_1,
				 struct k_thread *thread_2)
{
    5775:	f3 0f 1e fa          	endbr64 
	if (thread_1->base.prio < thread_2->base.prio) {
    5779:	8a 46 1a             	mov    0x1a(%rsi),%al
    577c:	38 47 1a             	cmp    %al,0x1a(%rdi)
    577f:	0f 9c c0             	setl   %al
		return (d2 - d1) >= 0;
	}
#endif

	return false;
}
    5782:	c3                   	retq   

0000000000005783 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    5783:	f3 0f 1e fa          	endbr64 
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    5787:	83 3d 16 60 00 00 00 	cmpl   $0x0,0x6016(%rip)        # b7a4 <slice_time>
    578e:	74 20                	je     57b0 <z_reset_time_slice+0x2d>
{
    5790:	50                   	push   %rax
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    5791:	e8 e1 dd ff ff       	callq  3577 <z_clock_elapsed>
    5796:	8b 3d 08 60 00 00    	mov    0x6008(%rip),%edi        # b7a4 <slice_time>
    579c:	48 8d 15 bd 5e 00 00 	lea    0x5ebd(%rip),%rdx        # b660 <_kernel>
		z_set_timeout_expiry(slice_time, false);
    57a3:	31 f6                	xor    %esi,%esi
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    57a5:	01 f8                	add    %edi,%eax
    57a7:	89 42 28             	mov    %eax,0x28(%rdx)
	}
}
    57aa:	5a                   	pop    %rdx
		z_set_timeout_expiry(slice_time, false);
    57ab:	e9 29 0a 00 00       	jmpq   61d9 <z_set_timeout_expiry>
    57b0:	c3                   	retq   

00000000000057b1 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    57b1:	f3 0f 1e fa          	endbr64 
    57b5:	41 54                	push   %r12
    57b7:	41 89 f4             	mov    %esi,%r12d
    57ba:	55                   	push   %rbp
    57bb:	53                   	push   %rbx
    57bc:	89 fb                	mov    %edi,%ebx
	return posix_irq_lock();
    57be:	e8 53 ee ff ff       	callq  4616 <posix_irq_lock>
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
    57c3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    57c8:	89 c5                	mov    %eax,%ebp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    57ca:	48 8d 05 8f 5e 00 00 	lea    0x5e8f(%rip),%rax        # b660 <_kernel>
    57d1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    57d8:	89 d8                	mov    %ebx,%eax
		t += off;
    57da:	48 83 c0 09          	add    $0x9,%rax
		if (result32 && (t < BIT64(32))) {
    57de:	48 39 d0             	cmp    %rdx,%rax
    57e1:	77 0e                	ja     57f1 <k_sched_time_slice_set+0x40>
			return ((uint32_t)t) / (from_hz / to_hz);
    57e3:	8d 43 09             	lea    0x9(%rbx),%eax
    57e6:	b9 0a 00 00 00       	mov    $0xa,%ecx
    57eb:	31 d2                	xor    %edx,%edx
    57ed:	f7 f1                	div    %ecx
    57ef:	eb 0a                	jmp    57fb <k_sched_time_slice_set+0x4a>
			return t / (from_hz / to_hz);
    57f1:	b9 0a 00 00 00       	mov    $0xa,%ecx
    57f6:	31 d2                	xor    %edx,%edx
    57f8:	48 f7 f1             	div    %rcx
		slice_time = k_ms_to_ticks_ceil32(slice);
		slice_max_prio = prio;
    57fb:	44 89 25 9e 5f 00 00 	mov    %r12d,0x5f9e(%rip)        # b7a0 <slice_max_prio>
		slice_time = k_ms_to_ticks_ceil32(slice);
    5802:	89 05 9c 5f 00 00    	mov    %eax,0x5f9c(%rip)        # b7a4 <slice_time>
		z_reset_time_slice();
    5808:	e8 76 ff ff ff       	callq  5783 <z_reset_time_slice>
	}
}
    580d:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    580e:	89 ef                	mov    %ebp,%edi
    5810:	5d                   	pop    %rbp
    5811:	41 5c                	pop    %r12
    5813:	e9 0c ee ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000005818 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    5818:	f3 0f 1e fa          	endbr64 
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    581c:	48 8d 05 3d 5e 00 00 	lea    0x5e3d(%rip),%rax        # b660 <_kernel>
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    5823:	89 f2                	mov    %esi,%edx
{
    5825:	89 f7                	mov    %esi,%edi
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    5827:	0b 10                	or     (%rax),%edx
    5829:	75 11                	jne    583c <z_reschedule+0x24>
	if (resched(key.key) && need_swap()) {
    582b:	48 8b 48 10          	mov    0x10(%rax),%rcx
    582f:	48 39 48 40          	cmp    %rcx,0x40(%rax)
    5833:	74 07                	je     583c <z_reschedule+0x24>
	ret = arch_swap(key);
    5835:	31 ff                	xor    %edi,%edi
    5837:	e9 18 e2 ff ff       	jmpq   3a54 <arch_swap>
    583c:	e9 e3 ed ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000005841 <z_reschedule_irqlock>:
		k_spin_unlock(lock, key);
	}
}

void z_reschedule_irqlock(uint32_t key)
{
    5841:	f3 0f 1e fa          	endbr64 
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    5845:	48 8d 05 14 5e 00 00 	lea    0x5e14(%rip),%rax        # b660 <_kernel>
    584c:	89 fa                	mov    %edi,%edx
    584e:	0b 10                	or     (%rax),%edx
    5850:	75 07                	jne    5859 <z_reschedule_irqlock+0x18>
    5852:	31 ff                	xor    %edi,%edi
    5854:	e9 fb e1 ff ff       	jmpq   3a54 <arch_swap>
    5859:	e9 c6 ed ff ff       	jmpq   4624 <posix_irq_unlock>

000000000000585e <z_reschedule_unlocked>:
{
    585e:	50                   	push   %rax
	return posix_irq_lock();
    585f:	e8 b2 ed ff ff       	callq  4616 <posix_irq_lock>
}
    5864:	5a                   	pop    %rdx
    5865:	89 c7                	mov    %eax,%edi
	(void) z_reschedule_irqlock(arch_irq_lock());
    5867:	e9 d5 ff ff ff       	jmpq   5841 <z_reschedule_irqlock>

000000000000586c <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
    586c:	f3 0f 1e fa          	endbr64 
    5870:	50                   	push   %rax
    5871:	e8 a0 ed ff ff       	callq  4616 <posix_irq_lock>
    5876:	89 c7                	mov    %eax,%edi
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    5878:	48 8d 05 e1 5d 00 00 	lea    0x5de1(%rip),%rax        # b660 <_kernel>
    587f:	48 8b 40 10          	mov    0x10(%rax),%rax
    5883:	fe 48 1b             	decb   0x1b(%rax)
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    5886:	5a                   	pop    %rdx
	posix_irq_unlock(key);
    5887:	e9 98 ed ff ff       	jmpq   4624 <posix_irq_unlock>

000000000000588c <z_priq_dumb_remove>:

	sys_dlist_append(pq, &thread->base.qnode_dlist);
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    588c:	f3 0f 1e fa          	endbr64 
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    5890:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    5894:	48 8b 06             	mov    (%rsi),%rax
    5897:	48 89 02             	mov    %rax,(%rdx)
	node->next->prev = node->prev;
    589a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    589e:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	node->prev = NULL;
    58a5:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
    58ac:	00 
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    58ad:	c3                   	retq   

00000000000058ae <unpend_thread_no_timeout>:
{
    58ae:	53                   	push   %rbx
    58af:	48 89 fb             	mov    %rdi,%rbx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
    58b2:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    58b6:	48 89 de             	mov    %rbx,%rsi
    58b9:	e8 ce ff ff ff       	callq  588c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    58be:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
    58c2:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    58c9:	00 
}
    58ca:	5b                   	pop    %rbx
    58cb:	c3                   	retq   

00000000000058cc <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    58cc:	f3 0f 1e fa          	endbr64 
	return list->head == list;
    58d0:	48 8b 07             	mov    (%rdi),%rax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
    58d3:	48 85 c0             	test   %rax,%rax
    58d6:	74 05                	je     58dd <z_priq_dumb_best+0x11>
    58d8:	48 39 c7             	cmp    %rax,%rdi
    58db:	75 02                	jne    58df <z_priq_dumb_best+0x13>
	struct k_thread *thread = NULL;
    58dd:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    58df:	c3                   	retq   

00000000000058e0 <update_cache>:
{
    58e0:	41 54                	push   %r12
    58e2:	41 89 fc             	mov    %edi,%r12d
    58e5:	55                   	push   %rbp
    58e6:	53                   	push   %rbx
	if (_current_cpu->pending_abort != NULL) {
    58e7:	48 8d 1d 72 5d 00 00 	lea    0x5d72(%rip),%rbx        # b660 <_kernel>
    58ee:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
    58f3:	75 22                	jne    5917 <update_cache+0x37>
	thread = _priq_run_best(&_kernel.ready_q.runq);
    58f5:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
    58f9:	e8 ce ff ff ff       	callq  58cc <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
    58fe:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	thread = _priq_run_best(&_kernel.ready_q.runq);
    5902:	48 89 c5             	mov    %rax,%rbp
	if (_current->base.thread_state & _THREAD_ABORTING) {
    5905:	8a 42 19             	mov    0x19(%rdx),%al
    5908:	a8 20                	test   $0x20,%al
    590a:	74 06                	je     5912 <update_cache+0x32>
		_current->base.thread_state |= _THREAD_DEAD;
    590c:	83 c8 08             	or     $0x8,%eax
    590f:	88 42 19             	mov    %al,0x19(%rdx)
	return thread ? thread : _current_cpu->idle_thread;
    5912:	48 85 ed             	test   %rbp,%rbp
    5915:	75 04                	jne    591b <update_cache+0x3b>
    5917:	48 8b 6b 18          	mov    0x18(%rbx),%rbp
	if (preempt_ok != 0) {
    591b:	48 8b 43 10          	mov    0x10(%rbx),%rax
    591f:	45 85 e4             	test   %r12d,%r12d
    5922:	75 13                	jne    5937 <update_cache+0x57>
	if (z_is_thread_prevented_from_running(_current)) {
    5924:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
    5928:	75 0d                	jne    5937 <update_cache+0x57>
	if (is_preempt(_current) || is_metairq(thread)) {
    592a:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
    592f:	76 06                	jbe    5937 <update_cache+0x57>
		_kernel.ready_q.cache = _current;
    5931:	48 89 43 40          	mov    %rax,0x40(%rbx)
    5935:	eb 0e                	jmp    5945 <update_cache+0x65>
		if (thread != _current) {
    5937:	48 39 c5             	cmp    %rax,%rbp
    593a:	74 05                	je     5941 <update_cache+0x61>
			z_reset_time_slice();
    593c:	e8 42 fe ff ff       	callq  5783 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    5941:	48 89 6b 40          	mov    %rbp,0x40(%rbx)
}
    5945:	5b                   	pop    %rbx
    5946:	5d                   	pop    %rbp
    5947:	41 5c                	pop    %r12
    5949:	c3                   	retq   

000000000000594a <z_impl_k_thread_suspend>:
{
    594a:	f3 0f 1e fa          	endbr64 
    594e:	41 54                	push   %r12
    5950:	55                   	push   %rbp
    5951:	53                   	push   %rbx
    5952:	48 89 fb             	mov    %rdi,%rbx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    5955:	48 83 c7 28          	add    $0x28,%rdi
    5959:	e8 0f 08 00 00       	callq  616d <z_abort_timeout>
	return posix_irq_lock();
    595e:	e8 b3 ec ff ff       	callq  4616 <posix_irq_lock>
    5963:	48 8d 2d f6 5c 00 00 	lea    0x5cf6(%rip),%rbp        # b660 <_kernel>
    596a:	41 89 c4             	mov    %eax,%r12d
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    596d:	8a 43 19             	mov    0x19(%rbx),%al
		if (z_is_thread_queued(thread)) {
    5970:	84 c0                	test   %al,%al
    5972:	79 12                	jns    5986 <z_impl_k_thread_suspend+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5974:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    5977:	48 89 de             	mov    %rbx,%rsi
    597a:	48 8d 7d 48          	lea    0x48(%rbp),%rdi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    597e:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    5981:	e8 06 ff ff ff       	callq  588c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    5986:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
    598a:	31 ff                	xor    %edi,%edi
    598c:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    5990:	40 0f 94 c7          	sete   %dil
    5994:	e8 47 ff ff ff       	callq  58e0 <update_cache>
	posix_irq_unlock(key);
    5999:	44 89 e7             	mov    %r12d,%edi
    599c:	e8 83 ec ff ff       	callq  4624 <posix_irq_unlock>
	if (thread == _current) {
    59a1:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    59a5:	75 09                	jne    59b0 <z_impl_k_thread_suspend+0x66>
}
    59a7:	5b                   	pop    %rbx
    59a8:	5d                   	pop    %rbp
    59a9:	41 5c                	pop    %r12
		z_reschedule_unlocked();
    59ab:	e9 ae fe ff ff       	jmpq   585e <z_reschedule_unlocked>
}
    59b0:	5b                   	pop    %rbx
    59b1:	5d                   	pop    %rbp
    59b2:	41 5c                	pop    %r12
    59b4:	c3                   	retq   

00000000000059b5 <k_sched_unlock>:
{
    59b5:	f3 0f 1e fa          	endbr64 
    59b9:	55                   	push   %rbp
	return posix_irq_lock();
    59ba:	e8 57 ec ff ff       	callq  4616 <posix_irq_lock>
		update_cache(0);
    59bf:	31 ff                	xor    %edi,%edi
    59c1:	89 c5                	mov    %eax,%ebp
		++_current->base.sched_locked;
    59c3:	48 8d 05 96 5c 00 00 	lea    0x5c96(%rip),%rax        # b660 <_kernel>
    59ca:	48 8b 40 10          	mov    0x10(%rax),%rax
    59ce:	fe 40 1b             	incb   0x1b(%rax)
		update_cache(0);
    59d1:	e8 0a ff ff ff       	callq  58e0 <update_cache>
	posix_irq_unlock(key);
    59d6:	89 ef                	mov    %ebp,%edi
    59d8:	e8 47 ec ff ff       	callq  4624 <posix_irq_unlock>
}
    59dd:	5d                   	pop    %rbp
	z_reschedule_unlocked();
    59de:	e9 7b fe ff ff       	jmpq   585e <z_reschedule_unlocked>

00000000000059e3 <move_thread_to_end_of_prio_q>:
{
    59e3:	41 54                	push   %r12
    59e5:	4c 8d 25 74 5c 00 00 	lea    0x5c74(%rip),%r12        # b660 <_kernel>
    59ec:	55                   	push   %rbp
    59ed:	53                   	push   %rbx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    59ee:	8a 47 19             	mov    0x19(%rdi),%al
    59f1:	48 89 fb             	mov    %rdi,%rbx
	if (z_is_thread_queued(thread)) {
    59f4:	84 c0                	test   %al,%al
    59f6:	79 13                	jns    5a0b <move_thread_to_end_of_prio_q+0x28>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    59f8:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    59fb:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    59fe:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    5a01:	49 8d 7c 24 48       	lea    0x48(%r12),%rdi
    5a06:	e8 81 fe ff ff       	callq  588c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    5a0b:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
    5a0f:	49 8b 6c 24 48       	mov    0x48(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5a14:	48 85 ed             	test   %rbp,%rbp
    5a17:	74 0a                	je     5a23 <move_thread_to_end_of_prio_q+0x40>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5a19:	49 8d 44 24 48       	lea    0x48(%r12),%rax
    5a1e:	48 39 c5             	cmp    %rax,%rbp
    5a21:	75 20                	jne    5a43 <move_thread_to_end_of_prio_q+0x60>
	node->next = list;
    5a23:	49 8d 44 24 48       	lea    0x48(%r12),%rax
    5a28:	48 89 03             	mov    %rax,(%rbx)
	node->prev = list->tail;
    5a2b:	49 8b 44 24 50       	mov    0x50(%r12),%rax
    5a30:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
    5a34:	49 8b 44 24 50       	mov    0x50(%r12),%rax
    5a39:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    5a3c:	49 89 5c 24 50       	mov    %rbx,0x50(%r12)
}
    5a41:	eb 33                	jmp    5a76 <move_thread_to_end_of_prio_q+0x93>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    5a43:	48 89 ee             	mov    %rbp,%rsi
    5a46:	48 89 df             	mov    %rbx,%rdi
    5a49:	e8 27 fd ff ff       	callq  5775 <z_is_t1_higher_prio_than_t2>
    5a4e:	84 c0                	test   %al,%al
    5a50:	74 14                	je     5a66 <move_thread_to_end_of_prio_q+0x83>
	node->prev = successor->prev;
    5a52:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    5a56:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
    5a59:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
    5a5d:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    5a60:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    5a64:	eb 10                	jmp    5a76 <move_thread_to_end_of_prio_q+0x93>
	return (node == list->tail) ? NULL : node->next;
    5a66:	49 39 6c 24 50       	cmp    %rbp,0x50(%r12)
    5a6b:	74 b6                	je     5a23 <move_thread_to_end_of_prio_q+0x40>
    5a6d:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5a71:	48 85 ed             	test   %rbp,%rbp
    5a74:	eb ab                	jmp    5a21 <move_thread_to_end_of_prio_q+0x3e>
	update_cache(thread == _current);
    5a76:	31 ff                	xor    %edi,%edi
    5a78:	49 39 5c 24 10       	cmp    %rbx,0x10(%r12)
}
    5a7d:	5b                   	pop    %rbx
	update_cache(thread == _current);
    5a7e:	40 0f 94 c7          	sete   %dil
}
    5a82:	5d                   	pop    %rbp
    5a83:	41 5c                	pop    %r12
	update_cache(thread == _current);
    5a85:	e9 56 fe ff ff       	jmpq   58e0 <update_cache>

0000000000005a8a <z_time_slice>:
{
    5a8a:	f3 0f 1e fa          	endbr64 
    5a8e:	55                   	push   %rbp
    5a8f:	53                   	push   %rbx
    5a90:	89 fb                	mov    %edi,%ebx
    5a92:	52                   	push   %rdx
	return posix_irq_lock();
    5a93:	e8 7e eb ff ff       	callq  4616 <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
    5a98:	83 3d 05 5d 00 00 00 	cmpl   $0x0,0x5d05(%rip)        # b7a4 <slice_time>
    5a9f:	89 c5                	mov    %eax,%ebp
    5aa1:	48 8d 05 b8 5b 00 00 	lea    0x5bb8(%rip),%rax        # b660 <_kernel>
    5aa8:	74 40                	je     5aea <z_time_slice+0x60>
    5aaa:	48 8b 78 10          	mov    0x10(%rax),%rdi
		&& !z_is_idle_thread_object(thread);
    5aae:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
    5ab3:	77 35                	ja     5aea <z_time_slice+0x60>
		&& !z_is_thread_prevented_from_running(thread)
    5ab5:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
    5ab9:	75 2f                	jne    5aea <z_time_slice+0x60>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    5abb:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
		&& !z_is_idle_thread_object(thread);
    5abf:	39 15 db 5c 00 00    	cmp    %edx,0x5cdb(%rip)        # b7a0 <slice_max_prio>
    5ac5:	7f 23                	jg     5aea <z_time_slice+0x60>
    5ac7:	48 3b 3d e2 44 00 00 	cmp    0x44e2(%rip),%rdi        # 9fb0 <_GLOBAL_OFFSET_TABLE_+0x158>
    5ace:	74 1a                	je     5aea <z_time_slice+0x60>
		if (ticks >= _current_cpu->slice_ticks) {
    5ad0:	8b 50 28             	mov    0x28(%rax),%edx
    5ad3:	39 da                	cmp    %ebx,%edx
    5ad5:	7f 0c                	jg     5ae3 <z_time_slice+0x59>
			move_thread_to_end_of_prio_q(_current);
    5ad7:	e8 07 ff ff ff       	callq  59e3 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    5adc:	e8 a2 fc ff ff       	callq  5783 <z_reset_time_slice>
    5ae1:	eb 0e                	jmp    5af1 <z_time_slice+0x67>
			_current_cpu->slice_ticks -= ticks;
    5ae3:	29 da                	sub    %ebx,%edx
    5ae5:	89 50 28             	mov    %edx,0x28(%rax)
    5ae8:	eb 07                	jmp    5af1 <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
    5aea:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
}
    5af1:	58                   	pop    %rax
	posix_irq_unlock(key);
    5af2:	89 ef                	mov    %ebp,%edi
    5af4:	5b                   	pop    %rbx
    5af5:	5d                   	pop    %rbp
    5af6:	e9 29 eb ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000005afb <ready_thread>:
    5afb:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    5afe:	84 c0                	test   %al,%al
    5b00:	0f 88 9a 00 00 00    	js     5ba0 <ready_thread+0xa5>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    5b06:	a8 1f                	test   $0x1f,%al
    5b08:	0f 85 92 00 00 00    	jne    5ba0 <ready_thread+0xa5>
{
    5b0e:	41 54                	push   %r12
    5b10:	55                   	push   %rbp
    5b11:	53                   	push   %rbx
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    5b12:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
    5b17:	48 89 fb             	mov    %rdi,%rbx
    5b1a:	75 7f                	jne    5b9b <ready_thread+0xa0>
	return list->head == list;
    5b1c:	4c 8d 25 3d 5b 00 00 	lea    0x5b3d(%rip),%r12        # b660 <_kernel>
	thread->base.thread_state |= _THREAD_QUEUED;
    5b23:	83 c8 80             	or     $0xffffff80,%eax
    5b26:	88 47 19             	mov    %al,0x19(%rdi)
    5b29:	49 8b 6c 24 48       	mov    0x48(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5b2e:	48 85 ed             	test   %rbp,%rbp
    5b31:	74 0a                	je     5b3d <ready_thread+0x42>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5b33:	49 8d 44 24 48       	lea    0x48(%r12),%rax
    5b38:	48 39 c5             	cmp    %rax,%rbp
    5b3b:	75 20                	jne    5b5d <ready_thread+0x62>
	node->next = list;
    5b3d:	49 8d 44 24 48       	lea    0x48(%r12),%rax
    5b42:	48 89 03             	mov    %rax,(%rbx)
	node->prev = list->tail;
    5b45:	49 8b 44 24 50       	mov    0x50(%r12),%rax
    5b4a:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
    5b4e:	49 8b 44 24 50       	mov    0x50(%r12),%rax
    5b53:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    5b56:	49 89 5c 24 50       	mov    %rbx,0x50(%r12)
}
    5b5b:	eb 33                	jmp    5b90 <ready_thread+0x95>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    5b5d:	48 89 ee             	mov    %rbp,%rsi
    5b60:	48 89 df             	mov    %rbx,%rdi
    5b63:	e8 0d fc ff ff       	callq  5775 <z_is_t1_higher_prio_than_t2>
    5b68:	84 c0                	test   %al,%al
    5b6a:	74 14                	je     5b80 <ready_thread+0x85>
	node->prev = successor->prev;
    5b6c:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    5b70:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = successor->prev;
    5b73:	48 89 43 08          	mov    %rax,0x8(%rbx)
	successor->prev->next = node;
    5b77:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    5b7a:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    5b7e:	eb 10                	jmp    5b90 <ready_thread+0x95>
	return (node == list->tail) ? NULL : node->next;
    5b80:	49 39 6c 24 50       	cmp    %rbp,0x50(%r12)
    5b85:	74 b6                	je     5b3d <ready_thread+0x42>
    5b87:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5b8b:	48 85 ed             	test   %rbp,%rbp
    5b8e:	eb ab                	jmp    5b3b <ready_thread+0x40>
}
    5b90:	5b                   	pop    %rbx
		update_cache(0);
    5b91:	31 ff                	xor    %edi,%edi
}
    5b93:	5d                   	pop    %rbp
    5b94:	41 5c                	pop    %r12
		update_cache(0);
    5b96:	e9 45 fd ff ff       	jmpq   58e0 <update_cache>
}
    5b9b:	5b                   	pop    %rbx
    5b9c:	5d                   	pop    %rbp
    5b9d:	41 5c                	pop    %r12
    5b9f:	c3                   	retq   
    5ba0:	c3                   	retq   

0000000000005ba1 <z_ready_thread>:
{
    5ba1:	f3 0f 1e fa          	endbr64 
    5ba5:	55                   	push   %rbp
    5ba6:	48 83 ec 10          	sub    $0x10,%rsp
    5baa:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    5baf:	e8 62 ea ff ff       	callq  4616 <posix_irq_lock>
		ready_thread(thread);
    5bb4:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    5bb9:	89 c5                	mov    %eax,%ebp
    5bbb:	e8 3b ff ff ff       	callq  5afb <ready_thread>
}
    5bc0:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    5bc4:	89 ef                	mov    %ebp,%edi
    5bc6:	5d                   	pop    %rbp
    5bc7:	e9 58 ea ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000005bcc <z_sched_start>:
{
    5bcc:	f3 0f 1e fa          	endbr64 
    5bd0:	41 54                	push   %r12
    5bd2:	48 83 ec 10          	sub    $0x10,%rsp
    5bd6:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    5bdb:	e8 36 ea ff ff       	callq  4616 <posix_irq_lock>
	if (z_has_thread_started(thread)) {
    5be0:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    5be5:	41 89 c4             	mov    %eax,%r12d
    5be8:	8a 47 19             	mov    0x19(%rdi),%al
    5beb:	a8 04                	test   $0x4,%al
    5bed:	75 0e                	jne    5bfd <z_sched_start+0x31>
}
    5bef:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    5bf3:	44 89 e7             	mov    %r12d,%edi
    5bf6:	41 5c                	pop    %r12
    5bf8:	e9 27 ea ff ff       	jmpq   4624 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    5bfd:	83 e0 fb             	and    $0xfffffffb,%eax
    5c00:	88 47 19             	mov    %al,0x19(%rdi)
	ready_thread(thread);
    5c03:	e8 f3 fe ff ff       	callq  5afb <ready_thread>
}
    5c08:	48 83 c4 10          	add    $0x10,%rsp
	z_reschedule(&sched_spinlock, key);
    5c0c:	44 89 e6             	mov    %r12d,%esi
    5c0f:	48 8d 3d 9e 5b 00 00 	lea    0x5b9e(%rip),%rdi        # b7b4 <sched_spinlock>
}
    5c16:	41 5c                	pop    %r12
	z_reschedule(&sched_spinlock, key);
    5c18:	e9 fb fb ff ff       	jmpq   5818 <z_reschedule>

0000000000005c1d <z_thread_timeout>:
{
    5c1d:	f3 0f 1e fa          	endbr64 
    5c21:	41 54                	push   %r12
    5c23:	55                   	push   %rbp
    5c24:	53                   	push   %rbx
    5c25:	48 89 fb             	mov    %rdi,%rbx
		struct k_thread *thread = CONTAINER_OF(timeout,
    5c28:	4c 8d 63 d8          	lea    -0x28(%rbx),%r12
	return posix_irq_lock();
    5c2c:	e8 e5 e9 ff ff       	callq  4616 <posix_irq_lock>
		if (thread->base.pended_on != NULL) {
    5c31:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
    5c36:	89 c5                	mov    %eax,%ebp
    5c38:	74 08                	je     5c42 <z_thread_timeout+0x25>
			unpend_thread_no_timeout(thread);
    5c3a:	4c 89 e7             	mov    %r12,%rdi
    5c3d:	e8 6c fc ff ff       	callq  58ae <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    5c42:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
		ready_thread(thread);
    5c46:	4c 89 e7             	mov    %r12,%rdi
    5c49:	e8 ad fe ff ff       	callq  5afb <ready_thread>
}
    5c4e:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    5c4f:	89 ef                	mov    %ebp,%edi
    5c51:	5d                   	pop    %rbp
    5c52:	41 5c                	pop    %r12
    5c54:	e9 cb e9 ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000005c59 <z_thread_single_abort>:
{
    5c59:	f3 0f 1e fa          	endbr64 
    5c5d:	41 55                	push   %r13
    5c5f:	41 54                	push   %r12
    5c61:	55                   	push   %rbp
    5c62:	48 89 fd             	mov    %rdi,%rbp
    5c65:	53                   	push   %rbx
    5c66:	56                   	push   %rsi
	return posix_irq_lock();
    5c67:	e8 aa e9 ff ff       	callq  4616 <posix_irq_lock>
    5c6c:	89 c7                	mov    %eax,%edi
	if ((thread->base.thread_state &
    5c6e:	8a 45 19             	mov    0x19(%rbp),%al
    5c71:	a8 28                	test   $0x28,%al
    5c73:	74 0c                	je     5c81 <z_thread_single_abort+0x28>
}
    5c75:	59                   	pop    %rcx
    5c76:	5b                   	pop    %rbx
    5c77:	5d                   	pop    %rbp
    5c78:	41 5c                	pop    %r12
    5c7a:	41 5d                	pop    %r13
	posix_irq_unlock(key);
    5c7c:	e9 a3 e9 ff ff       	jmpq   4624 <posix_irq_unlock>
	thread->base.thread_state |= _THREAD_ABORTING;
    5c81:	83 c8 20             	or     $0x20,%eax
    5c84:	88 45 19             	mov    %al,0x19(%rbp)
    5c87:	e8 98 e9 ff ff       	callq  4624 <posix_irq_unlock>
    5c8c:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
    5c90:	e8 d8 04 00 00       	callq  616d <z_abort_timeout>
	return posix_irq_lock();
    5c95:	e8 7c e9 ff ff       	callq  4616 <posix_irq_lock>
    5c9a:	41 89 c5             	mov    %eax,%r13d
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    5c9d:	8a 45 19             	mov    0x19(%rbp),%al
    5ca0:	a8 1f                	test   $0x1f,%al
    5ca2:	75 37                	jne    5cdb <z_thread_single_abort+0x82>
		if (z_is_thread_ready(thread)) {
    5ca4:	48 83 7d 28 00       	cmpq   $0x0,0x28(%rbp)
    5ca9:	75 30                	jne    5cdb <z_thread_single_abort+0x82>
			if (z_is_thread_queued(thread)) {
    5cab:	84 c0                	test   %al,%al
    5cad:	4c 8d 25 ac 59 00 00 	lea    0x59ac(%rip),%r12        # b660 <_kernel>
    5cb4:	79 13                	jns    5cc9 <z_thread_single_abort+0x70>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5cb6:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    5cb9:	48 89 ee             	mov    %rbp,%rsi
    5cbc:	49 8d 7c 24 48       	lea    0x48(%r12),%rdi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5cc1:	88 45 19             	mov    %al,0x19(%rbp)
		_priq_run_remove(pq, thread);
    5cc4:	e8 c3 fb ff ff       	callq  588c <z_priq_dumb_remove>
			update_cache(thread == _current);
    5cc9:	31 ff                	xor    %edi,%edi
    5ccb:	49 39 6c 24 10       	cmp    %rbp,0x10(%r12)
    5cd0:	40 0f 94 c7          	sete   %dil
    5cd4:	e8 07 fc ff ff       	callq  58e0 <update_cache>
    5cd9:	eb 1c                	jmp    5cf7 <z_thread_single_abort+0x9e>
			if (z_is_thread_pending(thread)) {
    5cdb:	a8 02                	test   $0x2,%al
    5cdd:	74 18                	je     5cf7 <z_thread_single_abort+0x9e>
				_priq_wait_remove(&pended_on(thread)->waitq,
    5cdf:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
    5ce3:	48 89 ee             	mov    %rbp,%rsi
    5ce6:	e8 a1 fb ff ff       	callq  588c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    5ceb:	80 65 19 fd          	andb   $0xfd,0x19(%rbp)
				thread->base.pended_on = NULL;
    5cef:	48 c7 45 10 00 00 00 	movq   $0x0,0x10(%rbp)
    5cf6:	00 
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    5cf7:	48 8d 5d 48          	lea    0x48(%rbp),%rbx
	return list->head == list;
    5cfb:	4c 8b 65 48          	mov    0x48(%rbp),%r12
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
    5cff:	4d 85 e4             	test   %r12,%r12
    5d02:	74 3e                	je     5d42 <z_thread_single_abort+0xe9>
    5d04:	49 39 dc             	cmp    %rbx,%r12
    5d07:	74 39                	je     5d42 <z_thread_single_abort+0xe9>
    5d09:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
    5d0e:	e8 5a 04 00 00       	callq  616d <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
    5d13:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
    5d18:	4c 89 e6             	mov    %r12,%rsi
    5d1b:	e8 6c fb ff ff       	callq  588c <z_priq_dumb_remove>
    5d20:	41 80 64 24 19 fd    	andb   $0xfd,0x19(%r12)
			ready_thread(waiter);
    5d26:	4c 89 e7             	mov    %r12,%rdi
			waiter->base.pended_on = NULL;
    5d29:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
    5d30:	00 00 
	thread->callee_saved.retval = value;
    5d32:	41 c7 44 24 5c 00 00 	movl   $0x0,0x5c(%r12)
    5d39:	00 00 
			ready_thread(waiter);
    5d3b:	e8 bb fd ff ff       	callq  5afb <ready_thread>
    5d40:	eb b9                	jmp    5cfb <z_thread_single_abort+0xa2>
		if (z_is_idle_thread_object(_current)) {
    5d42:	48 8d 05 17 59 00 00 	lea    0x5917(%rip),%rax        # b660 <_kernel>
    5d49:	48 8d 15 d0 57 00 00 	lea    0x57d0(%rip),%rdx        # b520 <z_idle_threads>
    5d50:	48 39 50 10          	cmp    %rdx,0x10(%rax)
    5d54:	75 0a                	jne    5d60 <z_thread_single_abort+0x107>
			update_cache(1);
    5d56:	bf 01 00 00 00       	mov    $0x1,%edi
    5d5b:	e8 80 fb ff ff       	callq  58e0 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
    5d60:	80 4d 19 08          	orb    $0x8,0x19(%rbp)
		fn_abort = thread->fn_abort;
    5d64:	4c 8b 65 70          	mov    0x70(%rbp),%r12
	posix_irq_unlock(key);
    5d68:	44 89 ef             	mov    %r13d,%edi
    5d6b:	e8 b4 e8 ff ff       	callq  4624 <posix_irq_unlock>
	if (fn_abort != NULL) {
    5d70:	4d 85 e4             	test   %r12,%r12
    5d73:	74 0f                	je     5d84 <z_thread_single_abort+0x12b>
}
    5d75:	5a                   	pop    %rdx
		fn_abort(thread);
    5d76:	48 89 ef             	mov    %rbp,%rdi
}
    5d79:	5b                   	pop    %rbx
		fn_abort(thread);
    5d7a:	4c 89 e0             	mov    %r12,%rax
}
    5d7d:	5d                   	pop    %rbp
    5d7e:	41 5c                	pop    %r12
    5d80:	41 5d                	pop    %r13
		fn_abort(thread);
    5d82:	ff e0                	jmpq   *%rax
}
    5d84:	58                   	pop    %rax
    5d85:	5b                   	pop    %rbx
    5d86:	5d                   	pop    %rbp
    5d87:	41 5c                	pop    %r12
    5d89:	41 5d                	pop    %r13
    5d8b:	c3                   	retq   

0000000000005d8c <z_sched_init>:

	return need_sched;
}

void z_sched_init(void)
{
    5d8c:	f3 0f 1e fa          	endbr64 
	list->head = (sys_dnode_t *)list;
    5d90:	48 8d 05 c9 58 00 00 	lea    0x58c9(%rip),%rax        # b660 <_kernel>
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    5d97:	31 f6                	xor    %esi,%esi
    5d99:	31 ff                	xor    %edi,%edi
    5d9b:	48 8d 50 48          	lea    0x48(%rax),%rdx
    5d9f:	48 89 50 48          	mov    %rdx,0x48(%rax)
	list->tail = (sys_dnode_t *)list;
    5da3:	48 89 50 50          	mov    %rdx,0x50(%rax)
    5da7:	e9 05 fa ff ff       	jmpq   57b1 <k_sched_time_slice_set>

0000000000005dac <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    5dac:	f3 0f 1e fa          	endbr64 
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    5db0:	48 8d 05 a9 58 00 00 	lea    0x58a9(%rip),%rax        # b660 <_kernel>

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    5db7:	48 8b 40 10          	mov    0x10(%rax),%rax
}
    5dbb:	c3                   	retq   

0000000000005dbc <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    5dbc:	f3 0f 1e fa          	endbr64 
	z_sched_start(thread);
    5dc0:	e9 07 fe ff ff       	jmpq   5bcc <z_sched_start>

0000000000005dc5 <z_init_thread_base>:
}
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    5dc5:	f3 0f 1e fa          	endbr64 
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
    5dc9:	88 4f 18             	mov    %cl,0x18(%rdi)
	thread_base->thread_state = (uint8_t)initial_state;
    5dcc:	88 57 19             	mov    %dl,0x19(%rdi)

	thread_base->prio = priority;
    5dcf:	40 88 77 1a          	mov    %sil,0x1a(%rdi)

	thread_base->sched_locked = 0U;
    5dd3:	c6 47 1b 00          	movb   $0x0,0x1b(%rdi)
	node->next = NULL;
    5dd7:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
    5dde:	00 
	node->prev = NULL;
    5ddf:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
    5de6:	00 
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    5de7:	c3                   	retq   

0000000000005de8 <z_setup_new_thread>:
{
    5de8:	f3 0f 1e fa          	endbr64 
    5dec:	41 55                	push   %r13
	sys_dlist_init(&w->waitq);
    5dee:	48 8d 47 48          	lea    0x48(%rdi),%rax
    5df2:	49 89 cd             	mov    %rcx,%r13
    5df5:	41 54                	push   %r12
    5df7:	49 89 d4             	mov    %rdx,%r12
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    5dfa:	ba 04 00 00 00       	mov    $0x4,%edx
{
    5dff:	55                   	push   %rbp
    5e00:	48 89 f5             	mov    %rsi,%rbp
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    5e03:	49 83 c4 07          	add    $0x7,%r12
{
    5e07:	53                   	push   %rbx
    5e08:	48 89 fb             	mov    %rdi,%rbx
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    5e0b:	49 83 e4 f8          	and    $0xfffffffffffffff8,%r12
	stack_ptr = (char *)stack + stack_obj_size;
    5e0f:	49 01 ec             	add    %rbp,%r12
{
    5e12:	48 83 ec 18          	sub    $0x18,%rsp
	list->head = (sys_dnode_t *)list;
    5e16:	48 89 47 48          	mov    %rax,0x48(%rdi)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    5e1a:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
    5e1e:	8b 74 24 48          	mov    0x48(%rsp),%esi
	list->tail = (sys_dnode_t *)list;
    5e22:	48 89 47 50          	mov    %rax,0x50(%rdi)
{
    5e26:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    5e2b:	4c 89 0c 24          	mov    %r9,(%rsp)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    5e2f:	e8 91 ff ff ff       	callq  5dc5 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    5e34:	4c 89 e9             	mov    %r13,%rcx
    5e37:	4c 89 e2             	mov    %r12,%rdx
    5e3a:	48 89 ee             	mov    %rbp,%rsi
    5e3d:	50                   	push   %rax
    5e3e:	48 89 df             	mov    %rbx,%rdi
    5e41:	ff 74 24 48          	pushq  0x48(%rsp)
    5e45:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    5e4a:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    5e4f:	e8 69 dc ff ff       	callq  3abd <arch_new_thread>
	if (!_current) {
    5e54:	48 8d 05 05 58 00 00 	lea    0x5805(%rip),%rax        # b660 <_kernel>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    5e5b:	5a                   	pop    %rdx
	new_thread->init_data = NULL;
    5e5c:	48 c7 43 68 00 00 00 	movq   $0x0,0x68(%rbx)
    5e63:	00 
	new_thread->fn_abort = NULL;
    5e64:	48 c7 43 70 00 00 00 	movq   $0x0,0x70(%rbx)
    5e6b:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    5e6c:	59                   	pop    %rcx
	if (!_current) {
    5e6d:	48 8b 40 10          	mov    0x10(%rax),%rax
    5e71:	48 85 c0             	test   %rax,%rax
    5e74:	74 07                	je     5e7d <z_setup_new_thread+0x95>
	new_thread->resource_pool = _current->resource_pool;
    5e76:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
	return stack_ptr;
    5e7d:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
}
    5e84:	48 83 c4 18          	add    $0x18,%rsp
    5e88:	4c 89 e0             	mov    %r12,%rax
    5e8b:	5b                   	pop    %rbx
    5e8c:	5d                   	pop    %rbp
    5e8d:	41 5c                	pop    %r12
    5e8f:	41 5d                	pop    %r13
    5e91:	c3                   	retq   

0000000000005e92 <z_init_static_threads>:
{
    5e92:	f3 0f 1e fa          	endbr64 
    5e96:	55                   	push   %rbp
    5e97:	53                   	push   %rbx
    5e98:	52                   	push   %rdx
	_FOREACH_STATIC_THREAD(thread_data) {
    5e99:	48 8d 1d 14 52 00 00 	lea    0x5214(%rip),%rbx        # b0b4 <__device_init_status_end>
    5ea0:	48 89 dd             	mov    %rbx,%rbp
    5ea3:	48 3b 1d 0e 41 00 00 	cmp    0x410e(%rip),%rbx        # 9fb8 <_GLOBAL_OFFSET_TABLE_+0x160>
    5eaa:	73 3a                	jae    5ee6 <z_init_static_threads+0x54>
		z_setup_new_thread(
    5eac:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
    5eb0:	4c 8b 43 20          	mov    0x20(%rbx),%r8
    5eb4:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    5eb8:	8b 53 10             	mov    0x10(%rbx),%edx
    5ebb:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    5ebf:	ff 73 50             	pushq  0x50(%rbx)
    5ec2:	8b 43 3c             	mov    0x3c(%rbx),%eax
    5ec5:	50                   	push   %rax
    5ec6:	8b 43 38             	mov    0x38(%rbx),%eax
    5ec9:	50                   	push   %rax
    5eca:	ff 73 30             	pushq  0x30(%rbx)
    5ecd:	48 8b 3b             	mov    (%rbx),%rdi
    5ed0:	e8 13 ff ff ff       	callq  5de8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    5ed5:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
    5ed8:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
    5edc:	48 89 58 68          	mov    %rbx,0x68(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
    5ee0:	48 83 c3 58          	add    $0x58,%rbx
    5ee4:	eb bd                	jmp    5ea3 <z_init_static_threads+0x11>
	k_sched_lock();
    5ee6:	e8 81 f9 ff ff       	callq  586c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    5eeb:	48 89 eb             	mov    %rbp,%rbx
					    K_MSEC(thread_data->init_delay));
    5eee:	31 ed                	xor    %ebp,%ebp
	_FOREACH_STATIC_THREAD(thread_data) {
    5ef0:	48 3b 1d c1 40 00 00 	cmp    0x40c1(%rip),%rbx        # 9fb8 <_GLOBAL_OFFSET_TABLE_+0x160>
    5ef7:	73 46                	jae    5f3f <z_init_static_threads+0xad>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    5ef9:	8b 43 40             	mov    0x40(%rbx),%eax
    5efc:	83 f8 ff             	cmp    $0xffffffff,%eax
    5eff:	74 38                	je     5f39 <z_init_static_threads+0xa7>
					    K_MSEC(thread_data->init_delay));
    5f01:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    5f03:	48 8b 3b             	mov    (%rbx),%rdi
					    K_MSEC(thread_data->init_delay));
    5f06:	0f 48 c5             	cmovs  %ebp,%eax
    5f09:	48 63 c8             	movslq %eax,%rcx
		t += off;
    5f0c:	48 8d 41 09          	lea    0x9(%rcx),%rax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    5f10:	48 85 c9             	test   %rcx,%rcx
    5f13:	75 07                	jne    5f1c <z_init_static_threads+0x8a>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_START);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_start(thread);
    5f15:	e8 a2 fe ff ff       	callq  5dbc <z_impl_k_thread_start>
}
    5f1a:	eb 1d                	jmp    5f39 <z_init_static_threads+0xa7>
			return t / (from_hz / to_hz);
    5f1c:	b9 0a 00 00 00       	mov    $0xa,%ecx
    5f21:	31 d2                	xor    %edx,%edx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    5f23:	48 8d 35 f3 fc ff ff 	lea    -0x30d(%rip),%rsi        # 5c1d <z_thread_timeout>
    5f2a:	48 83 c7 28          	add    $0x28,%rdi
    5f2e:	48 f7 f1             	div    %rcx
    5f31:	48 89 c2             	mov    %rax,%rdx
    5f34:	e8 16 01 00 00       	callq  604f <z_add_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
    5f39:	48 83 c3 58          	add    $0x58,%rbx
    5f3d:	eb b1                	jmp    5ef0 <z_init_static_threads+0x5e>
}
    5f3f:	58                   	pop    %rax
    5f40:	5b                   	pop    %rbx
    5f41:	5d                   	pop    %rbp
	k_sched_unlock();
    5f42:	e9 6e fa ff ff       	jmpq   59b5 <k_sched_unlock>

0000000000005f47 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_self_abort(void)
{
    5f47:	f3 0f 1e fa          	endbr64 
    5f4b:	55                   	push   %rbp
	return posix_irq_lock();
    5f4c:	e8 c5 e6 ff ff       	callq  4616 <posix_irq_lock>
    5f51:	89 c5                	mov    %eax,%ebp
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
    5f53:	48 8d 05 06 57 00 00 	lea    0x5706(%rip),%rax        # b660 <_kernel>
    5f5a:	48 8b 78 10          	mov    0x10(%rax),%rdi
    5f5e:	48 89 78 20          	mov    %rdi,0x20(%rax)
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_SUSPEND);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_suspend(thread);
    5f62:	e8 e3 f9 ff ff       	callq  594a <z_impl_k_thread_suspend>
    5f67:	89 ef                	mov    %ebp,%edi
    5f69:	e8 e6 da ff ff       	callq  3a54 <arch_swap>
		_current, cpu->idle_thread);

	k_thread_suspend(_current);
	z_swap_irqlock(key);
	__ASSERT(false, "should never get here");
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    5f6e:	ba 31 00 00 00       	mov    $0x31,%edx
    5f73:	48 8d 35 48 1e 00 00 	lea    0x1e48(%rip),%rsi        # 7dc2 <__func__.5051+0xdc2>
    5f7a:	31 c0                	xor    %eax,%eax
    5f7c:	48 8d 3d 2e 12 00 00 	lea    0x122e(%rip),%rdi        # 71b1 <__func__.5051+0x1b1>
    5f83:	e8 25 ea ff ff       	callq  49ad <posix_print_error_and_exit>

0000000000005f88 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    5f88:	f3 0f 1e fa          	endbr64 
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    5f8c:	48 8d 15 de 1c 00 00 	lea    0x1cde(%rip),%rdx        # 7c71 <__func__.5051+0xc71>
    5f93:	48 8d 35 51 1e 00 00 	lea    0x1e51(%rip),%rsi        # 7deb <__func__.5051+0xdeb>
    5f9a:	31 c0                	xor    %eax,%eax
    5f9c:	48 8d 3d 68 1e 00 00 	lea    0x1e68(%rip),%rdi        # 7e0b <__func__.5051+0xe0b>
    5fa3:	e9 2c c7 ff ff       	jmpq   26d4 <printk>

0000000000005fa8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
    5fa8:	83 3d f9 57 00 00 00 	cmpl   $0x0,0x57f9(%rip)        # b7a8 <announce_remaining>
    5faf:	75 05                	jne    5fb6 <elapsed+0xe>
    5fb1:	e9 c1 d5 ff ff       	jmpq   3577 <z_clock_elapsed>
}
    5fb6:	31 c0                	xor    %eax,%eax
    5fb8:	c3                   	retq   

0000000000005fb9 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    5fb9:	48 8b 07             	mov    (%rdi),%rax
    5fbc:	48 85 ff             	test   %rdi,%rdi
    5fbf:	74 16                	je     5fd7 <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
    5fc1:	48 3b 3d 50 43 00 00 	cmp    0x4350(%rip),%rdi        # a318 <timeout_list+0x8>
    5fc8:	74 0d                	je     5fd7 <remove_timeout+0x1e>
	if (next(t) != NULL) {
    5fca:	48 85 c0             	test   %rax,%rax
    5fcd:	74 08                	je     5fd7 <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
    5fcf:	48 8b 57 18          	mov    0x18(%rdi),%rdx
    5fd3:	48 01 50 18          	add    %rdx,0x18(%rax)
	node->prev->next = node->next;
    5fd7:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    5fdb:	48 89 02             	mov    %rax,(%rdx)
	node->next->prev = node->prev;
    5fde:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    5fe2:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
    5fe9:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    5ff0:	00 
}
    5ff1:	c3                   	retq   

0000000000005ff2 <next_timeout>:

static int32_t next_timeout(void)
{
    5ff2:	53                   	push   %rbx
	return list->head == list;
    5ff3:	48 8b 1d 16 43 00 00 	mov    0x4316(%rip),%rbx        # a310 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5ffa:	48 8d 05 0f 43 00 00 	lea    0x430f(%rip),%rax        # a310 <timeout_list>
    6001:	48 39 c3             	cmp    %rax,%rbx
    6004:	75 02                	jne    6008 <next_timeout+0x16>
    6006:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    6008:	e8 9b ff ff ff       	callq  5fa8 <elapsed>
    600d:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
    600f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    6014:	48 85 db             	test   %rbx,%rbx
    6017:	74 21                	je     603a <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    6019:	48 63 c2             	movslq %edx,%rax
    601c:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    6020:	48 29 c2             	sub    %rax,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    6023:	31 c0                	xor    %eax,%eax
    6025:	48 85 d2             	test   %rdx,%rdx
    6028:	7e 10                	jle    603a <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    602a:	48 81 fa ff ff ff 7f 	cmp    $0x7fffffff,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    6031:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    6036:	48 0f 4e c2          	cmovle %rdx,%rax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    603a:	48 8d 15 1f 56 00 00 	lea    0x561f(%rip),%rdx        # b660 <_kernel>
    6041:	8b 52 28             	mov    0x28(%rdx),%edx
    6044:	85 d2                	test   %edx,%edx
    6046:	74 05                	je     604d <next_timeout+0x5b>
    6048:	39 d0                	cmp    %edx,%eax
    604a:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    604d:	5b                   	pop    %rbx
    604e:	c3                   	retq   

000000000000604f <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    604f:	f3 0f 1e fa          	endbr64 
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    6053:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    6057:	0f 84 0f 01 00 00    	je     616c <z_add_timeout+0x11d>
{
    605d:	41 55                	push   %r13
    605f:	49 89 f5             	mov    %rsi,%r13
    6062:	41 54                	push   %r12
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    6064:	49 c7 c4 fe ff ff ff 	mov    $0xfffffffffffffffe,%r12
{
    606b:	55                   	push   %rbp
	k_ticks_t ticks = timeout.ticks + 1;
    606c:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
{
    6070:	53                   	push   %rbx
    6071:	48 89 fb             	mov    %rdi,%rbx
    6074:	51                   	push   %rcx
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    6075:	49 39 ec             	cmp    %rbp,%r12
    6078:	78 17                	js     6091 <z_add_timeout+0x42>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
    607a:	e8 29 ff ff ff       	callq  5fa8 <elapsed>
    607f:	4c 2b 25 ea 56 00 00 	sub    0x56ea(%rip),%r12        # b770 <curr_tick>
    6086:	49 29 ec             	sub    %rbp,%r12
    6089:	48 98                	cltq   
    608b:	4c 89 e5             	mov    %r12,%rbp
    608e:	48 29 c5             	sub    %rax,%rbp
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    6091:	4c 89 6b 10          	mov    %r13,0x10(%rbx)
    6095:	e8 7c e5 ff ff       	callq  4616 <posix_irq_lock>
    609a:	41 89 c4             	mov    %eax,%r12d
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    609d:	e8 06 ff ff ff       	callq  5fa8 <elapsed>
	ticks = MAX(1, ticks);
    60a2:	48 85 ed             	test   %rbp,%rbp
    60a5:	ba 01 00 00 00       	mov    $0x1,%edx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    60aa:	48 8b 3d 67 42 00 00 	mov    0x4267(%rip),%rdi        # a318 <timeout_list+0x8>
    60b1:	48 0f 4e ea          	cmovle %rdx,%rbp
		to->dticks = ticks + elapsed();
    60b5:	48 98                	cltq   
	return list->head == list;
    60b7:	48 8d 15 52 42 00 00 	lea    0x4252(%rip),%rdx        # a310 <timeout_list>
    60be:	48 01 c5             	add    %rax,%rbp
    60c1:	48 8b 05 48 42 00 00 	mov    0x4248(%rip),%rax        # a310 <timeout_list>
    60c8:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    60cc:	48 39 d0             	cmp    %rdx,%rax
    60cf:	74 3e                	je     610f <z_add_timeout+0xc0>
		for (t = first(); t != NULL; t = next(t)) {
    60d1:	48 85 c0             	test   %rax,%rax
    60d4:	74 39                	je     610f <z_add_timeout+0xc0>
			if (t->dticks > to->dticks) {
    60d6:	48 8b 70 18          	mov    0x18(%rax),%rsi
    60da:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    60de:	48 39 ce             	cmp    %rcx,%rsi
    60e1:	7e 1b                	jle    60fe <z_add_timeout+0xaf>
				t->dticks -= to->dticks;
    60e3:	48 29 ce             	sub    %rcx,%rsi
	node->prev = successor->prev;
    60e6:	48 8b 48 08          	mov    0x8(%rax),%rcx
    60ea:	48 89 70 18          	mov    %rsi,0x18(%rax)
    60ee:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	node->next = successor;
    60f2:	48 89 03             	mov    %rax,(%rbx)
	successor->prev->next = node;
    60f5:	48 89 19             	mov    %rbx,(%rcx)
	successor->prev = node;
    60f8:	48 89 58 08          	mov    %rbx,0x8(%rax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    60fc:	eb 30                	jmp    612e <z_add_timeout+0xdf>
			to->dticks -= t->dticks;
    60fe:	48 29 f1             	sub    %rsi,%rcx
    6101:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
	return (node == list->tail) ? NULL : node->next;
    6105:	48 39 f8             	cmp    %rdi,%rax
    6108:	74 05                	je     610f <z_add_timeout+0xc0>
    610a:	48 8b 00             	mov    (%rax),%rax
    610d:	eb c2                	jmp    60d1 <z_add_timeout+0x82>
	node->prev = list->tail;
    610f:	48 8b 05 02 42 00 00 	mov    0x4202(%rip),%rax        # a318 <timeout_list+0x8>
	node->next = list;
    6116:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = list->tail;
    6119:	48 89 43 08          	mov    %rax,0x8(%rbx)
	list->tail->next = node;
    611d:	48 8b 05 f4 41 00 00 	mov    0x41f4(%rip),%rax        # a318 <timeout_list+0x8>
    6124:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    6127:	48 89 1d ea 41 00 00 	mov    %rbx,0x41ea(%rip)        # a318 <timeout_list+0x8>
	return list->head == list;
    612e:	48 8b 05 db 41 00 00 	mov    0x41db(%rip),%rax        # a310 <timeout_list>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    6135:	48 39 c3             	cmp    %rax,%rbx
    6138:	75 23                	jne    615d <z_add_timeout+0x10e>
    613a:	48 39 d0             	cmp    %rdx,%rax
    613d:	74 1e                	je     615d <z_add_timeout+0x10e>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    613f:	e8 ae fe ff ff       	callq  5ff2 <next_timeout>
    6144:	89 c7                	mov    %eax,%edi

			if (next_time == 0 ||
    6146:	85 c0                	test   %eax,%eax
    6148:	74 0c                	je     6156 <z_add_timeout+0x107>
			    _current_cpu->slice_ticks != next_time) {
    614a:	48 8d 05 0f 55 00 00 	lea    0x550f(%rip),%rax        # b660 <_kernel>
			if (next_time == 0 ||
    6151:	39 78 28             	cmp    %edi,0x28(%rax)
    6154:	74 07                	je     615d <z_add_timeout+0x10e>
				z_clock_set_timeout(next_time, false);
    6156:	31 f6                	xor    %esi,%esi
    6158:	e8 f3 d3 ff ff       	callq  3550 <z_clock_set_timeout>
#else
			z_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    615d:	58                   	pop    %rax
	posix_irq_unlock(key);
    615e:	44 89 e7             	mov    %r12d,%edi
    6161:	5b                   	pop    %rbx
    6162:	5d                   	pop    %rbp
    6163:	41 5c                	pop    %r12
    6165:	41 5d                	pop    %r13
    6167:	e9 b8 e4 ff ff       	jmpq   4624 <posix_irq_unlock>
    616c:	c3                   	retq   

000000000000616d <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    616d:	f3 0f 1e fa          	endbr64 
    6171:	41 54                	push   %r12
    6173:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    6179:	48 83 ec 10          	sub    $0x10,%rsp
    617d:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    6182:	e8 8f e4 ff ff       	callq  4616 <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    6187:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    618c:	41 89 c0             	mov    %eax,%r8d
    618f:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    6193:	74 08                	je     619d <z_abort_timeout+0x30>
			remove_timeout(to);
    6195:	e8 1f fe ff ff       	callq  5fb9 <remove_timeout>
			ret = 0;
    619a:	45 31 e4             	xor    %r12d,%r12d
	posix_irq_unlock(key);
    619d:	44 89 c7             	mov    %r8d,%edi
    61a0:	e8 7f e4 ff ff       	callq  4624 <posix_irq_unlock>
		}
	}

	return ret;
}
    61a5:	48 83 c4 10          	add    $0x10,%rsp
    61a9:	44 89 e0             	mov    %r12d,%eax
    61ac:	41 5c                	pop    %r12
    61ae:	c3                   	retq   

00000000000061af <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
    61af:	f3 0f 1e fa          	endbr64 
    61b3:	55                   	push   %rbp
    61b4:	48 83 ec 10          	sub    $0x10,%rsp
	return posix_irq_lock();
    61b8:	e8 59 e4 ff ff       	callq  4616 <posix_irq_lock>
    61bd:	89 c5                	mov    %eax,%ebp
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
    61bf:	e8 2e fe ff ff       	callq  5ff2 <next_timeout>
	posix_irq_unlock(key);
    61c4:	89 ef                	mov    %ebp,%edi
    61c6:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    61ca:	e8 55 e4 ff ff       	callq  4624 <posix_irq_unlock>
	}
	return ret;
}
    61cf:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    61d3:	48 83 c4 10          	add    $0x10,%rsp
    61d7:	5d                   	pop    %rbp
    61d8:	c3                   	retq   

00000000000061d9 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    61d9:	f3 0f 1e fa          	endbr64 
    61dd:	41 54                	push   %r12
    61df:	53                   	push   %rbx
    61e0:	89 f3                	mov    %esi,%ebx
    61e2:	48 83 ec 18          	sub    $0x18,%rsp
    61e6:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
	return posix_irq_lock();
    61ea:	e8 27 e4 ff ff       	callq  4616 <posix_irq_lock>
    61ef:	41 89 c4             	mov    %eax,%r12d
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    61f2:	e8 fb fd ff ff       	callq  5ff2 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
    61f7:	8b 7c 24 0c          	mov    0xc(%rsp),%edi
		bool sooner = (next_to == K_TICKS_FOREVER)
    61fb:	83 f8 ff             	cmp    $0xffffffff,%eax
    61fe:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
    6201:	39 f8                	cmp    %edi,%eax
    6203:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    6206:	08 d1                	or     %dl,%cl
    6208:	74 0c                	je     6216 <z_set_timeout_expiry+0x3d>
    620a:	ff c8                	dec    %eax
    620c:	7e 08                	jle    6216 <z_set_timeout_expiry+0x3d>
			z_clock_set_timeout(ticks, is_idle);
    620e:	0f b6 f3             	movzbl %bl,%esi
    6211:	e8 3a d3 ff ff       	callq  3550 <z_clock_set_timeout>
		}
	}
}
    6216:	48 83 c4 18          	add    $0x18,%rsp
	posix_irq_unlock(key);
    621a:	44 89 e7             	mov    %r12d,%edi
    621d:	5b                   	pop    %rbx
    621e:	41 5c                	pop    %r12
    6220:	e9 ff e3 ff ff       	jmpq   4624 <posix_irq_unlock>

0000000000006225 <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
    6225:	f3 0f 1e fa          	endbr64 
    6229:	41 54                	push   %r12
    622b:	4c 8d 25 de 40 00 00 	lea    0x40de(%rip),%r12        # a310 <timeout_list>
    6232:	55                   	push   %rbp
    6233:	53                   	push   %rbx
    6234:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    6236:	e8 4f f8 ff ff       	callq  5a8a <z_time_slice>
	return posix_irq_lock();
    623b:	e8 d6 e3 ff ff       	callq  4616 <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    6240:	89 1d 62 55 00 00    	mov    %ebx,0x5562(%rip)        # b7a8 <announce_remaining>
    6246:	89 c5                	mov    %eax,%ebp
    6248:	48 63 15 59 55 00 00 	movslq 0x5559(%rip),%rdx        # b7a8 <announce_remaining>
    624f:	49 8b 1c 24          	mov    (%r12),%rbx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    6253:	48 8b 35 16 55 00 00 	mov    0x5516(%rip),%rsi        # b770 <curr_tick>
    625a:	48 89 d1             	mov    %rdx,%rcx

	while (first() != NULL && first()->dticks <= announce_remaining) {
    625d:	48 85 db             	test   %rbx,%rbx
    6260:	74 50                	je     62b2 <z_clock_announce+0x8d>
    6262:	4c 39 e3             	cmp    %r12,%rbx
    6265:	74 4b                	je     62b2 <z_clock_announce+0x8d>
    6267:	48 8b 43 18          	mov    0x18(%rbx),%rax
    626b:	48 39 d0             	cmp    %rdx,%rax
    626e:	7f 3b                	jg     62ab <z_clock_announce+0x86>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
    6270:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    6277:	00 
		curr_tick += dt;
    6278:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
    627b:	29 c1                	sub    %eax,%ecx
		remove_timeout(t);
    627d:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
    6280:	48 01 f2             	add    %rsi,%rdx
		announce_remaining -= dt;
    6283:	89 0d 1f 55 00 00    	mov    %ecx,0x551f(%rip)        # b7a8 <announce_remaining>
		curr_tick += dt;
    6289:	48 89 15 e0 54 00 00 	mov    %rdx,0x54e0(%rip)        # b770 <curr_tick>
		remove_timeout(t);
    6290:	e8 24 fd ff ff       	callq  5fb9 <remove_timeout>
	posix_irq_unlock(key);
    6295:	89 ef                	mov    %ebp,%edi
    6297:	e8 88 e3 ff ff       	callq  4624 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    629c:	48 89 df             	mov    %rbx,%rdi
    629f:	ff 53 10             	callq  *0x10(%rbx)
	return posix_irq_lock();
    62a2:	e8 6f e3 ff ff       	callq  4616 <posix_irq_lock>
    62a7:	89 c5                	mov    %eax,%ebp
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    62a9:	eb 9d                	jmp    6248 <z_clock_announce+0x23>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    62ab:	48 29 d0             	sub    %rdx,%rax
    62ae:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    62b2:	c7 05 ec 54 00 00 00 	movl   $0x0,0x54ec(%rip)        # b7a8 <announce_remaining>
    62b9:	00 00 00 
	curr_tick += announce_remaining;
    62bc:	48 01 f2             	add    %rsi,%rdx
    62bf:	48 89 15 aa 54 00 00 	mov    %rdx,0x54aa(%rip)        # b770 <curr_tick>

	z_clock_set_timeout(next_timeout(), false);
    62c6:	e8 27 fd ff ff       	callq  5ff2 <next_timeout>
    62cb:	31 f6                	xor    %esi,%esi
    62cd:	89 c7                	mov    %eax,%edi
    62cf:	e8 7c d2 ff ff       	callq  3550 <z_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
}
    62d4:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    62d5:	89 ef                	mov    %ebp,%edi
    62d7:	5d                   	pop    %rbp
    62d8:	41 5c                	pop    %r12
    62da:	e9 45 e3 ff ff       	jmpq   4624 <posix_irq_unlock>

00000000000062df <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    62df:	f3 0f 1e fa          	endbr64 
    62e3:	41 55                	push   %r13
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    62e5:	48 63 c7             	movslq %edi,%rax
    62e8:	4c 8d 2d 31 39 00 00 	lea    0x3931(%rip),%r13        # 9c20 <levels.4720>
    62ef:	ff c7                	inc    %edi
{
    62f1:	41 54                	push   %r12
    62f3:	55                   	push   %rbp
    62f4:	53                   	push   %rbx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    62f5:	48 63 df             	movslq %edi,%rbx
{
    62f8:	52                   	push   %rdx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    62f9:	4d 8b 64 c5 00       	mov    0x0(%r13,%rax,8),%r12
    62fe:	4d 39 64 dd 00       	cmp    %r12,0x0(%r13,%rbx,8)
    6303:	76 3c                	jbe    6341 <z_sys_init_run_level+0x62>
		const struct device *dev = entry->dev;
    6305:	49 8b 6c 24 08       	mov    0x8(%r12),%rbp

		if (dev != NULL) {
			z_object_init(dev);
		}

		if ((entry->init(dev) != 0) && (dev != NULL)) {
    630a:	48 89 ef             	mov    %rbp,%rdi
    630d:	41 ff 14 24          	callq  *(%r12)
    6311:	85 c0                	test   %eax,%eax
    6313:	74 26                	je     633b <z_sys_init_run_level+0x5c>
    6315:	48 85 ed             	test   %rbp,%rbp
    6318:	74 21                	je     633b <z_sys_init_run_level+0x5c>
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
    631a:	48 2b 2d b7 3c 00 00 	sub    0x3cb7(%rip),%rbp        # 9fd8 <_GLOBAL_OFFSET_TABLE_+0x180>
    6321:	48 c1 fd 05          	sar    $0x5,%rbp
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    6325:	89 e8                	mov    %ebp,%eax
    6327:	c1 e8 05             	shr    $0x5,%eax
    632a:	c1 e0 02             	shl    $0x2,%eax
    632d:	48 03 05 ac 3c 00 00 	add    0x3cac(%rip),%rax        # 9fe0 <_GLOBAL_OFFSET_TABLE_+0x188>
	uint32_t temp = *(volatile uint32_t *)addr;
    6334:	8b 10                	mov    (%rax),%edx
	*(volatile uint32_t *)addr = temp | (1 << bit);
    6336:	0f ab ea             	bts    %ebp,%edx
    6339:	89 10                	mov    %edx,(%rax)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    633b:	49 83 c4 10          	add    $0x10,%r12
    633f:	eb bd                	jmp    62fe <z_sys_init_run_level+0x1f>
		}
	}
}
    6341:	58                   	pop    %rax
    6342:	5b                   	pop    %rbx
    6343:	5d                   	pop    %rbp
    6344:	41 5c                	pop    %r12
    6346:	41 5d                	pop    %r13
    6348:	c3                   	retq   

0000000000006349 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
    6349:	f3 0f 1e fa          	endbr64 
    634d:	55                   	push   %rbp
    634e:	53                   	push   %rbx
    634f:	48 89 fb             	mov    %rdi,%rbx
    6352:	50                   	push   %rax
	return posix_irq_lock();
    6353:	e8 be e2 ff ff       	callq  4616 <posix_irq_lock>
	while (true) {
		/* Lock interrupts to atomically check if to_abort is non-NULL,
		 * and if so clear it
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;
    6358:	48 8b 6b 20          	mov    0x20(%rbx),%rbp
    635c:	89 c7                	mov    %eax,%edi

		if (to_abort) {
    635e:	48 85 ed             	test   %rbp,%rbp
    6361:	74 23                	je     6386 <idle+0x3d>
			cpu->pending_abort = NULL;
    6363:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    636a:	00 
	posix_irq_unlock(key);
    636b:	e8 b4 e2 ff ff       	callq  4624 <posix_irq_unlock>
			 * is continued below.
			 */
			LOG_DBG("idle %p aborting thread %p",
				_current, to_abort);

			z_thread_single_abort(to_abort);
    6370:	48 89 ef             	mov    %rbp,%rdi
    6373:	e8 e1 f8 ff ff       	callq  5c59 <z_thread_single_abort>
	return posix_irq_lock();
    6378:	e8 99 e2 ff ff       	callq  4616 <posix_irq_lock>
    637d:	89 c7                	mov    %eax,%edi
	(void) z_reschedule_irqlock(arch_irq_lock());
    637f:	e8 bd f4 ff ff       	callq  5841 <z_reschedule_irqlock>
			 * in order to abort the thread, and we now need to
			 * figure out what to do next, it's not necessarily
			 * the case that there are no other runnable threads.
			 */
			z_reschedule_unlocked();
			continue;
    6384:	eb cd                	jmp    6353 <idle+0xa>
		k_busy_wait(100);
		k_yield();
#else

#ifdef CONFIG_SYS_CLOCK_EXISTS
		int32_t ticks = z_get_next_timeout_expiry();
    6386:	e8 24 fe ff ff       	callq  61af <z_get_next_timeout_expiry>
    638b:	89 c7                	mov    %eax,%edi
		 * that the system should not enter a tickless idle for
		 * periods less than that.  This seems... silly, given that it
		 * saves no power and does not improve latency.  But it's an
		 * API we need to honor...
		 */
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    638d:	83 f8 02             	cmp    $0x2,%eax
    6390:	7f 05                	jg     6397 <idle+0x4e>
    6392:	bf 01 00 00 00       	mov    $0x1,%edi
    6397:	be 01 00 00 00       	mov    $0x1,%esi
    639c:	e8 38 fe ff ff       	callq  61d9 <z_set_timeout_expiry>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    63a1:	e8 ed d1 ff ff       	callq  3593 <arch_cpu_idle>
}
    63a6:	eb ab                	jmp    6353 <idle+0xa>

00000000000063a8 <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    63a8:	f3 0f 1e fa          	endbr64 
    63ac:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
    63b0:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
    63b4:	48 89 47 20          	mov    %rax,0x20(%rdi)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    63b8:	e9 9a c4 ff ff       	jmpq   2857 <sys_heap_init>

00000000000063bd <statics_init>:
}

static int statics_init(const struct device *unused)
{
    63bd:	f3 0f 1e fa          	endbr64 
    63c1:	53                   	push   %rbx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    63c2:	48 8d 1d eb 4c 00 00 	lea    0x4ceb(%rip),%rbx        # b0b4 <__device_init_status_end>
    63c9:	48 3b 1d f0 3b 00 00 	cmp    0x3bf0(%rip),%rbx        # 9fc0 <_GLOBAL_OFFSET_TABLE_+0x168>
    63d0:	73 16                	jae    63e8 <statics_init+0x2b>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    63d2:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    63d6:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    63da:	48 89 df             	mov    %rbx,%rdi
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    63dd:	48 83 c3 28          	add    $0x28,%rbx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    63e1:	e8 c2 ff ff ff       	callq  63a8 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    63e6:	eb e1                	jmp    63c9 <statics_init+0xc>
	}
	return 0;
}
    63e8:	31 c0                	xor    %eax,%eax
    63ea:	5b                   	pop    %rbx
    63eb:	c3                   	retq   

00000000000063ec <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    63ec:	f3 0f 1e fa          	endbr64 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    63f0:	c3                   	retq   

Disassembly of section .fini:

00000000000063f4 <_fini>:
    63f4:	f3 0f 1e fa          	endbr64 
    63f8:	48 83 ec 08          	sub    $0x8,%rsp
    63fc:	48 83 c4 08          	add    $0x8,%rsp
    6400:	c3                   	retq   
