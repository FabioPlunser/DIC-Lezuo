\section{Theorie und Vorwissen}
\subsection{Zephyr}
    Zephyr ist ein Open-Source-Echtzeitbetriebssystem welches von der Linux Foundation.\footnote{Quelle: \url{https://de.wikipedia.org/wiki/Zephyr_(Betriebssystem)}}
    Ein Echtzeitbetriebssystem, real-time operating system \textbf{RTOS} ist ein Betriebssystem, das Echtzeit-Anforderungen erfüllen kann. 
    Das bedeutet, dass Anfragen eines Anwendungsprogramms innerhalb einer Voraus bestimmbaren Zeit gesichert verarbeitet werden.\footnote{Quelle: \url{https://de.wikipedia.org/wiki/Echtzeitbetriebssystem}}
    \\
    Zephyr wurde mit dem \href{https://docs.zephyrproject.org/latest/getting_started/index.html}{Getting-Started-GUID} Linux Subsystem von Windows installiert. 
    Um ein Zephyr Projekt zu kompilieren wird Zephyr eigenes \textbf{West}\footnote{\url{https://docs.zephyrproject.org/2.4.0/guides/west/index.html}} verwendet.\\
    \textbf{West} ist ein Kompilierungs-Tool von Zephyr. Es verwendet Ninja und CMake um das Projekt zu kompilieren. 
    West wird folgendermaßen verwendet, um ein Projekt zu kompilieren: 
    \begin{lstlisting}[style=StyleC, captionpos=b, caption=West Beispiel, label=West Beispiel]
west build -p auto -b nativ_posix_64 
    \end{lstlisting}

    \subsubsection{KConfig}
    \textbf{Kernel Configuration File}\footnote{\url{https://docs.zephyrproject.org/latest/application/index.html?\#application-kconfig}}ist die \textcolor{red}{prj.conf} Datei in einem 
    Zephyr Projekt. In diesem werden bestimmte Konfigurationen, Funktionen und \anfuehrung{Geräte}, wie z.b. \textit{CONFIG\_SERIAL=y} aktiviert. 


\newpage
    \subsubsection{Device Tree}
    Der Device Tree\footnote{\url{https://docs.zephyrproject.org/latest/guides/dts/intro.html}\\\url{https://docs.zephyrproject.org/latest/reference/devicetree/index.html\#devicetree}} ist 
    in einem Zephyr Projekt eine Datei mit der Endung \textbf{.dts} dort stehen alle für das ausgewählte Board verfügbare Geräte drinnen.
    Im Fall des nativ\_posix\_64 sieht dieses folgendermaßen aus. 
    \begin{lstlisting}[style=StyleC, captionpos=b, caption=West Beispiel, label=West Beispiel]
/dts-v1/;

/ {
    #address-cells = < 0x1 >;
    #size-cells = < 0x1 >;
    model = "Native POSIX Board";
    compatible = "zephyr,posix";
    chosen {
        zephyr,console = &uart0;
        zephyr,shell-uart = &uart0;
        zephyr,uart-mcumgr = &uart0;
        zephyr,flash = &flash0;
        zephyr,entropy = &rng;
        zephyr,flash-controller = &flashcontroller0;
        zephyr,ec-host-interface = &hcp;
    };
    aliases {
        eeprom-0 = &eeprom0;
        i2c-0 = &i2c0;
        spi-0 = &spi0;
        led0 = &led0;
    };
    leds {
        compatible = "gpio-leds";
        led0: led_0 {
            gpios = < &gpio0 0x0 0x0 >;
            label = "Green LED";
        };
    };

    ...

    };
    uart0: uart {
        status = "okay";
        compatible = "zephyr,native-posix-uart";
        label = "UART_0";
        current-speed = < 0x0 >;
    };
    
    ...

};    
    \end{lstlisting}


\newpage
    \subsubsection{Tinycrypt}
    Tinycrypt ist eine kleine Kryptography Bibliothek, von Intel\footnote{\url{https://github.com/intel/tinycrypt}}, die in Assenbler geschreiben und in Zephyr implementiert wird.\footnote{\url{https://docs.zephyrproject.org/2.3.0/guides/crypto/tinycrypt.html?highlight=tinycrypt}}

     
\subsection{Linux Pseudoterminal}
Ein Pseudoterminal ist ein Dienst der eine bidirektionale Pipe, aufbaut. Sie werden verwendet um ein physisches Terminal zu emulieren. 
Im Fall von Zephyr mit dem nativ\_posx Board wird ein Pseudoterminal verwendet um mit dem Baord zu kommunizieren. Der Pfad dieses Terminals ist /dev/pts/.
\subsection{Threads}
Ein Thread ist eine sequentielle Reihe von Befehlen. Mehrere Threads können unabhängig voneinander gleichzeitig laufen. Somit können mehrere Aufgaben gleichzeitig erledigt werden. 

\subsection{Message-Queue}
Eine Message-Queue ist ein besonderer Buffer, ein FIFO-Buffer (First-In-First-Out-Buffer). Das bedeutet, es werden Nachrichten in einer Reihe in den Buffer geschrieben und es kann nur die
erste Nachricht in der Reihe herausgenommen werden, dabei wird diese nachricht im Buffer gelöscht und die nächste Nachricht rückt nach. 
Solche Message-Queues werden verwendet, um zwischen Threads die Daten korrekt auszutauschen. Da eine Nachricht beim auslesen gelöscht wird, können nicht mehrere Threads gleichzeitig auf 
die Nachricht zugreifen. 
\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{Message-Queue.pdf}
    \caption{Message-Queue-Darstellung}
    \label{fig:Message-Queue-Darstellung}
\end{figure}